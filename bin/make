const libcp = require('child_process');
const libos = require('os');
const libfs = require('fs');
const libpath = require('path');

/**
 * @typedef {{
 *   compiler: string;
 *   platform: string;
 *   arch: string;
 * }} Match
 *
 * @typedef {Match & {
 *   value: string;
 * }} Flag
 *
 * @typedef {Match & {
 *   path: string;
 * }} Export
 *
 * @typedef {Match & {
 *   path: string;
 * }} Import
 *
 * @typedef {Match & {
 *   path: string;
 * }} Include
 *
 * @typedef {Match & {
 *   path: string;
 * }} Compile
 *
 * @typedef {{
 *   path: string;
 *   modified: number;
 *   affects: string[];
 * }} Header
 *
 * @typedef {{
 *   name: string;
 *   type: string;
 *   flags: Flag[];
 *   include: Include[];
 *   compile: Compile[];
 *   export: Export[];
 *   import: Import[];
 * }} Config
 *
 * @typedef {{
 *   path: string;
 *   ready: boolean;
 *   error: string | null;
 *   args: string[];
 *   out: string;
 *   modified: number;
 * }} Source
 *
 * @typedef {{
 *   path: string;
 *   name: string;
 *   type: string;
 *   out: string;
 *   export: string[];
 *   sources: Source[];
 * }} Target
 */

/** @type {string} */
const ROOT = process.cwd();

/** @type {string} */
const COMPILER = 'clang++';

/** @type {string} */
const PLARTFORM = (() => {
    const plat = libos.platform();
    const remap = {
        'darwin': 'macos',
        'win32': 'windows'
    };
    return (remap[plat] ?? plat);
})()

/** @type {string} */
const ARCH = libos.arch();

/** @type {string[]} */
const DEBUG = ['-g', '-fsanitize=address'];

/** @type {string[]} */
const RELEASE = ['-O3'];

/**
 * @param {string} wildcard
 * @return {RegExp}
 */
const WildcardToRegExp = wildcard => {
    let path = wildcard.replace(/\\/g, '/');
    let regexp = path.replace(/([.+^=!:${}()|\[\]\/\\])/g, '\\$1');
    regexp = regexp.replace(/\*/g, '[^\\/]*');
    regexp = regexp.replace(/\?/g, '.');
    regexp = '^' + regexp + '$';
    return new RegExp(regexp);
}

/**
 * @template {Match} T
 * @param {T[]} entries
 * @return {T[]}
 */
const FilterByMatch = entries => {
    return entries.filter(e => (
           (e.platform.toLocaleLowerCase() === PLARTFORM || e.platform === '*')
        && (e.compiler.toLocaleLowerCase() === COMPILER || e.compiler === '*')
        && (e.arch.toLocaleLowerCase() === ARCH || e.arch === '*')
    ))
}

/**
 * @param {any} object
 * @return {Match}
 */
const ParseMatch = object => ({
    compiler: (object?.compiler ?? '*'),
    platform: (object?.platform ?? '*'),
    arch: (object?.arch ?? '*')
})

/**
 * @param {any} object
 * @return {Flag}
 */
const ParseFlag = object => ({
    ...ParseMatch(object),
    value: (object?.value ?? '')
})

/**
 * @param {any} object
 * @return {Import}
 */
const ParseImport = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Export}
 */
const ParseExport = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Include}
 */
const ParseInclude = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Compile}
 */
const ParseCompile = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Config}
 */
const ParseConfig = object => ({
    name: (object?.name ?? ''),
    type: (object?.type ?? 'executable'),
    flags: (object?.flags ?? []).map(ParseFlag),
    include: (object?.include ?? []).map(ParseInclude),
    compile: (object?.compile ?? []).map(ParseCompile),
    export: (object?.export ?? []).map(ParseExport),
    import: (object?.import ?? []).map(ParseImport)
})

/**
 * @param {string} path
 * @return {Target}
 */
const MakeTarget = path => {
    const config = (() => {
        try {
            return ParseConfig(
                JSON.parse(
                    libfs.readFileSync(path).toString()
                )
            );
        } catch (e) {
            throw new Error(`Failed to load config at path "${path}": ${e.message}`);
        }
    })();
    const base = libpath.dirname(path);
    const subtree = (
        libfs.readdirSync(base, { recursive: true })
            .map(path => path.toString())
            .map(path => libpath.join(base, path))
            .filter(path => !path.includes('.git'))
            .filter(path => libfs.statSync(path).isFile())
    )
    const flags = FilterByMatch(config.flags).map(f => f.value);
    const include = FilterByMatch(config.include).map(i => `-I${libpath.join(base, i.path)}`);
    const exports = FilterByMatch(config.export).map(e => `-I${libpath.join(base, e.path)}`);
    const [
        importInclude,
        importSources
    ] = (() => {
        /** @type {string[]} */
        let importInclude = [];
        /** @type {Source[]} */
        let importSources = [];
        for (const dep of FilterByMatch(config.import)) {
            const path = libpath.join(base, dep.path, 'make.config.json');
            if (libfs.existsSync(path)) {
                const target = MakeTarget(path);
                for (const source of target.sources) {
                    source.out = libpath.join(base, '.build', `${target.name}-${libpath.basename(source.out)}`);
                }
                importInclude = [ ...importInclude, ...target.export ];
                importSources = [ ...importSources, ...target.sources ];
            } else {
                throw new Error(`Dependency not found at path "${path}"`);
            }
        }
        return [ importInclude, importSources ];
    })();
    const sources = FilterByMatch(config.compile).reduce((
        /** @type {Source[]} */ acc,
        /** @type {Compile} */ comp
    ) => {
        const pattern = libpath.join(base, comp.path);
        const regexp = WildcardToRegExp(pattern);
        const sources = (
            subtree
                .filter(path => (PLARTFORM === 'windows') ? regexp.test(path.replace(/\\/g, '/')) : regexp.test(path))
                .map(path => {
                    const args = [ ...flags, ...importInclude, ...include ];
                    const out = libpath.join(base, '.build', `${path.replace(base, '').slice(1).split(libpath.sep).join('-')}.o`);
                    return ({ path, args, out, ready: false, error: null, modified: 0 });
                })
        );
        return [ ...acc, ...sources ];
    }, []);
    return {
        name: config.name,
        type: config.type,
        path: libpath.dirname(path),
        out: libpath.join(base, '.build', `${config.name}${PLARTFORM === 'windows' ? '.exe' : ''}`),
        export: exports,
        sources: [ ...importSources, ...sources ]
    }
}

/**
 * @param {Source} source
 * @return {boolean}
 */
const Compile = source => {
    const command = `${COMPILER} -c -fdiagnostics-color=always ${DEBUG.join(' ')} ${source.args.join(' ')} ${source.path} -o ${source.out}`;
    const basename = libpath.basename(source.path);
    try {
        if (libfs.existsSync(source.out)) {
            libfs.unlinkSync(source.out);
        }
        libfs.mkdirSync(libpath.dirname(source.out), { recursive: true });
        libcp.execSync(command);
        console.log(basename);
        return true;
    } catch (e) {
        console.log(command);
        if (e.stdout) process.stdout.write(e.stdout);
        if (e.stderr) process.stderr.write(e.stderr);
        return false;
    }
}

/**
 * @param {Target} target
 * @return {void}
 */
const Link = target => {
    try {
        if (libfs.existsSync(target.out)) {
            libfs.unlinkSync(target.out);
        }
        libfs.mkdirSync(libpath.dirname(target.out), { recursive: true });
        if (target.sources.every(s => libfs.existsSync(s.out))) {
            libcp.execSync(`${COMPILER} ${target.sources.map(s => s.out).join(' ')} -o ${target.out}`);
        }
    } catch (e) {
        if (e.stdout) process.stdout.write(e.stdout);
        if (e.stderr) process.stderr.write(e.stderr);
    }
}

/** @type {string[] | undefined} */
let __subtree = undefined;

/** @type {Target[] | undefined} */
let __targets = undefined;

/** @return {string[]} */
const SubTree = () => {
    if (!__subtree) {
        __subtree = (
            libfs.readdirSync(ROOT, { recursive: true })
                .map(path => path.toString())
                .map(path => libpath.join(ROOT, path))
                .filter(path => !path.includes('.git'))
                .filter(path => libfs.statSync(path).isFile())
        )
    }
    return __subtree;
}

/** @return {Target[]} */
const Targets = () => {
    if (!__targets) {
        __targets = (
            libfs.readdirSync(ROOT, { recursive: true })
                .map(path => libpath.join(ROOT, path))
                .filter(path => libpath.basename(path) === 'make.config.json')
                .map(path => MakeTarget(path))
        )
    }
    return __targets;
}

/** @return {void} */
const Dev = () => {
    /** @type {Header[]} */
    const headers = [];

    /**
     * @param {string} path
     * @return {void}
     */
    const proc = path => {
        const [ paths, force ] = (() => {
            const header = headers.find(h => h.path === path);
            if (header) {
                const modified = libfs.statSync(path).mtime.getTime();
                if (header.modified !== modified) {
                    header.modified = modified;
                    return [ header.affects, true ];
                } else {
                    return [ [], false ];
                }
            } else {
                return [ [path], false ];
            }
        })()
        for (const path of paths) {
            for (const target of Targets()) {
                const source = target.sources.find(s => s.path === path);
                if (source) {
                    const MM = (() => {
                        try {
                            return (
                                libcp.execSync(`${COMPILER} -MM ${source.args.join(' ')} ${source.path}`)
                                    .toString()
                                    .split('\n')
                                    .slice(1)
                                    .map(path => path.trim().replace(/\ \\$/, ''))
                                    .filter(path => libfs.existsSync(path))
                            )
                        } catch (e) {
                            return [];
                        }
                    })();
                    for (const header of headers) {
                        header.affects = header.affects.filter(p => p !== source.path)
                    }
                    for (const path of MM) {
                        let header = headers.find(h => h.path === path);
                        if (!header) {
                            header = {
                                path,
                                modified: libfs.statSync(path).mtime.getTime(),
                                affects: [source.path]
                            }
                            headers.push(header);
                        } else {
                            header.affects.push(source.path);
                        }
                    }
                    const modified = libfs.statSync(path).mtime.getTime();
                    if ((source.modified !== modified) || force) {
                        source.modified = modified;
                        if (!Compile(source)) return;
                        if (target.type === 'executable') {
                            Link(target);
                        }
                    }
                }
            }
        }
    }

    for (const target of Targets()) {
        for (const source of target.sources) {
            proc(source.path);
        }
        for (const path of [libpath.join(target.path, 'include'),
                            libpath.join(target.path, 'src')]) {
            if (libfs.existsSync(path)) {
                libfs.watch(path, { recursive: true }, (event, filename) => {
                    if ((event === 'change')
                    && filename !== null) {
                        proc(libpath.join(path, filename));
                    }
                });
            }
        }
    }
}

Dev();