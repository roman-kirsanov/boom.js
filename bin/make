const libcp = require('child_process');
const libos = require('os');
const libfs = require('fs');
const libpath = require('path');

/**
 * @typedef {{
 *   compiler: string;
 *   platform: string;
 *   arch: string;
 * }} Match
 *
 * @typedef {Match & {
 *   value: string;
 * }} Flag
 *
 * @typedef {Match & {
 *   path: string;
 * }} Export
 *
 * @typedef {Match & {
 *   path: string;
 * }} Import
 *
 * @typedef {Match & {
 *   path: string;
 * }} Include
 *
 * @typedef {Match & {
 *   path: string;
 * }} Compile
 *
 * @typedef {Match & {
 *   name: string;
 * }} Link
 *
 * @typedef {{
 *   path: string;
 *   name: string;
 *   type: string;
 *   flags: Flag[];
 *   include: Include[];
 *   compile: Compile[];
 *   export: Export[];
 *   import: Import[];
 *   link: Link[];
 * }} Config
 *
 * @typedef {{
 *   path: string;
 *   modified: number;
 * }} Header
 *
 * @typedef {{
 *   path: string;
 *   ready: boolean;
 *   error: string | null;
 *   args: string[];
 *   out: string;
 *   modified: number;
 *   depends: Header[];
 *   onReady: (callback: Function) => void;
 * }} Source
 *
 * @typedef {{
 *   path: string;
 *   name: string;
 *   type: string;
 *   out: string;
 *   sources: Source[];
 *   imports: Target[];
 *   exports: string[];
 *   libraries: string[];
 *   onReady: (callback: Function) => void;
 * }} Target
 *
 * @typedef {{
 *   onChange: (callback: (path: string) => void) => void
 * }} Watch
 */

/** @type {string} */
const ROOT = process.cwd();

/** @type {string} */
const COMPILER = 'clang++';

/** @type {string} */
const PLARTFORM = (() => {
    const plat = libos.platform();
    const remap = {
        'darwin': 'macos',
        'win32': 'windows'
    };
    return (remap[plat] ?? plat);
})()

/** @type {string} */
const ARCH = libos.arch();

/** @type {string[]} */
const DEBUG = ['-g', '-fsanitize=address'];

/** @type {string[]} */
const RELEASE = ['-O3'];

/**
 * @param {string} wildcard
 * @return {RegExp}
 */
const WildcardToRegExp = wildcard => {
    let path = wildcard.replace(/\\/g, '/');
    let regexp = path.replace(/([.+^=!:${}()|\[\]\/\\])/g, '\\$1');
    regexp = regexp.replace(/\*/g, '[^\\/]*');
    regexp = regexp.replace(/\?/g, '.');
    regexp = '^' + regexp + '$';
    return new RegExp(regexp);
}

/**
 * @template {Match} T
 * @param {T[]} entries
 * @return {T[]}
 */
const FilterByMatch = entries => {
    return entries.filter(e => (
           (e.platform.toLocaleLowerCase() === PLARTFORM || e.platform === '*')
        && (e.compiler.toLocaleLowerCase() === COMPILER || e.compiler === '*')
        && (e.arch.toLocaleLowerCase() === ARCH || e.arch === '*')
    ))
}

/**
 * @param {any} object
 * @return {Match}
 */
const ParseMatch = object => ({
    compiler: (object?.compiler ?? '*'),
    platform: (object?.platform ?? '*'),
    arch: (object?.arch ?? '*')
})

/**
 * @param {any} object
 * @return {Flag}
 */
const ParseFlag = object => ({
    ...ParseMatch(object),
    value: (object?.value ?? '')
})

/**
 * @param {any} object
 * @return {Import}
 */
const ParseImport = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Export}
 */
const ParseExport = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Include}
 */
const ParseInclude = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Compile}
 */
const ParseCompile = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Link}
 */
const ParseLink = object => ({
    ...ParseMatch(object),
    name: (object?.name ?? '')
})

/**
 * @param {string} path
 * @return {string[]}
 */
const SubTree = path => (
    libfs.readdirSync(path, { recursive: true })
        .map(filename => filename.toString())
        .map(filename => libpath.join(path, filename))
        .filter(path => !path.includes('.git'))
        .filter(path => libfs.statSync(path).isFile())
);

/** @type {Watch | undefined} */
let __watch = undefined;

/** @type {Source[]} */
let __sources = [];

/** @type {Config[]} */
let __configs = [];

/** @type {Target[]} */
let __targets = [];

/**
 * @return {Watch}
 */
const Watch = () => {
    if (!__watch) {
        /** @type {((path: string) => void)[]} */
        const callbacks = [];
        __watch = {
            onChange: callback => callbacks.push(callback)
        }
        libfs.watch(ROOT, { recursive: true }, (event, filename) => {
            if ((event === 'change') && filename) {
                const path = libpath.join(ROOT, filename);
                for (const callback of callbacks) {
                    try {
                        callback(path);
                    } catch (e) {
                        console.log(`ERROR: ${e.message}`);
                    }
                }
            }
        })
    }
    return __watch;
}

/**
 * @param {string} path
 * @return {Source}
 */
const Source = path => {
    const source = __sources.find(s => s.path === path);
    if (source) return source;
    else {
        if (libfs.existsSync(path)) {
            /** @type {Set<Function>} */
            const callbacks = new Set();
            /** @type {Source} */
            const source = {
                path,
                args: [],
                error: null,
                ready: false,
                modified: 0,
                out: '',
                depends: [],
                onReady: callback => callbacks.add(callback)
            }
            const compile = () => {
                const command = `${COMPILER} -c -fdiagnostics-color=always ${DEBUG.join(' ')} ${source.args.join(' ')} ${source.path} -o ${source.out}`;
                try {
                    const modified = libfs.statSync(source.path).mtime.getTime();
                    const depends = (
                        libcp.execSync(`${COMPILER} -MM ${source.args.join(' ')} ${source.path}`)
                            .toString()
                            .split('\n')
                            .slice(1)
                            .map(path => path.trim().replace(/\ \\$/, ''))
                            .filter(path => libfs.existsSync(path))
                            .map(path => {
                                /** @type {Header} */
                                const header = {
                                    path,
                                    modified: libfs.statSync(path).mtime.getTime()
                                }
                                return header;
                            })
                    );
                    source.ready = (
                           (source.modified === modified)
                        && (source.depends.length === depends.length)
                        && (source.depends.every(lh => depends.find(rh => rh.path === lh.path)?.modified === lh.modified))
                    );
                    source.depends = depends;
                    source.modified = modified;
                    if (source.ready === false) {
                        console.log(`ðŸ“„ ${source.path.replace(ROOT, '').slice(1)}`);
                        if (libfs.existsSync(source.out)) {
                            libfs.unlinkSync(source.out);
                        }
                        libfs.mkdirSync(libpath.dirname(source.out), { recursive: true });
                        libcp.execSync(command);
                        source.ready = true;
                        for (const callback of callbacks) {
                            callback();
                        }
                    }
                } catch (e) {
                    source.ready = false;
                    console.log(command);
                    if (e.stdout) process.stdout.write(e.stdout);
                    if (e.stderr) process.stderr.write(e.stderr);
                }
            }
            Watch().onChange(path => {
                if (path === source.path) {
                    compile();
                } else {
                    for (const source of __sources) {
                        if (source.depends.some(d => d.path === path)) {
                            source.ready = false;
                        }
                    }
                    if (source.depends.some(d => d.path === path)) {
                        setTimeout(compile, 100);
                    }
                }
            });
            setTimeout(compile, 100);
            __sources.push(source);
            return source;
        } else {
            throw new Error(`Source file not found at path "${path}"`);
        }
    }
}

/**
 * @param {string} path
 * @return {Config}
 */
const Config = path => {
    const config = __configs.find(c => c.path === path);
    if (config) return config;
    else {
        try {
            if (libfs.existsSync(path)) {
                const json = JSON.parse(libfs.readFileSync(path).toString());
                const config = {
                    path,
                    name: (json?.name ?? ''),
                    type: (json?.type ?? 'executable'),
                    flags: (json?.flags ?? []).map(ParseFlag),
                    include: (json?.include ?? []).map(ParseInclude),
                    compile: (json?.compile ?? []).map(ParseCompile),
                    export: (json?.export ?? []).map(ParseExport),
                    import: (json?.import ?? []).map(ParseImport),
                    link: (json?.link ?? []).map(ParseLink)
                }
                if (['library', 'executable'].includes(config.type) === false) {
                    throw new Error(`Target type "${config.type}" is not supported, use "executable" or "library"`);
                }
                __configs.push(config);
                return config;
            } else {
                throw new Error('Config not found');
            }
        } catch (e) {
            throw new Error(`Failed to load config at path: "${path}": ${e.message}`);
        }
    }
}

/**
 * @param {string} path
 * @return {Target}
 */
const Target = path => {
    const target = __targets.find(t => t.path === path);
    if (target) return target;
    else {
        /**
         * @param {Target[]} targets
         * @param {(target: Target) => void} callback
         * @return {void}
         */
        const traverse = (targets, callback) => {
            for (const target of targets) {
                traverse(target.imports, callback);
                callback(target);
            }
        }
        const subtree = SubTree(path);
        const config = Config(libpath.join(path, 'make.config.json'));
        const flags = FilterByMatch(config.flags).map(f => f.value);
        const libraries = FilterByMatch(config.link).map(l => l.name);
        const include = FilterByMatch(config.include).map(i => libpath.join(path, i.path));
        const exports = FilterByMatch(config.export).map(e => libpath.join(path, e.path));
        const imports = FilterByMatch(config.import).map(i => Target(libpath.join(path, i.path)));
        const compile = FilterByMatch(config.compile).reduce((
            /** @type {string[]} */ acc,
            /** @type {Compile} */ comp
        ) => {
            const pattern = libpath.join(path, comp.path);
            const regexp = WildcardToRegExp(pattern);
            const compile = subtree.filter(path => (PLARTFORM === 'windows') ? regexp.test(path.replace(/\\/g, '/')) : regexp.test(path));
            return [ ...acc, ...compile ];
        }, [])
        const [
            importInclude,
            importLibraries,
            importTargets,
        ] = (() => {
            /** @type {string[]} */
            let include = [];
            /** @type {string[]} */
            let libraries = [];
            /** @type {string[]} */
            let targets = [];
            traverse(imports, target => {
                include = [ ...include, ...target.exports ];
                libraries = [ ...libraries, ...target.libraries ];
                targets = [ ...targets, target.out ];
            });
            return [ include, libraries, targets ];
        })();
        const sources = compile.map(comp => {
            const source = Source(comp);
            source.out = libpath.join(path, '.build', `${comp.replace(path, '').slice(1).split(libpath.sep).join('-')}.o`);
            source.args = [
                ...flags,
                ...importInclude.map(i => `-I${i}`),
                ...include.map(i => `-I${i}`)
            ];
            return source;
        })
        /** @type {Set<Function>} */
        const callbacks = new Set();
        /** @type {Target} */
        const target = {
            path,
            type: config.type,
            name: config.name,
            exports,
            imports,
            sources,
            libraries,
            out: (
                (PLARTFORM === 'windows')
                    ? (libpath.join(path, '.build', config.name + (config.type === 'executable' ? '.exe' : '.lib') ))
                    : (libpath.join(path, '.build', config.name + (config.type === 'executable' ? '' : '.a') ))
            ),
            onReady: callback => callbacks.add(callback)
        }
        const link = () => {
            if (target.sources.every(s => s.ready)) {
                if (target.type === 'executable') {
                    const command = `${COMPILER} ${DEBUG.join(' ')} ${target.sources.map(s => s.out).join(' ')} ${importTargets.join(' ')} ${importLibraries.map(l => `-l${l}`).join(' ')} -o ${target.out}`;
                    try {
                        console.log(`ðŸš€ ${target.out.replace(ROOT, '').slice(1)}`);
                        if (libfs.existsSync(target.out)) {
                            libfs.unlinkSync(target.out);
                        }
                        libfs.mkdirSync(libpath.dirname(target.out), { recursive: true });
                        libcp.execSync(command);
                        for (const callback of callbacks) {
                            callback();
                        }
                    } catch (e) {
                        console.log(command);
                        if (e.stdout) process.stdout.write(e.stdout);
                        if (e.stderr) process.stderr.write(e.stderr);
                    }
                } else if (target.type === 'library') {
                    const ar = ((PLARTFORM === 'windows') ? 'llvm-ar' : 'ar');
                    const command = `${ar} cr ${target.out} ${target.sources.map(s => s.out).join(' ')}`;
                    try {
                        console.log(`ðŸ“¦ ${target.out.replace(ROOT, '').slice(1)}`);
                        if (libfs.existsSync(target.out)) {
                            libfs.unlinkSync(target.out);
                        }
                        libfs.mkdirSync(libpath.dirname(target.out), { recursive: true });
                        libcp.execSync(command);
                        for (const callback of callbacks) {
                            callback();
                        }
                    } catch (e) {
                        console.log(command);
                        if (e.stdout) process.stdout.write(e.stdout);
                        if (e.stderr) process.stderr.write(e.stderr);
                    }
                }
            }
        }
        for (const subtarget of target.imports) {
            subtarget.onReady(link);
        }
        for (const source of target.sources) {
            source.onReady(link);
        }
        __targets.push(target);
        return target;
    }
}

libfs.readdirSync(ROOT, { recursive: true })
    .map(path => libpath.join(ROOT, path))
    .filter(path => libpath.basename(path) === 'make.config.json')
    .forEach(path => Target(libpath.dirname(path)));