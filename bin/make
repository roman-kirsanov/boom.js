const libcp = require('child_process');
const libos = require('os');
const libfs = require('fs');
const libpath = require('path');

/**
 * @typedef {{
 *   compiler: string;
 *   platform: string;
 *   arch: string;
 * }} Match
 *
 * @typedef {Match & {
 *   value: string;
 * }} Flag
 *
 * @typedef {Match & {
 *   path: string;
 * }} Include
 *
 * @typedef {Match & {
 *   path: string;
 * }} Compile
 *
 * @typedef {{
 *   path: string;
 *   modified: number;
 *   affects: string[];
 * }} Header
 *
 * @typedef {{
 *   name: string;
 *   flags: Flag[];
 *   include: Include[];
 *   compile: Compile[];
 * }} Config
 *
 * @typedef {{
 *   path: string;
 *   ready: boolean;
 *   error: string | null;
 *   args: string[];
 *   out: string;
 *   modified: number;
 * }} Source
 *
 * @typedef {{
 *   path: string;
 *   name: string;
 *   sources: Source[];
 *   modified: number;
 * }} Target
 */

/** @type {string} */
const ROOT = process.cwd();

/** @type {string} */
const COMPILER = 'clang++';

/** @type {string} */
const PLARTFORM = (() => {
    const plat = libos.platform();
    const remap = {
        'darwin': 'macos',
        'win32': 'windows'
    };
    return (remap[plat] ?? plat);
})()

/** @type {string} */
const ARCH = libos.arch();

/** @type {string[]} */
const DEBUG = ['-g', '-fsanitize=address'];

/** @type {string[]} */
const RELEASE = ['-O3'];

/**
 * @param {string} wildcard
 * @return {RegExp}
 */
const WildcardToRegExp = wildcard => {
    let path = wildcard.replace(/\\/g, '/');
    let regexp = path.replace(/([.+^=!:${}()|\[\]\/\\])/g, '\\$1');
    regexp = regexp.replace(/\*/g, '[^\\/]*');
    regexp = regexp.replace(/\?/g, '.');
    regexp = '^' + regexp + '$';
    return new RegExp(regexp);
}

/**
 * @template {Match} T
 * @param {T[]} entries
 * @return {T[]}
 */
const FilterByMatch = entries => {
    return entries.filter(e => (
           (e.platform.toLocaleLowerCase() === PLARTFORM || e.platform === '*')
        && (e.compiler.toLocaleLowerCase() === COMPILER || e.compiler === '*')
        && (e.arch.toLocaleLowerCase() === ARCH || e.arch === '*')
    ))
}

/**
 * @param {any} object
 * @return {Match}
 */
const ParseMatch = object => ({
    compiler: (object?.compiler ?? '*'),
    platform: (object?.platform ?? '*'),
    arch: (object?.arch ?? '*')
})

/**
 * @param {any} object
 * @return {Flag}
 */
const ParseFlag = object => ({
    ...ParseMatch(object),
    value: (object?.value ?? '')
})

/**
 * @param {any} object
 * @return {Include}
 */
const ParseInclude = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Compile}
 */
const ParseCompile = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Config}
 */
const ParseConfig = object => ({
    name: (object?.name ?? ''),
    flags: (object?.flags ?? []).map(ParseFlag),
    include: (object?.include ?? []).map(ParseInclude),
    compile: (object?.compile ?? []).map(ParseCompile)
})

/**
 * @param {Source} source
 * @return {boolean}
 */
const Compile = source => {
    try {
        if (libfs.existsSync(source.out)) {
            libfs.unlinkSync(source.out);
        }
        libfs.mkdirSync(libpath.dirname(source.out), { recursive: true });
        libcp.execSync(`${COMPILER} -c -fdiagnostics-color=always ${DEBUG.join(' ')} ${source.args.join(' ')} ${source.path} -o ${source.out}`);
        console.log(libpath.basename(source.path));
        return true;
    } catch (e) {
        if (e.stdout) process.stdout.write(e.stdout);
        if (e.stderr) process.stderr.write(e.stderr);
        return false;
    }
}

/** @type {string[] | undefined} */
let __subtree = undefined;

/** @type {Target[] | undefined} */
let __targets = undefined;

/** @return {string[]} */
const SubTree = () => {
    if (!__subtree) {
        __subtree = (
            libfs.readdirSync(ROOT, { recursive: true })
                .map(path => path.toString())
                .map(path => libpath.join(ROOT, path))
                .filter(path => !path.includes('.git'))
                .filter(path => libfs.statSync(path).isFile())
        )
    }
    return __subtree;
}

/** @return {Target[]} */
const Targets = () => {
    if (!__targets) {
        __targets = (
            libfs.readdirSync(ROOT, { recursive: true })
                .map(path => libpath.join(ROOT, path))
                .filter(path => libpath.basename(path) === 'make.config.json')
                .map(path => {
                    try {
                        /** @type {[ string, string, Config ]} */
                        const ret = [ libpath.dirname(path), path, ParseConfig(
                            JSON.parse(
                                libfs.readFileSync(path).toString()
                            )
                        )];
                        return ret;
                    } catch (e) {
                        throw new Error(`Failed to load config at path "${path}": ${e.message}`);
                    }
                })
                .map(([ base, path, config ]) => {
                    const flags = FilterByMatch(config.flags);
                    const include = FilterByMatch(config.include);
                    const compile = FilterByMatch(config.compile);
                    const sources = compile.reduce((
                        /** @type {Source[]} */ acc,
                        /** @type {Compile} */ comp
                    ) => {
                        const pattern = libpath.join(base, comp.path);
                        const regexp = WildcardToRegExp(pattern);
                        const sources = (
                            SubTree()
                                .filter(path => (PLARTFORM === 'windows') ? regexp.test(path.replace(/\\/g, '/')) : regexp.test(path))
                                .map(path => {
                                    const args = [ ...flags.map(f => f.value), ...include.map(i => `-I${libpath.join(base, i.path)}`) ];
                                    const out = libpath.join(base, '.build', `${path.replace(base, '').slice(1).split(libpath.sep).join('-')}.o`);
                                    return ({ path, args, out, ready: false, error: null, modified: 0 });
                                })
                        );
                        return [ ...acc, ...sources ];
                    }, []);
                    return {
                        name: config.name,
                        path: libpath.dirname(path),
                        sources,
                        modified: 0
                    }
                })
        )
    }
    return __targets;
}

/** @return {void} */
const Dev = () => {
    /** @type {Header[]} */
    const headers = [];

    /**
     * @param {string} path
     * @return {void}
     */
    const proc = path => {
        const [ paths, force ] = (() => {
            const header = headers.find(h => h.path === path);
            if (header) {
                const modified = libfs.statSync(path).mtime.getTime();
                if (header.modified !== modified) {
                    header.modified = modified;
                    return [ header.affects, true ];
                } else {
                    return [ [], false ];
                }
            } else {
                return [ [path], false ];
            }
        })()
        for (const path of paths) {
            for (const target of Targets()) {
                const source = target.sources.find(s => s.path === path);
                if (source) {
                    const MM = (
                        libcp.execSync(`${COMPILER} -MM ${source.args.join(' ')} ${source.path}`)
                            .toString()
                            .split('\n')
                            .slice(1)
                            .map(path => path.trim().replace(/\ \\$/, ''))
                            .filter(path => libfs.existsSync(path))
                    );
                    for (const header of headers) {
                        header.affects = header.affects.filter(p => p !== source.path)
                    }
                    for (const path of MM) {
                        let header = headers.find(h => h.path === path);
                        if (!header) {
                            header = {
                                path,
                                modified: libfs.statSync(path).mtime.getTime(),
                                affects: [source.path]
                            }
                            headers.push(header);
                        } else {
                            header.affects.push(source.path);
                        }
                    }
                    const modified = libfs.statSync(path).mtime.getTime();
                    if ((source.modified !== modified) || force) {
                        source.modified = modified;
                        if (!Compile(source)) return;
                    }
                }
            }
        }
    }

    for (const target of Targets()) {
        for (const source of target.sources) {
            proc(source.path);
        }
        for (const path of [libpath.join(target.path, 'include'),
                            libpath.join(target.path, 'src')]) {
            libfs.watch(path, { recursive: true }, (event, filename) => {
                if ((event === 'change')
                && filename !== null) {
                    proc(libpath.join(path, filename));
                }
            });
        }
    }
}

Dev();