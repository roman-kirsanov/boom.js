const libcp = require('child_process');
const libos = require('os');
const libfs = require('fs');
const libpath = require('path');

/**
 * @typedef {{
 *   compiler: string;
 *   platform: string;
 *   arch: string;
 * }} Match
 *
 * @typedef {Match & {
 *   value: string;
 * }} Flag
 *
 * @typedef {Match & {
 *   path: string;
 * }} Include
 *
 * @typedef {Match & {
 *   path: string;
 * }} Compile
 *
 * @typedef {{
 *   name: string;
 *   flags: Flag[];
 *   include: Include[];
 *   compile: Compile[];
 * }} Config
 *
 * @typedef {{
 *   path: string;
 *   args: string[];
 *   compile: boolean;
 *   deps: [string, number][];
 * }} Unit
 */

/** @type {string} */
const ROOT = process.cwd();

/** @type {string} */
const COMPILER = 'clang++';

/** @type {string} */
const PLARTFORM = (() => {
    const plat = libos.platform();
    const remap = {
        'darwin': 'macos',
        'win32': 'windows'
    };
    return (remap[plat] ?? plat);
})()

/** @type {string} */
const ARCH = libos.arch();

/**
 * @param {string} wildcard
 * @return {RegExp}
 */
const WildcardToRegExp = wildcard => {
    let path = wildcard.replace(/\\/g, '/');
    let regexp = path.replace(/([.+^=!:${}()|\[\]\/\\])/g, '\\$1');
    regexp = regexp.replace(/\*/g, '[^\\/]*');
    regexp = regexp.replace(/\?/g, '.');
    regexp = '^' + regexp + '$';
    return new RegExp(regexp);
}

/**
 * @param {any} object
 * @return {Match}
 */
const ParseMatch = object => ({
    compiler: (object?.compiler ?? '*'),
    platform: (object?.platform ?? '*'),
    arch: (object?.arch ?? '*')
})

/**
 * @param {any} object
 * @return {Flag}
 */
const ParseFlag = object => ({
    ...ParseMatch(object),
    value: (object?.value ?? '')
})

/**
 * @param {any} object
 * @return {Include}
 */
const ParseInclude = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Compile}
 */
const ParseCompile = object => ({
    ...ParseMatch(object),
    path: (object?.path ?? '')
})

/**
 * @param {any} object
 * @return {Config}
 */
const ParseConfig = object => ({
    name: (object?.name ?? ''),
    flags: (object?.flags ?? []).map(ParseFlag),
    include: (object?.include ?? []).map(ParseInclude),
    compile: (object?.compile ?? []).map(ParseCompile)
})

/**
 * @template {Match} T
 * @param {T[]} entries
 * @return {T[]}
 */
const FilterByMatch = entries => {
    return entries.filter(e => (
           (e.platform.toLocaleLowerCase() === PLARTFORM || e.platform === '*')
        && (e.compiler.toLocaleLowerCase() === COMPILER || e.compiler === '*')
        && (e.arch.toLocaleLowerCase() === ARCH || e.arch === '*')
    ))
}

/**
 * @param {string} path
 * @param {string[]} args
 * @return {[string, number][]}
 */
const Deps = (path, args) => (
    libcp.execSync(`${COMPILER} -MM ${args.join(' ')} ${path}`)
        .toString()
        .split('\n')
        .slice(1)
        .map(path => path.trim().replace(/\ \\$/, ''))
        .filter(path => libfs.existsSync(path))
        .map(path => [path, 0])
)

/**
 * @param {string} path
 * @param {string[]} flags
 * @param {string} output
 * @return {void}
 */
const Compile = (path, flags, output) => {
    ;
}

/** @type {string[] | undefined} */
let __subtree = undefined;

/** @type {Config | undefined} */
let __config = undefined;

/** @type {Unit[] | undefined} */
let __units = undefined;

/** @return {string[]} */
const SubTree = () => {
    if (!__subtree) {
        __subtree = (
            libfs.readdirSync(ROOT, { recursive: true })
                .map(path => libpath.join(ROOT, path))
                .filter(path => libfs.statSync(path).isFile())
        )
    }
    return __subtree;
}

/** @return {Config} */
const Config = () => {
    if (!__config) {
        try {
            const path = libpath.join(ROOT, 'make.config.json');
            const data = libfs.readFileSync(path).toString();
            const json = JSON.parse(data);
            __config = ParseConfig(json);
        } catch (e) {
            throw new Error(`Failed to load config: ${e.message}`);
        }
    }
    return __config;
}

/** @return {Unit[]} */
const Units = () => {
    if (!__units) {
        const flags = FilterByMatch(Config().flags);
        const include = FilterByMatch(Config().include);
        const compile = FilterByMatch(Config().compile);
        __units = compile.reduce((
            /** @type {Unit[]} */ acc,
            /** @type {Compile} */ comp
        ) => {
            const path = libpath.join(ROOT, comp.path);
            const regex = WildcardToRegExp(path);
            const units = (
                SubTree()
                    .filter(path => (PLARTFORM === 'windows') ? regex.test(path.replace(/\\/g, '/')) : regex.test(path))
                    .map(path => {
                        const args = [ ...flags.map(f => f.value), ...include.map(i => `-I${libpath.join(ROOT, i.path)}`) ];
                        const deps = Deps(path, args);
                        return ({ path, args, deps, compile: true });
                    })
            );
            return [ ...acc, ...units ];
        }, []);
    }
    return __units;
}

console.log(
`Boom build system [version 0.0.1]
Compiler: ${COMPILER}
Platform: ${PLARTFORM}
Arch: ${ARCH}
`);

const [ ,, command, ...args ] = process.argv;

try {
    if ((command === 'build')
    || (command === 'dev')) {
        console.dir(Units(), { depth: 10 });
    } else {
        throw new Error('Wrong command');
    }
} catch (e) {
    console.error(`ERROR: ${e.message}`);
}