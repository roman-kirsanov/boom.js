#pragma once

#include <optional>
#include <Boom/Memory.hpp>

namespace boom {

struct __OpenGLImpl;

class Window;
class OpenGL;

struct OpenGLOptions {
    std::optional<std::shared_ptr<boom::OpenGL>> shared;
    std::optional<std::shared_ptr<boom::Window>> window;
    std::optional<std::int32_t> majorVersion;
    std::optional<std::int32_t> minorVersion;
};

class OpenGL final : public boom::Shared {
public:
    OpenGL(boom::OpenGLOptions const& = {});
    void accum(std::uint32_t op, float value);
    void activeShaderProgram(std::uint32_t pipeline, std::uint32_t program);
    void activeTexture(std::uint32_t texture);
    void alphaFunc(std::uint32_t func, float ref);
    void alphaFuncx(std::uint32_t func, std::int32_t ref);
    std::uint8_t areTexturesResident(std::int32_t n, std::uint32_t const* textures, std::uint8_t* residences);
    void arrayElement(std::int32_t i);
    void attachShader(std::uint32_t program, std::uint32_t shader);
    void begin(std::uint32_t mode);
    void beginConditionalRender(std::uint32_t id, std::uint32_t mode);
    void beginQuery(std::uint32_t target, std::uint32_t id);
    void beginQueryIndexed(std::uint32_t target, std::uint32_t index, std::uint32_t id);
    void beginTransformFeedback(std::uint32_t primitiveMode);
    void bindAttribLocation(std::uint32_t program, std::uint32_t index, char const* name);
    void bindBuffer(std::uint32_t target, std::uint32_t buffer);
    void bindBufferBase(std::uint32_t target, std::uint32_t index, std::uint32_t buffer);
    void bindBufferRange(std::uint32_t target, std::uint32_t index, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void bindBuffersBase(std::uint32_t target, std::uint32_t first, std::int32_t count, std::uint32_t const* buffers);
    void bindBuffersRange(std::uint32_t target, std::uint32_t first, std::int32_t count, std::uint32_t const* buffers, std::intptr_t const* offsets, std::int64_t const* sizes);
    void bindFragDataLocation(std::uint32_t program, std::uint32_t color, char const* name);
    void bindFragDataLocationIndexed(std::uint32_t program, std::uint32_t colorNumber, std::uint32_t index, char const* name);
    void bindFramebuffer(std::uint32_t target, std::uint32_t framebuffer);
    void bindImageTexture(std::uint32_t unit, std::uint32_t texture, std::int32_t level, std::uint8_t layered, std::int32_t layer, std::uint32_t access, std::uint32_t format);
    void bindImageTextures(std::uint32_t first, std::int32_t count, std::uint32_t const* textures);
    void bindProgramPipeline(std::uint32_t pipeline);
    void bindRenderbuffer(std::uint32_t target, std::uint32_t renderbuffer);
    void bindSampler(std::uint32_t unit, std::uint32_t sampler);
    void bindSamplers(std::uint32_t first, std::int32_t count, std::uint32_t const* samplers);
    void bindTexture(std::uint32_t target, std::uint32_t texture);
    void bindTextureUnit(std::uint32_t unit, std::uint32_t texture);
    void bindTextures(std::uint32_t first, std::int32_t count, std::uint32_t const* textures);
    void bindTransformFeedback(std::uint32_t target, std::uint32_t id);
    void bindVertexArray(std::uint32_t array);
    void bindVertexBuffer(std::uint32_t bindingindex, std::uint32_t buffer, std::intptr_t offset, std::int32_t stride);
    void bindVertexBuffers(std::uint32_t first, std::int32_t count, std::uint32_t const* buffers, std::intptr_t const* offsets, std::int32_t const* strides);
    void bitmap(std::int32_t width, std::int32_t height, float xorig, float yorig, float xmove, float ymove, std::uint8_t const* bitmap);
    void blendBarrier();
    void blendColor(float red, float green, float blue, float alpha);
    void blendEquation(std::uint32_t mode);
    void blendEquationSeparate(std::uint32_t modeRGB, std::uint32_t modeAlpha);
    void blendEquationSeparatei(std::uint32_t buf, std::uint32_t modeRGB, std::uint32_t modeAlpha);
    void blendEquationi(std::uint32_t buf, std::uint32_t mode);
    void blendFunc(std::uint32_t sfactor, std::uint32_t dfactor);
    void blendFuncSeparate(std::uint32_t sfactorRGB, std::uint32_t dfactorRGB, std::uint32_t sfactorAlpha, std::uint32_t dfactorAlpha);
    void blendFuncSeparatei(std::uint32_t buf, std::uint32_t srcRGB, std::uint32_t dstRGB, std::uint32_t srcAlpha, std::uint32_t dstAlpha);
    void blendFunci(std::uint32_t buf, std::uint32_t src, std::uint32_t dst);
    void blitFramebuffer(std::int32_t srcX0, std::int32_t srcY0, std::int32_t srcX1, std::int32_t srcY1, std::int32_t dstX0, std::int32_t dstY0, std::int32_t dstX1, std::int32_t dstY1, std::uint32_t mask, std::uint32_t filter);
    void blitNamedFramebuffer(std::uint32_t readFramebuffer, std::uint32_t drawFramebuffer, std::int32_t srcX0, std::int32_t srcY0, std::int32_t srcX1, std::int32_t srcY1, std::int32_t dstX0, std::int32_t dstY0, std::int32_t dstX1, std::int32_t dstY1, std::uint32_t mask, std::uint32_t filter);
    void bufferData(std::uint32_t target, std::int64_t size, void const* data, std::uint32_t usage);
    void bufferStorage(std::uint32_t target, std::int64_t size, void const* data, std::uint32_t flags);
    void bufferSubData(std::uint32_t target, std::intptr_t offset, std::int64_t size, void const* data);
    void callList(std::uint32_t list);
    void callLists(std::int32_t n, std::uint32_t type, void const* lists);
    std::uint32_t checkFramebufferStatus(std::uint32_t target);
    std::uint32_t checkNamedFramebufferStatus(std::uint32_t framebuffer, std::uint32_t target);
    void clampColor(std::uint32_t target, std::uint32_t clamp);
    void clear(std::uint32_t mask);
    void clearAccum(float red, float green, float blue, float alpha);
    void clearBufferData(std::uint32_t target, std::uint32_t internalformat, std::uint32_t format, std::uint32_t type, void const* data);
    void clearBufferSubData(std::uint32_t target, std::uint32_t internalformat, std::intptr_t offset, std::int64_t size, std::uint32_t format, std::uint32_t type, void const* data);
    void clearBufferfi(std::uint32_t buffer, std::int32_t drawbuffer, float depth, std::int32_t stencil);
    void clearBufferfv(std::uint32_t buffer, std::int32_t drawbuffer, float const* value);
    void clearBufferiv(std::uint32_t buffer, std::int32_t drawbuffer, std::int32_t const* value);
    void clearBufferuiv(std::uint32_t buffer, std::int32_t drawbuffer, std::uint32_t const* value);
    void clearColor(float red, float green, float blue, float alpha);
    void clearColorx(std::int32_t red, std::int32_t green, std::int32_t blue, std::int32_t alpha);
    void clearDepth(double depth);
    void clearDepthf(float d);
    void clearDepthx(std::int32_t depth);
    void clearIndex(float c);
    void clearNamedBufferData(std::uint32_t buffer, std::uint32_t internalformat, std::uint32_t format, std::uint32_t type, void const* data);
    void clearNamedBufferSubData(std::uint32_t buffer, std::uint32_t internalformat, std::intptr_t offset, std::int64_t size, std::uint32_t format, std::uint32_t type, void const* data);
    void clearNamedFramebufferfi(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, float depth, std::int32_t stencil);
    void clearNamedFramebufferfv(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, float const* value);
    void clearNamedFramebufferiv(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, std::int32_t const* value);
    void clearNamedFramebufferuiv(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, std::uint32_t const* value);
    void clearStencil(std::int32_t s);
    void clearTexImage(std::uint32_t texture, std::int32_t level, std::uint32_t format, std::uint32_t type, void const* data);
    void clearTexSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, void const* data);
    void clientActiveTexture(std::uint32_t texture);
    std::uint32_t clientWaitSync(void* sync, std::uint32_t flags, std::uint64_t timeout);
    void clipControl(std::uint32_t origin, std::uint32_t depth);
    void clipPlane(std::uint32_t plane, double const* equation);
    void clipPlanef(std::uint32_t p, float const* eqn);
    void clipPlanex(std::uint32_t plane, std::int32_t const* equation);
    void color3b(std::int32_t red, std::int32_t green, std::int32_t blue);
    void color3bv(std::int32_t const* v);
    void color3d(double red, double green, double blue);
    void color3dv(double const* v);
    void color3f(float red, float green, float blue);
    void color3fv(float const* v);
    void color3i(std::int32_t red, std::int32_t green, std::int32_t blue);
    void color3iv(std::int32_t const* v);
    void color3s(std::int16_t red, std::int16_t green, std::int16_t blue);
    void color3sv(std::int16_t const* v);
    void color3ub(std::uint8_t red, std::uint8_t green, std::uint8_t blue);
    void color3ubv(std::uint8_t const* v);
    void color3ui(std::uint32_t red, std::uint32_t green, std::uint32_t blue);
    void color3uiv(std::uint32_t const* v);
    void color3us(std::uint16_t red, std::uint16_t green, std::uint16_t blue);
    void color3usv(std::uint16_t const* v);
    void color4b(std::int32_t red, std::int32_t green, std::int32_t blue, std::int32_t alpha);
    void color4bv(std::int32_t const* v);
    void color4d(double red, double green, double blue, double alpha);
    void color4dv(double const* v);
    void color4f(float red, float green, float blue, float alpha);
    void color4fv(float const* v);
    void color4i(std::int32_t red, std::int32_t green, std::int32_t blue, std::int32_t alpha);
    void color4iv(std::int32_t const* v);
    void color4s(std::int16_t red, std::int16_t green, std::int16_t blue, std::int16_t alpha);
    void color4sv(std::int16_t const* v);
    void color4ub(std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha);
    void color4ubv(std::uint8_t const* v);
    void color4ui(std::uint32_t red, std::uint32_t green, std::uint32_t blue, std::uint32_t alpha);
    void color4uiv(std::uint32_t const* v);
    void color4us(std::uint16_t red, std::uint16_t green, std::uint16_t blue, std::uint16_t alpha);
    void color4usv(std::uint16_t const* v);
    void color4x(std::int32_t red, std::int32_t green, std::int32_t blue, std::int32_t alpha);
    void colorMask(std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha);
    void colorMaski(std::uint32_t index, std::uint8_t r, std::uint8_t g, std::uint8_t b, std::uint8_t a);
    void colorMaterial(std::uint32_t face, std::uint32_t mode);
    void colorP3ui(std::uint32_t type, std::uint32_t color);
    void colorP3uiv(std::uint32_t type, std::uint32_t const* color);
    void colorP4ui(std::uint32_t type, std::uint32_t color);
    void colorP4uiv(std::uint32_t type, std::uint32_t const* color);
    void colorPointer(std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void compileShader(std::uint32_t shader);
    void compressedTexImage1D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t width, std::int32_t border, std::int32_t imageSize, void const* data);
    void compressedTexImage2D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t border, std::int32_t imageSize, void const* data);
    void compressedTexImage3D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::int32_t border, std::int32_t imageSize, void const* data);
    void compressedTexSubImage1D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTexSubImage2D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTexSubImage3D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTextureSubImage1D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTextureSubImage2D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTextureSubImage3D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::int32_t imageSize, void const* data);
    void copyBufferSubData(std::uint32_t readTarget, std::uint32_t writeTarget, std::intptr_t readOffset, std::intptr_t writeOffset, std::int64_t size);
    void copyImageSubData(std::uint32_t srcName, std::uint32_t srcTarget, std::int32_t srcLevel, std::int32_t srcX, std::int32_t srcY, std::int32_t srcZ, std::uint32_t dstName, std::uint32_t dstTarget, std::int32_t dstLevel, std::int32_t dstX, std::int32_t dstY, std::int32_t dstZ, std::int32_t srcWidth, std::int32_t srcHeight, std::int32_t srcDepth);
    void copyNamedBufferSubData(std::uint32_t readBuffer, std::uint32_t writeBuffer, std::intptr_t readOffset, std::intptr_t writeOffset, std::int64_t size);
    void copyPixels(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::uint32_t type);
    void copyTexImage1D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t border);
    void copyTexImage2D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::int32_t border);
    void copyTexSubImage1D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t x, std::int32_t y, std::int32_t width);
    void copyTexSubImage2D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void copyTexSubImage3D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void copyTextureSubImage1D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t x, std::int32_t y, std::int32_t width);
    void copyTextureSubImage2D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void copyTextureSubImage3D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void createBuffers(std::int32_t n, std::uint32_t* buffers);
    void createFramebuffers(std::int32_t n, std::uint32_t* framebuffers);
    std::uint32_t createProgram();
    void createProgramPipelines(std::int32_t n, std::uint32_t* pipelines);
    void createQueries(std::uint32_t target, std::int32_t n, std::uint32_t* ids);
    void createRenderbuffers(std::int32_t n, std::uint32_t* renderbuffers);
    void createSamplers(std::int32_t n, std::uint32_t* samplers);
    std::uint32_t createShader(std::uint32_t type);
    std::uint32_t createShaderProgramv(std::uint32_t type, std::int32_t count, char const* const*strings);
    void createTextures(std::uint32_t target, std::int32_t n, std::uint32_t* textures);
    void createTransformFeedbacks(std::int32_t n, std::uint32_t* ids);
    void createVertexArrays(std::int32_t n, std::uint32_t* arrays);
    void cullFace(std::uint32_t mode);
    void debugMessageCallback(void* callback, void const* userParam);
    void debugMessageControl(std::uint32_t source, std::uint32_t type, std::uint32_t severity, std::int32_t count, std::uint32_t const* ids, std::uint8_t enabled);
    void debugMessageInsert(std::uint32_t source, std::uint32_t type, std::uint32_t id, std::uint32_t severity, std::int32_t length, char const* buf);
    void deleteBuffers(std::int32_t n, std::uint32_t const* buffers);
    void deleteFramebuffers(std::int32_t n, std::uint32_t const* framebuffers);
    void deleteLists(std::uint32_t list, std::int32_t range);
    void deleteProgram(std::uint32_t program);
    void deleteProgramPipelines(std::int32_t n, std::uint32_t const* pipelines);
    void deleteQueries(std::int32_t n, std::uint32_t const* ids);
    void deleteRenderbuffers(std::int32_t n, std::uint32_t const* renderbuffers);
    void deleteSamplers(std::int32_t count, std::uint32_t const* samplers);
    void deleteShader(std::uint32_t shader);
    void deleteSync(void* sync);
    void deleteTextures(std::int32_t n, std::uint32_t const* textures);
    void deleteTransformFeedbacks(std::int32_t n, std::uint32_t const* ids);
    void deleteVertexArrays(std::int32_t n, std::uint32_t const* arrays);
    void depthFunc(std::uint32_t func);
    void depthMask(std::uint8_t flag);
    void depthRange(double n, double f);
    void depthRangeArrayv(std::uint32_t first, std::int32_t count, double const* v);
    void depthRangeIndexed(std::uint32_t index, double n, double f);
    void depthRangef(float n, float f);
    void depthRangex(std::int32_t n, std::int32_t f);
    void detachShader(std::uint32_t program, std::uint32_t shader);
    void disable(std::uint32_t cap);
    void disableClientState(std::uint32_t array);
    void disableVertexArrayAttrib(std::uint32_t vaobj, std::uint32_t index);
    void disableVertexAttribArray(std::uint32_t index);
    void disablei(std::uint32_t target, std::uint32_t index);
    void dispatchCompute(std::uint32_t num_groups_x, std::uint32_t num_groups_y, std::uint32_t num_groups_z);
    void dispatchComputeIndirect(std::intptr_t indirect);
    void drawArrays(std::uint32_t mode, std::int32_t first, std::int32_t count);
    void drawArraysIndirect(std::uint32_t mode, void const* indirect);
    void drawArraysInstanced(std::uint32_t mode, std::int32_t first, std::int32_t count, std::int32_t instancecount);
    void drawArraysInstancedBaseInstance(std::uint32_t mode, std::int32_t first, std::int32_t count, std::int32_t instancecount, std::uint32_t baseinstance);
    void drawBuffer(std::uint32_t buf);
    void drawBuffers(std::int32_t n, std::uint32_t const* bufs);
    void drawElements(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices);
    void drawElementsBaseVertex(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t basevertex);
    void drawElementsIndirect(std::uint32_t mode, std::uint32_t type, void const* indirect);
    void drawElementsInstanced(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount);
    void drawElementsInstancedBaseInstance(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount, std::uint32_t baseinstance);
    void drawElementsInstancedBaseVertex(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount, std::int32_t basevertex);
    void drawElementsInstancedBaseVertexBaseInstance(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount, std::int32_t basevertex, std::uint32_t baseinstance);
    void drawPixels(std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void const* pixels);
    void drawRangeElements(std::uint32_t mode, std::uint32_t start, std::uint32_t end, std::int32_t count, std::uint32_t type, void const* indices);
    void drawRangeElementsBaseVertex(std::uint32_t mode, std::uint32_t start, std::uint32_t end, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t basevertex);
    void drawTransformFeedback(std::uint32_t mode, std::uint32_t id);
    void drawTransformFeedbackInstanced(std::uint32_t mode, std::uint32_t id, std::int32_t instancecount);
    void drawTransformFeedbackStream(std::uint32_t mode, std::uint32_t id, std::uint32_t stream);
    void drawTransformFeedbackStreamInstanced(std::uint32_t mode, std::uint32_t id, std::uint32_t stream, std::int32_t instancecount);
    void edgeFlag(std::uint8_t flag);
    void edgeFlagPointer(std::int32_t stride, void const* pointer);
    void edgeFlagv(std::uint8_t const* flag);
    void enable(std::uint32_t cap);
    void enableClientState(std::uint32_t array);
    void enableVertexArrayAttrib(std::uint32_t vaobj, std::uint32_t index);
    void enableVertexAttribArray(std::uint32_t index);
    void enablei(std::uint32_t target, std::uint32_t index);
    void end();
    void endConditionalRender();
    void endList();
    void endQuery(std::uint32_t target);
    void endQueryIndexed(std::uint32_t target, std::uint32_t index);
    void endTransformFeedback();
    void evalCoord1d(double u);
    void evalCoord1dv(double const* u);
    void evalCoord1f(float u);
    void evalCoord1fv(float const* u);
    void evalCoord2d(double u, double v);
    void evalCoord2dv(double const* u);
    void evalCoord2f(float u, float v);
    void evalCoord2fv(float const* u);
    void evalMesh1(std::uint32_t mode, std::int32_t i1, std::int32_t i2);
    void evalMesh2(std::uint32_t mode, std::int32_t i1, std::int32_t i2, std::int32_t j1, std::int32_t j2);
    void evalPoint1(std::int32_t i);
    void evalPoint2(std::int32_t i, std::int32_t j);
    void feedbackBuffer(std::int32_t size, std::uint32_t type, float* buffer);
    void* fenceSync(std::uint32_t condition, std::uint32_t flags);
    void finish();
    void flush();
    void flushMappedBufferRange(std::uint32_t target, std::intptr_t offset, std::int64_t length);
    void flushMappedNamedBufferRange(std::uint32_t buffer, std::intptr_t offset, std::int64_t length);
    void fogCoordPointer(std::uint32_t type, std::int32_t stride, void const* pointer);
    void fogCoordd(double coord);
    void fogCoorddv(double const* coord);
    void fogCoordf(float coord);
    void fogCoordfv(float const* coord);
    void fogf(std::uint32_t pname, float param);
    void fogfv(std::uint32_t pname, float const* params);
    void fogi(std::uint32_t pname, std::int32_t param);
    void fogiv(std::uint32_t pname, std::int32_t const* params);
    void fogx(std::uint32_t pname, std::int32_t param);
    void fogxv(std::uint32_t pname, std::int32_t const* param);
    void framebufferParameteri(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void framebufferRenderbuffer(std::uint32_t target, std::uint32_t attachment, std::uint32_t renderbuffertarget, std::uint32_t renderbuffer);
    void framebufferTexture(std::uint32_t target, std::uint32_t attachment, std::uint32_t texture, std::int32_t level);
    void framebufferTexture1D(std::uint32_t target, std::uint32_t attachment, std::uint32_t textarget, std::uint32_t texture, std::int32_t level);
    void framebufferTexture2D(std::uint32_t target, std::uint32_t attachment, std::uint32_t textarget, std::uint32_t texture, std::int32_t level);
    void framebufferTexture3D(std::uint32_t target, std::uint32_t attachment, std::uint32_t textarget, std::uint32_t texture, std::int32_t level, std::int32_t zoffset);
    void framebufferTextureLayer(std::uint32_t target, std::uint32_t attachment, std::uint32_t texture, std::int32_t level, std::int32_t layer);
    void frontFace(std::uint32_t mode);
    void frustum(double left, double right, double bottom, double top, double zNear, double zFar);
    void frustumf(float l, float r, float b, float t, float n, float f);
    void frustumx(std::int32_t l, std::int32_t r, std::int32_t b, std::int32_t t, std::int32_t n, std::int32_t f);
    void genBuffers(std::int32_t n, std::uint32_t* buffers);
    void genFramebuffers(std::int32_t n, std::uint32_t* framebuffers);
    std::uint32_t genLists(std::int32_t range);
    void genProgramPipelines(std::int32_t n, std::uint32_t* pipelines);
    void genQueries(std::int32_t n, std::uint32_t* ids);
    void genRenderbuffers(std::int32_t n, std::uint32_t* renderbuffers);
    void genSamplers(std::int32_t count, std::uint32_t* samplers);
    void genTextures(std::int32_t n, std::uint32_t* textures);
    void genTransformFeedbacks(std::int32_t n, std::uint32_t* ids);
    void genVertexArrays(std::int32_t n, std::uint32_t* arrays);
    void generateMipmap(std::uint32_t target);
    void generateTextureMipmap(std::uint32_t texture);
    void getActiveAtomicCounterBufferiv(std::uint32_t program, std::uint32_t bufferIndex, std::uint32_t pname, std::int32_t* params);
    void getActiveAttrib(std::uint32_t program, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, std::int32_t* size, std::uint32_t* type, char* name);
    void getActiveSubroutineName(std::uint32_t program, std::uint32_t shadertype, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, char* name);
    void getActiveSubroutineUniformName(std::uint32_t program, std::uint32_t shadertype, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, char* name);
    void getActiveSubroutineUniformiv(std::uint32_t program, std::uint32_t shadertype, std::uint32_t index, std::uint32_t pname, std::int32_t* values);
    void getActiveUniform(std::uint32_t program, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, std::int32_t* size, std::uint32_t* type, char* name);
    void getActiveUniformBlockName(std::uint32_t program, std::uint32_t uniformBlockIndex, std::int32_t bufSize, std::int32_t* length, char* uniformBlockName);
    void getActiveUniformBlockiv(std::uint32_t program, std::uint32_t uniformBlockIndex, std::uint32_t pname, std::int32_t* params);
    void getActiveUniformName(std::uint32_t program, std::uint32_t uniformIndex, std::int32_t bufSize, std::int32_t* length, char* uniformName);
    void getActiveUniformsiv(std::uint32_t program, std::int32_t uniformCount, std::uint32_t const* uniformIndices, std::uint32_t pname, std::int32_t* params);
    void getAttachedShaders(std::uint32_t program, std::int32_t maxCount, std::int32_t* count, std::uint32_t* shaders);
    std::int32_t getAttribLocation(std::uint32_t program, char const* name);
    void getBooleani_v(std::uint32_t target, std::uint32_t index, std::uint8_t* data);
    void getBooleanv(std::uint32_t pname, std::uint8_t* data);
    void getBufferParameteri64v(std::uint32_t target, std::uint32_t pname, std::int64_t* params);
    void getBufferParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getBufferPointerv(std::uint32_t target, std::uint32_t pname, void* *params);
    void getBufferSubData(std::uint32_t target, std::intptr_t offset, std::int64_t size, void* data);
    void getClipPlane(std::uint32_t plane, double* equation);
    void getClipPlanef(std::uint32_t plane, float* equation);
    void getClipPlanex(std::uint32_t plane, std::int32_t* equation);
    void getCompressedTexImage(std::uint32_t target, std::int32_t level, void* img);
    void getCompressedTextureImage(std::uint32_t texture, std::int32_t level, std::int32_t bufSize, void* pixels);
    void getCompressedTextureSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::int32_t bufSize, void* pixels);
    std::uint32_t getDebugMessageLog(std::uint32_t count, std::int32_t bufSize, std::uint32_t* sources, std::uint32_t* types, std::uint32_t* ids, std::uint32_t* severities, std::int32_t* lengths, char* messageLog);
    void getDoublei_v(std::uint32_t target, std::uint32_t index, double* data);
    void getDoublev(std::uint32_t pname, double* data);
    std::uint32_t getError();
    void getFixedv(std::uint32_t pname, std::int32_t* params);
    void getFloati_v(std::uint32_t target, std::uint32_t index, float* data);
    void getFloatv(std::uint32_t pname, float* data);
    std::int32_t getFragDataIndex(std::uint32_t program, char const* name);
    std::int32_t getFragDataLocation(std::uint32_t program, char const* name);
    void getFramebufferAttachmentParameteriv(std::uint32_t target, std::uint32_t attachment, std::uint32_t pname, std::int32_t* params);
    void getFramebufferParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    std::uint32_t getGraphicsResetStatus();
    void getInteger64i_v(std::uint32_t target, std::uint32_t index, std::int64_t* data);
    void getInteger64v(std::uint32_t pname, std::int64_t* data);
    void getIntegeri_v(std::uint32_t target, std::uint32_t index, std::int32_t* data);
    void getIntegerv(std::uint32_t pname, std::int32_t* data);
    void getInternalformati64v(std::uint32_t target, std::uint32_t internalformat, std::uint32_t pname, std::int32_t count, std::int64_t* params);
    void getInternalformativ(std::uint32_t target, std::uint32_t internalformat, std::uint32_t pname, std::int32_t count, std::int32_t* params);
    void getLightfv(std::uint32_t light, std::uint32_t pname, float* params);
    void getLightiv(std::uint32_t light, std::uint32_t pname, std::int32_t* params);
    void getLightxv(std::uint32_t light, std::uint32_t pname, std::int32_t* params);
    void getMapdv(std::uint32_t target, std::uint32_t query, double* v);
    void getMapfv(std::uint32_t target, std::uint32_t query, float* v);
    void getMapiv(std::uint32_t target, std::uint32_t query, std::int32_t* v);
    void getMaterialfv(std::uint32_t face, std::uint32_t pname, float* params);
    void getMaterialiv(std::uint32_t face, std::uint32_t pname, std::int32_t* params);
    void getMaterialxv(std::uint32_t face, std::uint32_t pname, std::int32_t* params);
    void getMultisamplefv(std::uint32_t pname, std::uint32_t index, float* val);
    void getNamedBufferParameteri64v(std::uint32_t buffer, std::uint32_t pname, std::int64_t* params);
    void getNamedBufferParameteriv(std::uint32_t buffer, std::uint32_t pname, std::int32_t* params);
    void getNamedBufferPointerv(std::uint32_t buffer, std::uint32_t pname, void* *params);
    void getNamedBufferSubData(std::uint32_t buffer, std::intptr_t offset, std::int64_t size, void* data);
    void getNamedFramebufferAttachmentParameteriv(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t pname, std::int32_t* params);
    void getNamedFramebufferParameteriv(std::uint32_t framebuffer, std::uint32_t pname, std::int32_t* param);
    void getNamedRenderbufferParameteriv(std::uint32_t renderbuffer, std::uint32_t pname, std::int32_t* params);
    void getObjectLabel(std::uint32_t identifier, std::uint32_t name, std::int32_t bufSize, std::int32_t* length, char* label);
    void getObjectPtrLabel(void const* ptr, std::int32_t bufSize, std::int32_t* length, char* label);
    void getPixelMapfv(std::uint32_t map, float* values);
    void getPixelMapuiv(std::uint32_t map, std::uint32_t* values);
    void getPixelMapusv(std::uint32_t map, std::uint16_t* values);
    void getPointerv(std::uint32_t pname, void* *params);
    void getPolygonStipple(std::uint8_t* mask);
    void getProgramBinary(std::uint32_t program, std::int32_t bufSize, std::int32_t* length, std::uint32_t* binaryFormat, void* binary);
    void getProgramInfoLog(std::uint32_t program, std::int32_t bufSize, std::int32_t* length, char* infoLog);
    void getProgramInterfaceiv(std::uint32_t program, std::uint32_t programInterface, std::uint32_t pname, std::int32_t* params);
    void getProgramPipelineInfoLog(std::uint32_t pipeline, std::int32_t bufSize, std::int32_t* length, char* infoLog);
    void getProgramPipelineiv(std::uint32_t pipeline, std::uint32_t pname, std::int32_t* params);
    std::uint32_t getProgramResourceIndex(std::uint32_t program, std::uint32_t programInterface, char const* name);
    std::int32_t getProgramResourceLocation(std::uint32_t program, std::uint32_t programInterface, char const* name);
    std::int32_t getProgramResourceLocationIndex(std::uint32_t program, std::uint32_t programInterface, char const* name);
    void getProgramResourceName(std::uint32_t program, std::uint32_t programInterface, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, char* name);
    void getProgramResourceiv(std::uint32_t program, std::uint32_t programInterface, std::uint32_t index, std::int32_t propCount, std::uint32_t const* props, std::int32_t count, std::int32_t* length, std::int32_t* params);
    void getProgramStageiv(std::uint32_t program, std::uint32_t shadertype, std::uint32_t pname, std::int32_t* values);
    void getProgramiv(std::uint32_t program, std::uint32_t pname, std::int32_t* params);
    void getQueryBufferObjecti64v(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryBufferObjectiv(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryBufferObjectui64v(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryBufferObjectuiv(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryIndexediv(std::uint32_t target, std::uint32_t index, std::uint32_t pname, std::int32_t* params);
    void getQueryObjecti64v(std::uint32_t id, std::uint32_t pname, std::int64_t* params);
    void getQueryObjectiv(std::uint32_t id, std::uint32_t pname, std::int32_t* params);
    void getQueryObjectui64v(std::uint32_t id, std::uint32_t pname, std::uint64_t* params);
    void getQueryObjectuiv(std::uint32_t id, std::uint32_t pname, std::uint32_t* params);
    void getQueryiv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getRenderbufferParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getSamplerParameterIiv(std::uint32_t sampler, std::uint32_t pname, std::int32_t* params);
    void getSamplerParameterIuiv(std::uint32_t sampler, std::uint32_t pname, std::uint32_t* params);
    void getSamplerParameterfv(std::uint32_t sampler, std::uint32_t pname, float* params);
    void getSamplerParameteriv(std::uint32_t sampler, std::uint32_t pname, std::int32_t* params);
    void getShaderInfoLog(std::uint32_t shader, std::int32_t bufSize, std::int32_t* length, char* infoLog);
    void getShaderPrecisionFormat(std::uint32_t shadertype, std::uint32_t precisiontype, std::int32_t* range, std::int32_t* precision);
    void getShaderSource(std::uint32_t shader, std::int32_t bufSize, std::int32_t* length, char* source);
    void getShaderiv(std::uint32_t shader, std::uint32_t pname, std::int32_t* params);
    std::uint8_t const* getString(std::uint32_t name);
    std::uint8_t const* getStringi(std::uint32_t name, std::uint32_t index);
    std::uint32_t getSubroutineIndex(std::uint32_t program, std::uint32_t shadertype, char const* name);
    std::int32_t getSubroutineUniformLocation(std::uint32_t program, std::uint32_t shadertype, char const* name);
    void getSynciv(void* sync, std::uint32_t pname, std::int32_t count, std::int32_t* length, std::int32_t* values);
    void getTexEnvfv(std::uint32_t target, std::uint32_t pname, float* params);
    void getTexEnviv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTexEnvxv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTexGendv(std::uint32_t coord, std::uint32_t pname, double* params);
    void getTexGenfv(std::uint32_t coord, std::uint32_t pname, float* params);
    void getTexGeniv(std::uint32_t coord, std::uint32_t pname, std::int32_t* params);
    void getTexImage(std::uint32_t target, std::int32_t level, std::uint32_t format, std::uint32_t type, void* pixels);
    void getTexLevelParameterfv(std::uint32_t target, std::int32_t level, std::uint32_t pname, float* params);
    void getTexLevelParameteriv(std::uint32_t target, std::int32_t level, std::uint32_t pname, std::int32_t* params);
    void getTexParameterIiv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTexParameterIuiv(std::uint32_t target, std::uint32_t pname, std::uint32_t* params);
    void getTexParameterfv(std::uint32_t target, std::uint32_t pname, float* params);
    void getTexParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTexParameterxv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTextureImage(std::uint32_t texture, std::int32_t level, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* pixels);
    void getTextureLevelParameterfv(std::uint32_t texture, std::int32_t level, std::uint32_t pname, float* params);
    void getTextureLevelParameteriv(std::uint32_t texture, std::int32_t level, std::uint32_t pname, std::int32_t* params);
    void getTextureParameterIiv(std::uint32_t texture, std::uint32_t pname, std::int32_t* params);
    void getTextureParameterIuiv(std::uint32_t texture, std::uint32_t pname, std::uint32_t* params);
    void getTextureParameterfv(std::uint32_t texture, std::uint32_t pname, float* params);
    void getTextureParameteriv(std::uint32_t texture, std::uint32_t pname, std::int32_t* params);
    void getTextureSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* pixels);
    void getTransformFeedbackVarying(std::uint32_t program, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, std::int32_t* size, std::uint32_t* type, char* name);
    void getTransformFeedbacki64_v(std::uint32_t xfb, std::uint32_t pname, std::uint32_t index, std::int64_t* param);
    void getTransformFeedbacki_v(std::uint32_t xfb, std::uint32_t pname, std::uint32_t index, std::int32_t* param);
    void getTransformFeedbackiv(std::uint32_t xfb, std::uint32_t pname, std::int32_t* param);
    std::uint32_t getUniformBlockIndex(std::uint32_t program, char const* uniformBlockName);
    void getUniformIndices(std::uint32_t program, std::int32_t uniformCount, char const* const*uniformNames, std::uint32_t* uniformIndices);
    std::int32_t getUniformLocation(std::uint32_t program, char const* name);
    void getUniformSubroutineuiv(std::uint32_t shadertype, std::int32_t location, std::uint32_t* params);
    void getUniformdv(std::uint32_t program, std::int32_t location, double* params);
    void getUniformfv(std::uint32_t program, std::int32_t location, float* params);
    void getUniformiv(std::uint32_t program, std::int32_t location, std::int32_t* params);
    void getUniformuiv(std::uint32_t program, std::int32_t location, std::uint32_t* params);
    void getVertexArrayIndexed64iv(std::uint32_t vaobj, std::uint32_t index, std::uint32_t pname, std::int64_t* param);
    void getVertexArrayIndexediv(std::uint32_t vaobj, std::uint32_t index, std::uint32_t pname, std::int32_t* param);
    void getVertexArrayiv(std::uint32_t vaobj, std::uint32_t pname, std::int32_t* param);
    void getVertexAttribIiv(std::uint32_t index, std::uint32_t pname, std::int32_t* params);
    void getVertexAttribIuiv(std::uint32_t index, std::uint32_t pname, std::uint32_t* params);
    void getVertexAttribLdv(std::uint32_t index, std::uint32_t pname, double* params);
    void getVertexAttribPointerv(std::uint32_t index, std::uint32_t pname, void* *pointer);
    void getVertexAttribdv(std::uint32_t index, std::uint32_t pname, double* params);
    void getVertexAttribfv(std::uint32_t index, std::uint32_t pname, float* params);
    void getVertexAttribiv(std::uint32_t index, std::uint32_t pname, std::int32_t* params);
    void getnColorTable(std::uint32_t target, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* table);
    void getnCompressedTexImage(std::uint32_t target, std::int32_t lod, std::int32_t bufSize, void* pixels);
    void getnConvolutionFilter(std::uint32_t target, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* image);
    void getnHistogram(std::uint32_t target, std::uint8_t reset, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* values);
    void getnMapdv(std::uint32_t target, std::uint32_t query, std::int32_t bufSize, double* v);
    void getnMapfv(std::uint32_t target, std::uint32_t query, std::int32_t bufSize, float* v);
    void getnMapiv(std::uint32_t target, std::uint32_t query, std::int32_t bufSize, std::int32_t* v);
    void getnMinmax(std::uint32_t target, std::uint8_t reset, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* values);
    void getnPixelMapfv(std::uint32_t map, std::int32_t bufSize, float* values);
    void getnPixelMapuiv(std::uint32_t map, std::int32_t bufSize, std::uint32_t* values);
    void getnPixelMapusv(std::uint32_t map, std::int32_t bufSize, std::uint16_t* values);
    void getnPolygonStipple(std::int32_t bufSize, std::uint8_t* pattern);
    void getnSeparableFilter(std::uint32_t target, std::uint32_t format, std::uint32_t type, std::int32_t rowBufSize, void* row, std::int32_t columnBufSize, void* column, void* span);
    void getnTexImage(std::uint32_t target, std::int32_t level, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* pixels);
    void getnUniformdv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, double* params);
    void getnUniformfv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, float* params);
    void getnUniformiv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, std::int32_t* params);
    void getnUniformuiv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, std::uint32_t* params);
    void hint(std::uint32_t target, std::uint32_t mode);
    void indexMask(std::uint32_t mask);
    void indexPointer(std::uint32_t type, std::int32_t stride, void const* pointer);
    void indexd(double c);
    void indexdv(double const* c);
    void indexf(float c);
    void indexfv(float const* c);
    void indexi(std::int32_t c);
    void indexiv(std::int32_t const* c);
    void indexs(std::int16_t c);
    void indexsv(std::int16_t const* c);
    void indexub(std::uint8_t c);
    void indexubv(std::uint8_t const* c);
    void initNames();
    void interleavedArrays(std::uint32_t format, std::int32_t stride, void const* pointer);
    void invalidateBufferData(std::uint32_t buffer);
    void invalidateBufferSubData(std::uint32_t buffer, std::intptr_t offset, std::int64_t length);
    void invalidateFramebuffer(std::uint32_t target, std::int32_t numAttachments, std::uint32_t const* attachments);
    void invalidateNamedFramebufferData(std::uint32_t framebuffer, std::int32_t numAttachments, std::uint32_t const* attachments);
    void invalidateNamedFramebufferSubData(std::uint32_t framebuffer, std::int32_t numAttachments, std::uint32_t const* attachments, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void invalidateSubFramebuffer(std::uint32_t target, std::int32_t numAttachments, std::uint32_t const* attachments, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void invalidateTexImage(std::uint32_t texture, std::int32_t level);
    void invalidateTexSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth);
    std::uint8_t isBuffer(std::uint32_t buffer);
    std::uint8_t isEnabled(std::uint32_t cap);
    std::uint8_t isEnabledi(std::uint32_t target, std::uint32_t index);
    std::uint8_t isFramebuffer(std::uint32_t framebuffer);
    std::uint8_t isList(std::uint32_t list);
    std::uint8_t isProgram(std::uint32_t program);
    std::uint8_t isProgramPipeline(std::uint32_t pipeline);
    std::uint8_t isQuery(std::uint32_t id);
    std::uint8_t isRenderbuffer(std::uint32_t renderbuffer);
    std::uint8_t isSampler(std::uint32_t sampler);
    std::uint8_t isShader(std::uint32_t shader);
    std::uint8_t isSync(void* sync);
    std::uint8_t isTexture(std::uint32_t texture);
    std::uint8_t isTransformFeedback(std::uint32_t id);
    std::uint8_t isVertexArray(std::uint32_t array);
    void lightModelf(std::uint32_t pname, float param);
    void lightModelfv(std::uint32_t pname, float const* params);
    void lightModeli(std::uint32_t pname, std::int32_t param);
    void lightModeliv(std::uint32_t pname, std::int32_t const* params);
    void lightModelx(std::uint32_t pname, std::int32_t param);
    void lightModelxv(std::uint32_t pname, std::int32_t const* param);
    void lightf(std::uint32_t light, std::uint32_t pname, float param);
    void lightfv(std::uint32_t light, std::uint32_t pname, float const* params);
    void lighti(std::uint32_t light, std::uint32_t pname, std::int32_t param);
    void lightiv(std::uint32_t light, std::uint32_t pname, std::int32_t const* params);
    void lightx(std::uint32_t light, std::uint32_t pname, std::int32_t param);
    void lightxv(std::uint32_t light, std::uint32_t pname, std::int32_t const* params);
    void lineStipple(std::int32_t factor, std::uint16_t pattern);
    void lineWidth(float width);
    void lineWidthx(std::int32_t width);
    void linkProgram(std::uint32_t program);
    void listBase(std::uint32_t base);
    void loadIdentity();
    void loadMatrixd(double const* m);
    void loadMatrixf(float const* m);
    void loadMatrixx(std::int32_t const* m);
    void loadName(std::uint32_t name);
    void loadTransposeMatrixd(double const* m);
    void loadTransposeMatrixf(float const* m);
    void logicOp(std::uint32_t opcode);
    void map1d(std::uint32_t target, double u1, double u2, std::int32_t stride, std::int32_t order, double const* points);
    void map1f(std::uint32_t target, float u1, float u2, std::int32_t stride, std::int32_t order, float const* points);
    void map2d(std::uint32_t target, double u1, double u2, std::int32_t ustride, std::int32_t uorder, double v1, double v2, std::int32_t vstride, std::int32_t vorder, double const* points);
    void map2f(std::uint32_t target, float u1, float u2, std::int32_t ustride, std::int32_t uorder, float v1, float v2, std::int32_t vstride, std::int32_t vorder, float const* points);
    void* mapBuffer(std::uint32_t target, std::uint32_t access);
    void* mapBufferRange(std::uint32_t target, std::intptr_t offset, std::int64_t length, std::uint32_t access);
    void mapGrid1d(std::int32_t un, double u1, double u2);
    void mapGrid1f(std::int32_t un, float u1, float u2);
    void mapGrid2d(std::int32_t un, double u1, double u2, std::int32_t vn, double v1, double v2);
    void mapGrid2f(std::int32_t un, float u1, float u2, std::int32_t vn, float v1, float v2);
    void* mapNamedBuffer(std::uint32_t buffer, std::uint32_t access);
    void* mapNamedBufferRange(std::uint32_t buffer, std::intptr_t offset, std::int64_t length, std::uint32_t access);
    void materialf(std::uint32_t face, std::uint32_t pname, float param);
    void materialfv(std::uint32_t face, std::uint32_t pname, float const* params);
    void materiali(std::uint32_t face, std::uint32_t pname, std::int32_t param);
    void materialiv(std::uint32_t face, std::uint32_t pname, std::int32_t const* params);
    void materialx(std::uint32_t face, std::uint32_t pname, std::int32_t param);
    void materialxv(std::uint32_t face, std::uint32_t pname, std::int32_t const* param);
    void matrixMode(std::uint32_t mode);
    void memoryBarrier(std::uint32_t barriers);
    void memoryBarrierByRegion(std::uint32_t barriers);
    void minSampleShading(float value);
    void multMatrixd(double const* m);
    void multMatrixf(float const* m);
    void multMatrixx(std::int32_t const* m);
    void multTransposeMatrixd(double const* m);
    void multTransposeMatrixf(float const* m);
    void multiDrawArrays(std::uint32_t mode, std::int32_t const* first, std::int32_t const* count, std::int32_t drawcount);
    void multiDrawArraysIndirect(std::uint32_t mode, void const* indirect, std::int32_t drawcount, std::int32_t stride);
    void multiDrawArraysIndirectCount(std::uint32_t mode, void const* indirect, std::intptr_t drawcount, std::int32_t maxdrawcount, std::int32_t stride);
    void multiDrawElements(std::uint32_t mode, std::int32_t const* count, std::uint32_t type, void const* const*indices, std::int32_t drawcount);
    void multiDrawElementsBaseVertex(std::uint32_t mode, std::int32_t const* count, std::uint32_t type, void const* const*indices, std::int32_t drawcount, std::int32_t const* basevertex);
    void multiDrawElementsIndirect(std::uint32_t mode, std::uint32_t type, void const* indirect, std::int32_t drawcount, std::int32_t stride);
    void multiDrawElementsIndirectCount(std::uint32_t mode, std::uint32_t type, void const* indirect, std::intptr_t drawcount, std::int32_t maxdrawcount, std::int32_t stride);
    void multiTexCoord1d(std::uint32_t target, double s);
    void multiTexCoord1dv(std::uint32_t target, double const* v);
    void multiTexCoord1f(std::uint32_t target, float s);
    void multiTexCoord1fv(std::uint32_t target, float const* v);
    void multiTexCoord1i(std::uint32_t target, std::int32_t s);
    void multiTexCoord1iv(std::uint32_t target, std::int32_t const* v);
    void multiTexCoord1s(std::uint32_t target, std::int16_t s);
    void multiTexCoord1sv(std::uint32_t target, std::int16_t const* v);
    void multiTexCoord2d(std::uint32_t target, double s, double t);
    void multiTexCoord2dv(std::uint32_t target, double const* v);
    void multiTexCoord2f(std::uint32_t target, float s, float t);
    void multiTexCoord2fv(std::uint32_t target, float const* v);
    void multiTexCoord2i(std::uint32_t target, std::int32_t s, std::int32_t t);
    void multiTexCoord2iv(std::uint32_t target, std::int32_t const* v);
    void multiTexCoord2s(std::uint32_t target, std::int16_t s, std::int16_t t);
    void multiTexCoord2sv(std::uint32_t target, std::int16_t const* v);
    void multiTexCoord3d(std::uint32_t target, double s, double t, double r);
    void multiTexCoord3dv(std::uint32_t target, double const* v);
    void multiTexCoord3f(std::uint32_t target, float s, float t, float r);
    void multiTexCoord3fv(std::uint32_t target, float const* v);
    void multiTexCoord3i(std::uint32_t target, std::int32_t s, std::int32_t t, std::int32_t r);
    void multiTexCoord3iv(std::uint32_t target, std::int32_t const* v);
    void multiTexCoord3s(std::uint32_t target, std::int16_t s, std::int16_t t, std::int16_t r);
    void multiTexCoord3sv(std::uint32_t target, std::int16_t const* v);
    void multiTexCoord4d(std::uint32_t target, double s, double t, double r, double q);
    void multiTexCoord4dv(std::uint32_t target, double const* v);
    void multiTexCoord4f(std::uint32_t target, float s, float t, float r, float q);
    void multiTexCoord4fv(std::uint32_t target, float const* v);
    void multiTexCoord4i(std::uint32_t target, std::int32_t s, std::int32_t t, std::int32_t r, std::int32_t q);
    void multiTexCoord4iv(std::uint32_t target, std::int32_t const* v);
    void multiTexCoord4s(std::uint32_t target, std::int16_t s, std::int16_t t, std::int16_t r, std::int16_t q);
    void multiTexCoord4sv(std::uint32_t target, std::int16_t const* v);
    void multiTexCoord4x(std::uint32_t texture, std::int32_t s, std::int32_t t, std::int32_t r, std::int32_t q);
    void multiTexCoordP1ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP1uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP2ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP2uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP3ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP3uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP4ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP4uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void namedBufferData(std::uint32_t buffer, std::int64_t size, void const* data, std::uint32_t usage);
    void namedBufferStorage(std::uint32_t buffer, std::int64_t size, void const* data, std::uint32_t flags);
    void namedBufferSubData(std::uint32_t buffer, std::intptr_t offset, std::int64_t size, void const* data);
    void namedFramebufferDrawBuffer(std::uint32_t framebuffer, std::uint32_t buf);
    void namedFramebufferDrawBuffers(std::uint32_t framebuffer, std::int32_t n, std::uint32_t const* bufs);
    void namedFramebufferParameteri(std::uint32_t framebuffer, std::uint32_t pname, std::int32_t param);
    void namedFramebufferReadBuffer(std::uint32_t framebuffer, std::uint32_t src);
    void namedFramebufferRenderbuffer(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t renderbuffertarget, std::uint32_t renderbuffer);
    void namedFramebufferTexture(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t texture, std::int32_t level);
    void namedFramebufferTextureLayer(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t texture, std::int32_t level, std::int32_t layer);
    void namedRenderbufferStorage(std::uint32_t renderbuffer, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void namedRenderbufferStorageMultisample(std::uint32_t renderbuffer, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void newList(std::uint32_t list, std::uint32_t mode);
    void normal3b(std::int32_t nx, std::int32_t ny, std::int32_t nz);
    void normal3bv(std::int32_t const* v);
    void normal3d(double nx, double ny, double nz);
    void normal3dv(double const* v);
    void normal3f(float nx, float ny, float nz);
    void normal3fv(float const* v);
    void normal3i(std::int32_t nx, std::int32_t ny, std::int32_t nz);
    void normal3iv(std::int32_t const* v);
    void normal3s(std::int16_t nx, std::int16_t ny, std::int16_t nz);
    void normal3sv(std::int16_t const* v);
    void normal3x(std::int32_t nx, std::int32_t ny, std::int32_t nz);
    void normalP3ui(std::uint32_t type, std::uint32_t coords);
    void normalP3uiv(std::uint32_t type, std::uint32_t const* coords);
    void normalPointer(std::uint32_t type, std::int32_t stride, void const* pointer);
    void objectLabel(std::uint32_t identifier, std::uint32_t name, std::int32_t length, char const* label);
    void objectPtrLabel(void const* ptr, std::int32_t length, char const* label);
    void ortho(double left, double right, double bottom, double top, double zNear, double zFar);
    void orthof(float l, float r, float b, float t, float n, float f);
    void orthox(std::int32_t l, std::int32_t r, std::int32_t b, std::int32_t t, std::int32_t n, std::int32_t f);
    void passThrough(float token);
    void patchParameterfv(std::uint32_t pname, float const* values);
    void patchParameteri(std::uint32_t pname, std::int32_t value);
    void pauseTransformFeedback();
    void pixelMapfv(std::uint32_t map, std::int32_t mapsize, float const* values);
    void pixelMapuiv(std::uint32_t map, std::int32_t mapsize, std::uint32_t const* values);
    void pixelMapusv(std::uint32_t map, std::int32_t mapsize, std::uint16_t const* values);
    void pixelStoref(std::uint32_t pname, float param);
    void pixelStorei(std::uint32_t pname, std::int32_t param);
    void pixelTransferf(std::uint32_t pname, float param);
    void pixelTransferi(std::uint32_t pname, std::int32_t param);
    void pixelZoom(float xfactor, float yfactor);
    void pointParameterf(std::uint32_t pname, float param);
    void pointParameterfv(std::uint32_t pname, float const* params);
    void pointParameteri(std::uint32_t pname, std::int32_t param);
    void pointParameteriv(std::uint32_t pname, std::int32_t const* params);
    void pointParameterx(std::uint32_t pname, std::int32_t param);
    void pointParameterxv(std::uint32_t pname, std::int32_t const* params);
    void pointSize(float size);
    void pointSizex(std::int32_t size);
    void polygonMode(std::uint32_t face, std::uint32_t mode);
    void polygonOffset(float factor, float units);
    void polygonOffsetClamp(float factor, float units, float clamp);
    void polygonOffsetx(std::int32_t factor, std::int32_t units);
    void polygonStipple(std::uint8_t const* mask);
    void popAttrib();
    void popClientAttrib();
    void popDebugGroup();
    void popMatrix();
    void popName();
    void primitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW);
    void primitiveRestartIndex(std::uint32_t index);
    void prioritizeTextures(std::int32_t n, std::uint32_t const* textures, float const* priorities);
    void programBinary(std::uint32_t program, std::uint32_t binaryFormat, void const* binary, std::int32_t length);
    void programParameteri(std::uint32_t program, std::uint32_t pname, std::int32_t value);
    void programUniform1d(std::uint32_t program, std::int32_t location, double v0);
    void programUniform1dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform1f(std::uint32_t program, std::int32_t location, float v0);
    void programUniform1fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform1i(std::uint32_t program, std::int32_t location, std::int32_t v0);
    void programUniform1iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform1ui(std::uint32_t program, std::int32_t location, std::uint32_t v0);
    void programUniform1uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniform2d(std::uint32_t program, std::int32_t location, double v0, double v1);
    void programUniform2dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform2f(std::uint32_t program, std::int32_t location, float v0, float v1);
    void programUniform2fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform2i(std::uint32_t program, std::int32_t location, std::int32_t v0, std::int32_t v1);
    void programUniform2iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform2ui(std::uint32_t program, std::int32_t location, std::uint32_t v0, std::uint32_t v1);
    void programUniform2uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniform3d(std::uint32_t program, std::int32_t location, double v0, double v1, double v2);
    void programUniform3dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform3f(std::uint32_t program, std::int32_t location, float v0, float v1, float v2);
    void programUniform3fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform3i(std::uint32_t program, std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2);
    void programUniform3iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform3ui(std::uint32_t program, std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2);
    void programUniform3uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniform4d(std::uint32_t program, std::int32_t location, double v0, double v1, double v2, double v3);
    void programUniform4dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform4f(std::uint32_t program, std::int32_t location, float v0, float v1, float v2, float v3);
    void programUniform4fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform4i(std::uint32_t program, std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2, std::int32_t v3);
    void programUniform4iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform4ui(std::uint32_t program, std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2, std::uint32_t v3);
    void programUniform4uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniformMatrix2dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix2fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix2x3dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix2x3fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix2x4dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix2x4fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix3dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix3fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix3x2dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix3x2fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix3x4dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix3x4fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix4dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix4fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix4x2dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix4x2fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix4x3dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix4x3fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void provokingVertex(std::uint32_t mode);
    void pushAttrib(std::uint32_t mask);
    void pushClientAttrib(std::uint32_t mask);
    void pushDebugGroup(std::uint32_t source, std::uint32_t id, std::int32_t length, char const* message);
    void pushMatrix();
    void pushName(std::uint32_t name);
    void queryCounter(std::uint32_t id, std::uint32_t target);
    void rasterPos2d(double x, double y);
    void rasterPos2dv(double const* v);
    void rasterPos2f(float x, float y);
    void rasterPos2fv(float const* v);
    void rasterPos2i(std::int32_t x, std::int32_t y);
    void rasterPos2iv(std::int32_t const* v);
    void rasterPos2s(std::int16_t x, std::int16_t y);
    void rasterPos2sv(std::int16_t const* v);
    void rasterPos3d(double x, double y, double z);
    void rasterPos3dv(double const* v);
    void rasterPos3f(float x, float y, float z);
    void rasterPos3fv(float const* v);
    void rasterPos3i(std::int32_t x, std::int32_t y, std::int32_t z);
    void rasterPos3iv(std::int32_t const* v);
    void rasterPos3s(std::int16_t x, std::int16_t y, std::int16_t z);
    void rasterPos3sv(std::int16_t const* v);
    void rasterPos4d(double x, double y, double z, double w);
    void rasterPos4dv(double const* v);
    void rasterPos4f(float x, float y, float z, float w);
    void rasterPos4fv(float const* v);
    void rasterPos4i(std::int32_t x, std::int32_t y, std::int32_t z, std::int32_t w);
    void rasterPos4iv(std::int32_t const* v);
    void rasterPos4s(std::int16_t x, std::int16_t y, std::int16_t z, std::int16_t w);
    void rasterPos4sv(std::int16_t const* v);
    void readBuffer(std::uint32_t src);
    void readPixels(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void* pixels);
    void readnPixels(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* data);
    void rectd(double x1, double y1, double x2, double y2);
    void rectdv(double const* v1, double const* v2);
    void rectf(float x1, float y1, float x2, float y2);
    void rectfv(float const* v1, float const* v2);
    void recti(std::int32_t x1, std::int32_t y1, std::int32_t x2, std::int32_t y2);
    void rectiv(std::int32_t const* v1, std::int32_t const* v2);
    void rects(std::int16_t x1, std::int16_t y1, std::int16_t x2, std::int16_t y2);
    void rectsv(std::int16_t const* v1, std::int16_t const* v2);
    void releaseShaderCompiler();
    std::int32_t renderMode(std::uint32_t mode);
    void renderbufferStorage(std::uint32_t target, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void renderbufferStorageMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void resumeTransformFeedback();
    void rotated(double angle, double x, double y, double z);
    void rotatef(float angle, float x, float y, float z);
    void rotatex(std::int32_t angle, std::int32_t x, std::int32_t y, std::int32_t z);
    void sampleCoverage(float value, std::uint8_t invert);
    void sampleCoveragex(std::int32_t value, std::uint8_t invert);
    void sampleMaski(std::uint32_t maskNumber, std::uint32_t mask);
    void samplerParameterIiv(std::uint32_t sampler, std::uint32_t pname, std::int32_t const* param);
    void samplerParameterIuiv(std::uint32_t sampler, std::uint32_t pname, std::uint32_t const* param);
    void samplerParameterf(std::uint32_t sampler, std::uint32_t pname, float param);
    void samplerParameterfv(std::uint32_t sampler, std::uint32_t pname, float const* param);
    void samplerParameteri(std::uint32_t sampler, std::uint32_t pname, std::int32_t param);
    void samplerParameteriv(std::uint32_t sampler, std::uint32_t pname, std::int32_t const* param);
    void scaled(double x, double y, double z);
    void scalef(float x, float y, float z);
    void scalex(std::int32_t x, std::int32_t y, std::int32_t z);
    void scissor(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void scissorArrayv(std::uint32_t first, std::int32_t count, std::int32_t const* v);
    void scissorIndexed(std::uint32_t index, std::int32_t left, std::int32_t bottom, std::int32_t width, std::int32_t height);
    void scissorIndexedv(std::uint32_t index, std::int32_t const* v);
    void secondaryColor3b(std::int32_t red, std::int32_t green, std::int32_t blue);
    void secondaryColor3bv(std::int32_t const* v);
    void secondaryColor3d(double red, double green, double blue);
    void secondaryColor3dv(double const* v);
    void secondaryColor3f(float red, float green, float blue);
    void secondaryColor3fv(float const* v);
    void secondaryColor3i(std::int32_t red, std::int32_t green, std::int32_t blue);
    void secondaryColor3iv(std::int32_t const* v);
    void secondaryColor3s(std::int16_t red, std::int16_t green, std::int16_t blue);
    void secondaryColor3sv(std::int16_t const* v);
    void secondaryColor3ub(std::uint8_t red, std::uint8_t green, std::uint8_t blue);
    void secondaryColor3ubv(std::uint8_t const* v);
    void secondaryColor3ui(std::uint32_t red, std::uint32_t green, std::uint32_t blue);
    void secondaryColor3uiv(std::uint32_t const* v);
    void secondaryColor3us(std::uint16_t red, std::uint16_t green, std::uint16_t blue);
    void secondaryColor3usv(std::uint16_t const* v);
    void secondaryColorP3ui(std::uint32_t type, std::uint32_t color);
    void secondaryColorP3uiv(std::uint32_t type, std::uint32_t const* color);
    void secondaryColorPointer(std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void selectBuffer(std::int32_t size, std::uint32_t* buffer);
    void shadeModel(std::uint32_t mode);
    void shaderBinary(std::int32_t count, std::uint32_t const* shaders, std::uint32_t binaryFormat, void const* binary, std::int32_t length);
    void shaderSource(std::uint32_t shader, std::int32_t count, char const* const*string, std::int32_t const* length);
    void shaderStorageBlockBinding(std::uint32_t program, std::uint32_t storageBlockIndex, std::uint32_t storageBlockBinding);
    void specializeShader(std::uint32_t shader, char const* pEntryPoint, std::uint32_t numSpecializationConstants, std::uint32_t const* pConstantIndex, std::uint32_t const* pConstantValue);
    void stencilFunc(std::uint32_t func, std::int32_t ref, std::uint32_t mask);
    void stencilFuncSeparate(std::uint32_t face, std::uint32_t func, std::int32_t ref, std::uint32_t mask);
    void stencilMask(std::uint32_t mask);
    void stencilMaskSeparate(std::uint32_t face, std::uint32_t mask);
    void stencilOp(std::uint32_t fail, std::uint32_t zfail, std::uint32_t zpass);
    void stencilOpSeparate(std::uint32_t face, std::uint32_t sfail, std::uint32_t dpfail, std::uint32_t dppass);
    void texBuffer(std::uint32_t target, std::uint32_t internalformat, std::uint32_t buffer);
    void texBufferRange(std::uint32_t target, std::uint32_t internalformat, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void texCoord1d(double s);
    void texCoord1dv(double const* v);
    void texCoord1f(float s);
    void texCoord1fv(float const* v);
    void texCoord1i(std::int32_t s);
    void texCoord1iv(std::int32_t const* v);
    void texCoord1s(std::int16_t s);
    void texCoord1sv(std::int16_t const* v);
    void texCoord2d(double s, double t);
    void texCoord2dv(double const* v);
    void texCoord2f(float s, float t);
    void texCoord2fv(float const* v);
    void texCoord2i(std::int32_t s, std::int32_t t);
    void texCoord2iv(std::int32_t const* v);
    void texCoord2s(std::int16_t s, std::int16_t t);
    void texCoord2sv(std::int16_t const* v);
    void texCoord3d(double s, double t, double r);
    void texCoord3dv(double const* v);
    void texCoord3f(float s, float t, float r);
    void texCoord3fv(float const* v);
    void texCoord3i(std::int32_t s, std::int32_t t, std::int32_t r);
    void texCoord3iv(std::int32_t const* v);
    void texCoord3s(std::int16_t s, std::int16_t t, std::int16_t r);
    void texCoord3sv(std::int16_t const* v);
    void texCoord4d(double s, double t, double r, double q);
    void texCoord4dv(double const* v);
    void texCoord4f(float s, float t, float r, float q);
    void texCoord4fv(float const* v);
    void texCoord4i(std::int32_t s, std::int32_t t, std::int32_t r, std::int32_t q);
    void texCoord4iv(std::int32_t const* v);
    void texCoord4s(std::int16_t s, std::int16_t t, std::int16_t r, std::int16_t q);
    void texCoord4sv(std::int16_t const* v);
    void texCoordP1ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP1uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordP2ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP2uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordP3ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP3uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordP4ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP4uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordPointer(std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void texEnvf(std::uint32_t target, std::uint32_t pname, float param);
    void texEnvfv(std::uint32_t target, std::uint32_t pname, float const* params);
    void texEnvi(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void texEnviv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texEnvx(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void texEnvxv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texGend(std::uint32_t coord, std::uint32_t pname, double param);
    void texGendv(std::uint32_t coord, std::uint32_t pname, double const* params);
    void texGenf(std::uint32_t coord, std::uint32_t pname, float param);
    void texGenfv(std::uint32_t coord, std::uint32_t pname, float const* params);
    void texGeni(std::uint32_t coord, std::uint32_t pname, std::int32_t param);
    void texGeniv(std::uint32_t coord, std::uint32_t pname, std::int32_t const* params);
    void texImage1D(std::uint32_t target, std::int32_t level, std::int32_t internalformat, std::int32_t width, std::int32_t border, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texImage2D(std::uint32_t target, std::int32_t level, std::int32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t border, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texImage2DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::uint8_t fixedsamplelocations);
    void texImage3D(std::uint32_t target, std::int32_t level, std::int32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::int32_t border, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texImage3DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint8_t fixedsamplelocations);
    void texParameterIiv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texParameterIuiv(std::uint32_t target, std::uint32_t pname, std::uint32_t const* params);
    void texParameterf(std::uint32_t target, std::uint32_t pname, float param);
    void texParameterfv(std::uint32_t target, std::uint32_t pname, float const* params);
    void texParameteri(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void texParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texParameterx(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void texParameterxv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texStorage1D(std::uint32_t target, std::int32_t levels, std::uint32_t internalformat, std::int32_t width);
    void texStorage2D(std::uint32_t target, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void texStorage2DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::uint8_t fixedsamplelocations);
    void texStorage3D(std::uint32_t target, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth);
    void texStorage3DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint8_t fixedsamplelocations);
    void texSubImage1D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texSubImage2D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texSubImage3D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, void const* pixels);
    void textureBarrier();
    void textureBuffer(std::uint32_t texture, std::uint32_t internalformat, std::uint32_t buffer);
    void textureBufferRange(std::uint32_t texture, std::uint32_t internalformat, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void textureParameterIiv(std::uint32_t texture, std::uint32_t pname, std::int32_t const* params);
    void textureParameterIuiv(std::uint32_t texture, std::uint32_t pname, std::uint32_t const* params);
    void textureParameterf(std::uint32_t texture, std::uint32_t pname, float param);
    void textureParameterfv(std::uint32_t texture, std::uint32_t pname, float const* param);
    void textureParameteri(std::uint32_t texture, std::uint32_t pname, std::int32_t param);
    void textureParameteriv(std::uint32_t texture, std::uint32_t pname, std::int32_t const* param);
    void textureStorage1D(std::uint32_t texture, std::int32_t levels, std::uint32_t internalformat, std::int32_t width);
    void textureStorage2D(std::uint32_t texture, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void textureStorage2DMultisample(std::uint32_t texture, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::uint8_t fixedsamplelocations);
    void textureStorage3D(std::uint32_t texture, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth);
    void textureStorage3DMultisample(std::uint32_t texture, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint8_t fixedsamplelocations);
    void textureSubImage1D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::uint32_t type, void const* pixels);
    void textureSubImage2D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void const* pixels);
    void textureSubImage3D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, void const* pixels);
    void textureView(std::uint32_t texture, std::uint32_t target, std::uint32_t origtexture, std::uint32_t internalformat, std::uint32_t minlevel, std::uint32_t numlevels, std::uint32_t minlayer, std::uint32_t numlayers);
    void transformFeedbackBufferBase(std::uint32_t xfb, std::uint32_t index, std::uint32_t buffer);
    void transformFeedbackBufferRange(std::uint32_t xfb, std::uint32_t index, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void transformFeedbackVaryings(std::uint32_t program, std::int32_t count, char const* const*varyings, std::uint32_t bufferMode);
    void translated(double x, double y, double z);
    void translatef(float x, float y, float z);
    void translatex(std::int32_t x, std::int32_t y, std::int32_t z);
    void uniform1d(std::int32_t location, double x);
    void uniform1dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform1f(std::int32_t location, float v0);
    void uniform1fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform1i(std::int32_t location, std::int32_t v0);
    void uniform1iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform1ui(std::int32_t location, std::uint32_t v0);
    void uniform1uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniform2d(std::int32_t location, double x, double y);
    void uniform2dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform2f(std::int32_t location, float v0, float v1);
    void uniform2fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform2i(std::int32_t location, std::int32_t v0, std::int32_t v1);
    void uniform2iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform2ui(std::int32_t location, std::uint32_t v0, std::uint32_t v1);
    void uniform2uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniform3d(std::int32_t location, double x, double y, double z);
    void uniform3dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform3f(std::int32_t location, float v0, float v1, float v2);
    void uniform3fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform3i(std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2);
    void uniform3iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform3ui(std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2);
    void uniform3uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniform4d(std::int32_t location, double x, double y, double z, double w);
    void uniform4dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform4f(std::int32_t location, float v0, float v1, float v2, float v3);
    void uniform4fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform4i(std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2, std::int32_t v3);
    void uniform4iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform4ui(std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2, std::uint32_t v3);
    void uniform4uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniformBlockBinding(std::uint32_t program, std::uint32_t uniformBlockIndex, std::uint32_t uniformBlockBinding);
    void uniformMatrix2dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix2fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix2x3dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix2x3fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix2x4dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix2x4fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix3dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix3fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix3x2dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix3x2fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix3x4dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix3x4fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix4dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix4fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix4x2dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix4x2fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix4x3dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix4x3fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformSubroutinesuiv(std::uint32_t shadertype, std::int32_t count, std::uint32_t const* indices);
    std::uint8_t unmapBuffer(std::uint32_t target);
    std::uint8_t unmapNamedBuffer(std::uint32_t buffer);
    void useProgram(std::uint32_t program);
    void useProgramStages(std::uint32_t pipeline, std::uint32_t stages, std::uint32_t program);
    void validateProgram(std::uint32_t program);
    void validateProgramPipeline(std::uint32_t pipeline);
    void vertex2d(double x, double y);
    void vertex2dv(double const* v);
    void vertex2f(float x, float y);
    void vertex2fv(float const* v);
    void vertex2i(std::int32_t x, std::int32_t y);
    void vertex2iv(std::int32_t const* v);
    void vertex2s(std::int16_t x, std::int16_t y);
    void vertex2sv(std::int16_t const* v);
    void vertex3d(double x, double y, double z);
    void vertex3dv(double const* v);
    void vertex3f(float x, float y, float z);
    void vertex3fv(float const* v);
    void vertex3i(std::int32_t x, std::int32_t y, std::int32_t z);
    void vertex3iv(std::int32_t const* v);
    void vertex3s(std::int16_t x, std::int16_t y, std::int16_t z);
    void vertex3sv(std::int16_t const* v);
    void vertex4d(double x, double y, double z, double w);
    void vertex4dv(double const* v);
    void vertex4f(float x, float y, float z, float w);
    void vertex4fv(float const* v);
    void vertex4i(std::int32_t x, std::int32_t y, std::int32_t z, std::int32_t w);
    void vertex4iv(std::int32_t const* v);
    void vertex4s(std::int16_t x, std::int16_t y, std::int16_t z, std::int16_t w);
    void vertex4sv(std::int16_t const* v);
    void vertexArrayAttribBinding(std::uint32_t vaobj, std::uint32_t attribindex, std::uint32_t bindingindex);
    void vertexArrayAttribFormat(std::uint32_t vaobj, std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint8_t normalized, std::uint32_t relativeoffset);
    void vertexArrayAttribIFormat(std::uint32_t vaobj, std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexArrayAttribLFormat(std::uint32_t vaobj, std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexArrayBindingDivisor(std::uint32_t vaobj, std::uint32_t bindingindex, std::uint32_t divisor);
    void vertexArrayElementBuffer(std::uint32_t vaobj, std::uint32_t buffer);
    void vertexArrayVertexBuffer(std::uint32_t vaobj, std::uint32_t bindingindex, std::uint32_t buffer, std::intptr_t offset, std::int32_t stride);
    void vertexArrayVertexBuffers(std::uint32_t vaobj, std::uint32_t first, std::int32_t count, std::uint32_t const* buffers, std::intptr_t const* offsets, std::int32_t const* strides);
    void vertexAttrib1d(std::uint32_t index, double x);
    void vertexAttrib1dv(std::uint32_t index, double const* v);
    void vertexAttrib1f(std::uint32_t index, float x);
    void vertexAttrib1fv(std::uint32_t index, float const* v);
    void vertexAttrib1s(std::uint32_t index, std::int16_t x);
    void vertexAttrib1sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib2d(std::uint32_t index, double x, double y);
    void vertexAttrib2dv(std::uint32_t index, double const* v);
    void vertexAttrib2f(std::uint32_t index, float x, float y);
    void vertexAttrib2fv(std::uint32_t index, float const* v);
    void vertexAttrib2s(std::uint32_t index, std::int16_t x, std::int16_t y);
    void vertexAttrib2sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib3d(std::uint32_t index, double x, double y, double z);
    void vertexAttrib3dv(std::uint32_t index, double const* v);
    void vertexAttrib3f(std::uint32_t index, float x, float y, float z);
    void vertexAttrib3fv(std::uint32_t index, float const* v);
    void vertexAttrib3s(std::uint32_t index, std::int16_t x, std::int16_t y, std::int16_t z);
    void vertexAttrib3sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib4Nbv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4Niv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4Nsv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib4Nub(std::uint32_t index, std::uint8_t x, std::uint8_t y, std::uint8_t z, std::uint8_t w);
    void vertexAttrib4Nubv(std::uint32_t index, std::uint8_t const* v);
    void vertexAttrib4Nuiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttrib4Nusv(std::uint32_t index, std::uint16_t const* v);
    void vertexAttrib4bv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4d(std::uint32_t index, double x, double y, double z, double w);
    void vertexAttrib4dv(std::uint32_t index, double const* v);
    void vertexAttrib4f(std::uint32_t index, float x, float y, float z, float w);
    void vertexAttrib4fv(std::uint32_t index, float const* v);
    void vertexAttrib4iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4s(std::uint32_t index, std::int16_t x, std::int16_t y, std::int16_t z, std::int16_t w);
    void vertexAttrib4sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib4ubv(std::uint32_t index, std::uint8_t const* v);
    void vertexAttrib4uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttrib4usv(std::uint32_t index, std::uint16_t const* v);
    void vertexAttribBinding(std::uint32_t attribindex, std::uint32_t bindingindex);
    void vertexAttribDivisor(std::uint32_t index, std::uint32_t divisor);
    void vertexAttribFormat(std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint8_t normalized, std::uint32_t relativeoffset);
    void vertexAttribI1i(std::uint32_t index, std::int32_t x);
    void vertexAttribI1iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI1ui(std::uint32_t index, std::uint32_t x);
    void vertexAttribI1uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI2i(std::uint32_t index, std::int32_t x, std::int32_t y);
    void vertexAttribI2iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI2ui(std::uint32_t index, std::uint32_t x, std::uint32_t y);
    void vertexAttribI2uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI3i(std::uint32_t index, std::int32_t x, std::int32_t y, std::int32_t z);
    void vertexAttribI3iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI3ui(std::uint32_t index, std::uint32_t x, std::uint32_t y, std::uint32_t z);
    void vertexAttribI3uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI4bv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI4i(std::uint32_t index, std::int32_t x, std::int32_t y, std::int32_t z, std::int32_t w);
    void vertexAttribI4iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI4sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttribI4ubv(std::uint32_t index, std::uint8_t const* v);
    void vertexAttribI4ui(std::uint32_t index, std::uint32_t x, std::uint32_t y, std::uint32_t z, std::uint32_t w);
    void vertexAttribI4uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI4usv(std::uint32_t index, std::uint16_t const* v);
    void vertexAttribIFormat(std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexAttribIPointer(std::uint32_t index, std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void vertexAttribL1d(std::uint32_t index, double x);
    void vertexAttribL1dv(std::uint32_t index, double const* v);
    void vertexAttribL2d(std::uint32_t index, double x, double y);
    void vertexAttribL2dv(std::uint32_t index, double const* v);
    void vertexAttribL3d(std::uint32_t index, double x, double y, double z);
    void vertexAttribL3dv(std::uint32_t index, double const* v);
    void vertexAttribL4d(std::uint32_t index, double x, double y, double z, double w);
    void vertexAttribL4dv(std::uint32_t index, double const* v);
    void vertexAttribLFormat(std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexAttribLPointer(std::uint32_t index, std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void vertexAttribP1ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP1uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribP2ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP2uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribP3ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP3uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribP4ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP4uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribPointer(std::uint32_t index, std::int32_t size, std::uint32_t type, std::uint8_t normalized, std::int32_t stride, void const* pointer);
    void vertexBindingDivisor(std::uint32_t bindingindex, std::uint32_t divisor);
    void vertexP2ui(std::uint32_t type, std::uint32_t value);
    void vertexP2uiv(std::uint32_t type, std::uint32_t const* value);
    void vertexP3ui(std::uint32_t type, std::uint32_t value);
    void vertexP3uiv(std::uint32_t type, std::uint32_t const* value);
    void vertexP4ui(std::uint32_t type, std::uint32_t value);
    void vertexP4uiv(std::uint32_t type, std::uint32_t const* value);
    void vertexPointer(std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void viewport(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void viewportArrayv(std::uint32_t first, std::int32_t count, float const* v);
    void viewportIndexedf(std::uint32_t index, float x, float y, float w, float h);
    void viewportIndexedfv(std::uint32_t index, float const* v);
    void waitSync(void* sync, std::uint32_t flags, std::uint64_t timeout);
    void windowPos2d(double x, double y);
    void windowPos2dv(double const* v);
    void windowPos2f(float x, float y);
    void windowPos2fv(float const* v);
    void windowPos2i(std::int32_t x, std::int32_t y);
    void windowPos2iv(std::int32_t const* v);
    void windowPos2s(std::int16_t x, std::int16_t y);
    void windowPos2sv(std::int16_t const* v);
    void windowPos3d(double x, double y, double z);
    void windowPos3dv(double const* v);
    void windowPos3f(float x, float y, float z);
    void windowPos3fv(float const* v);
    void windowPos3i(std::int32_t x, std::int32_t y, std::int32_t z);
    void windowPos3iv(std::int32_t const* v);
    void windowPos3s(std::int16_t x, std::int16_t y, std::int16_t z);
    void windowPos3sv(std::int16_t const* v);
    void swap();
    virtual ~OpenGL();
private:
    boom::__OpenGLImpl* _impl;
    void _current();
    void _bootstrap();
    void _implInit(boom::OpenGLOptions const&);
    void _implDone();
    void _implSwap();
    void _implCurrent();
    void _implBootstrap();
};

auto constexpr OpenGL2Bytes = 0x1407;
auto constexpr OpenGL2d = 0x0600;
auto constexpr OpenGL3Bytes = 0x1408;
auto constexpr OpenGL3d = 0x0601;
auto constexpr OpenGL3dColor = 0x0602;
auto constexpr OpenGL3dColorTexture = 0x0603;
auto constexpr OpenGL4Bytes = 0x1409;
auto constexpr OpenGL4dColorTexture = 0x0604;
auto constexpr OpenGLAccum = 0x0100;
auto constexpr OpenGLAccumAlphaBits = 0x0d5b;
auto constexpr OpenGLAccumBlueBits = 0x0d5a;
auto constexpr OpenGLAccumBufferBit = 0x00000200;
auto constexpr OpenGLAccumClearValue = 0x0b80;
auto constexpr OpenGLAccumGreenBits = 0x0d59;
auto constexpr OpenGLAccumRedBits = 0x0d58;
auto constexpr OpenGLActiveAtomicCounterBuffers = 0x92d9;
auto constexpr OpenGLActiveAttributeMaxLength = 0x8b8a;
auto constexpr OpenGLActiveAttributes = 0x8b89;
auto constexpr OpenGLActiveProgram = 0x8259;
auto constexpr OpenGLActiveResources = 0x92f5;
auto constexpr OpenGLActiveSubroutineMaxLength = 0x8e48;
auto constexpr OpenGLActiveSubroutineUniformLocations = 0x8e47;
auto constexpr OpenGLActiveSubroutineUniformMaxLength = 0x8e49;
auto constexpr OpenGLActiveSubroutineUniforms = 0x8de6;
auto constexpr OpenGLActiveSubroutines = 0x8de5;
auto constexpr OpenGLActiveTexture = 0x84e0;
auto constexpr OpenGLActiveUniformBlockMaxNameLength = 0x8a35;
auto constexpr OpenGLActiveUniformBlocks = 0x8a36;
auto constexpr OpenGLActiveUniformMaxLength = 0x8b87;
auto constexpr OpenGLActiveUniforms = 0x8b86;
auto constexpr OpenGLActiveVariables = 0x9305;
auto constexpr OpenGLAdd = 0x0104;
auto constexpr OpenGLAddSigned = 0x8574;
auto constexpr OpenGLAliasedLineWidthRange = 0x846e;
auto constexpr OpenGLAliasedPointSizeRange = 0x846d;
auto constexpr OpenGLAllAttribBits = 0xffffffff;
auto constexpr OpenGLAllBarrierBits = 0xffffffff;
auto constexpr OpenGLAllShaderBits = 0xffffffff;
auto constexpr OpenGLAlpha = 0x1906;
auto constexpr OpenGLAlpha12 = 0x803d;
auto constexpr OpenGLAlpha16 = 0x803e;
auto constexpr OpenGLAlpha4 = 0x803b;
auto constexpr OpenGLAlpha8 = 0x803c;
auto constexpr OpenGLAlphaBias = 0x0d1d;
auto constexpr OpenGLAlphaBits = 0x0d55;
auto constexpr OpenGLAlphaInteger = 0x8d97;
auto constexpr OpenGLAlphaScale = 0x0d1c;
auto constexpr OpenGLAlphaTest = 0x0bc0;
auto constexpr OpenGLAlphaTestFunc = 0x0bc1;
auto constexpr OpenGLAlphaTestRef = 0x0bc2;
auto constexpr OpenGLAlreadySignaled = 0x911a;
auto constexpr OpenGLAlways = 0x0207;
auto constexpr OpenGLAmbient = 0x1200;
auto constexpr OpenGLAmbientAndDiffuse = 0x1602;
auto constexpr OpenGLAnd = 0x1501;
auto constexpr OpenGLAndInverted = 0x1504;
auto constexpr OpenGLAndReverse = 0x1502;
auto constexpr OpenGLAnySamplesPassed = 0x8c2f;
auto constexpr OpenGLAnySamplesPassedConservative = 0x8d6a;
auto constexpr OpenGLArrayBuffer = 0x8892;
auto constexpr OpenGLArrayBufferBinding = 0x8894;
auto constexpr OpenGLArraySize = 0x92fb;
auto constexpr OpenGLArrayStride = 0x92fe;
auto constexpr OpenGLAtomicCounterBarrierBit = 0x00001000;
auto constexpr OpenGLAtomicCounterBuffer = 0x92c0;
auto constexpr OpenGLAtomicCounterBufferActiveAtomicCounterIndices = 0x92c6;
auto constexpr OpenGLAtomicCounterBufferActiveAtomicCounters = 0x92c5;
auto constexpr OpenGLAtomicCounterBufferBinding = 0x92c1;
auto constexpr OpenGLAtomicCounterBufferDataSize = 0x92c4;
auto constexpr OpenGLAtomicCounterBufferIndex = 0x9301;
auto constexpr OpenGLAtomicCounterBufferReferencedByComputeShader = 0x90ed;
auto constexpr OpenGLAtomicCounterBufferReferencedByFragmentShader = 0x92cb;
auto constexpr OpenGLAtomicCounterBufferReferencedByGeometryShader = 0x92ca;
auto constexpr OpenGLAtomicCounterBufferReferencedByTessControlShader = 0x92c8;
auto constexpr OpenGLAtomicCounterBufferReferencedByTessEvaluationShader = 0x92c9;
auto constexpr OpenGLAtomicCounterBufferReferencedByVertexShader = 0x92c7;
auto constexpr OpenGLAtomicCounterBufferSize = 0x92c3;
auto constexpr OpenGLAtomicCounterBufferStart = 0x92c2;
auto constexpr OpenGLAttachedShaders = 0x8b85;
auto constexpr OpenGLAttribStackDepth = 0x0bb0;
auto constexpr OpenGLAutoGenerateMipmap = 0x8295;
auto constexpr OpenGLAutoNormal = 0x0d80;
auto constexpr OpenGLAux0 = 0x0409;
auto constexpr OpenGLAux1 = 0x040a;
auto constexpr OpenGLAux2 = 0x040b;
auto constexpr OpenGLAux3 = 0x040c;
auto constexpr OpenGLAuxBuffers = 0x0c00;
auto constexpr OpenGLBGRA = 0x80e1;
auto constexpr OpenGLBGRAInteger = 0x8d9b;
auto constexpr OpenGLBack = 0x0405;
auto constexpr OpenGLBackLeft = 0x0402;
auto constexpr OpenGLBackRight = 0x0403;
auto constexpr OpenGLBgr = 0x80e0;
auto constexpr OpenGLBgrInteger = 0x8d9a;
auto constexpr OpenGLBitmap = 0x1a00;
auto constexpr OpenGLBitmapToken = 0x0704;
auto constexpr OpenGLBlend = 0x0be2;
auto constexpr OpenGLBlendColor = 0x8005;
auto constexpr OpenGLBlendDst = 0x0be0;
auto constexpr OpenGLBlendDstAlpha = 0x80ca;
auto constexpr OpenGLBlendDstRgb = 0x80c8;
auto constexpr OpenGLBlendEquation = 0x8009;
auto constexpr OpenGLBlendEquationAlpha = 0x883d;
auto constexpr OpenGLBlendEquationRgb = 0x8009;
auto constexpr OpenGLBlendSrc = 0x0be1;
auto constexpr OpenGLBlendSrcAlpha = 0x80cb;
auto constexpr OpenGLBlendSrcRgb = 0x80c9;
auto constexpr OpenGLBlockIndex = 0x92fd;
auto constexpr OpenGLBlue = 0x1905;
auto constexpr OpenGLBlueBias = 0x0d1b;
auto constexpr OpenGLBlueBits = 0x0d54;
auto constexpr OpenGLBlueInteger = 0x8d96;
auto constexpr OpenGLBlueScale = 0x0d1a;
auto constexpr OpenGLBool = 0x8b56;
auto constexpr OpenGLBoolVec2 = 0x8b57;
auto constexpr OpenGLBoolVec3 = 0x8b58;
auto constexpr OpenGLBoolVec4 = 0x8b59;
auto constexpr OpenGLBuffer = 0x82e0;
auto constexpr OpenGLBufferAccess = 0x88bb;
auto constexpr OpenGLBufferAccessFlags = 0x911f;
auto constexpr OpenGLBufferBinding = 0x9302;
auto constexpr OpenGLBufferDataSize = 0x9303;
auto constexpr OpenGLBufferImmutableStorage = 0x821f;
auto constexpr OpenGLBufferMapLength = 0x9120;
auto constexpr OpenGLBufferMapOffset = 0x9121;
auto constexpr OpenGLBufferMapPointer = 0x88bd;
auto constexpr OpenGLBufferMapped = 0x88bc;
auto constexpr OpenGLBufferSize = 0x8764;
auto constexpr OpenGLBufferStorageFlags = 0x8220;
auto constexpr OpenGLBufferUpdateBarrierBit = 0x00000200;
auto constexpr OpenGLBufferUsage = 0x8765;
auto constexpr OpenGLBufferVariable = 0x92e5;
auto constexpr OpenGLByte = 0x1400;
auto constexpr OpenGLC3fV3f = 0x2a24;
auto constexpr OpenGLC4fN3fV3f = 0x2a26;
auto constexpr OpenGLC4ubV2f = 0x2a22;
auto constexpr OpenGLC4ubV3f = 0x2a23;
auto constexpr OpenGLCaveatSupport = 0x82b8;
auto constexpr OpenGLCcw = 0x0901;
auto constexpr OpenGLClamp = 0x2900;
auto constexpr OpenGLClampFragmentColor = 0x891b;
auto constexpr OpenGLClampReadColor = 0x891c;
auto constexpr OpenGLClampToBorder = 0x812d;
auto constexpr OpenGLClampToEdge = 0x812f;
auto constexpr OpenGLClampVertexColor = 0x891a;
auto constexpr OpenGLClear = 0x1500;
auto constexpr OpenGLClearBuffer = 0x82b4;
auto constexpr OpenGLClearTexture = 0x9365;
auto constexpr OpenGLClientActiveTexture = 0x84e1;
auto constexpr OpenGLClientAllAttribBits = 0xffffffff;
auto constexpr OpenGLClientAttribStackDepth = 0x0bb1;
auto constexpr OpenGLClientMappedBufferBarrierBit = 0x00004000;
auto constexpr OpenGLClientPixelStoreBit = 0x00000001;
auto constexpr OpenGLClientStorageBit = 0x0200;
auto constexpr OpenGLClientVertexArrayBit = 0x00000002;
auto constexpr OpenGLClipDepthMode = 0x935d;
auto constexpr OpenGLClipDistance0 = 0x3000;
auto constexpr OpenGLClipDistance1 = 0x3001;
auto constexpr OpenGLClipDistance2 = 0x3002;
auto constexpr OpenGLClipDistance3 = 0x3003;
auto constexpr OpenGLClipDistance4 = 0x3004;
auto constexpr OpenGLClipDistance5 = 0x3005;
auto constexpr OpenGLClipDistance6 = 0x3006;
auto constexpr OpenGLClipDistance7 = 0x3007;
auto constexpr OpenGLClipOrigin = 0x935c;
auto constexpr OpenGLClipPlane0 = 0x3000;
auto constexpr OpenGLClipPlane1 = 0x3001;
auto constexpr OpenGLClipPlane2 = 0x3002;
auto constexpr OpenGLClipPlane3 = 0x3003;
auto constexpr OpenGLClipPlane4 = 0x3004;
auto constexpr OpenGLClipPlane5 = 0x3005;
auto constexpr OpenGLClippingInputPrimitives = 0x82f6;
auto constexpr OpenGLClippingOutputPrimitives = 0x82f7;
auto constexpr OpenGLCoeff = 0x0a00;
auto constexpr OpenGLColor = 0x1800;
auto constexpr OpenGLColorArray = 0x8076;
auto constexpr OpenGLColorArrayBufferBinding = 0x8898;
auto constexpr OpenGLColorArrayPointer = 0x8090;
auto constexpr OpenGLColorArraySize = 0x8081;
auto constexpr OpenGLColorArrayStride = 0x8083;
auto constexpr OpenGLColorArrayType = 0x8082;
auto constexpr OpenGLColorAttachment0 = 0x8ce0;
auto constexpr OpenGLColorAttachment1 = 0x8ce1;
auto constexpr OpenGLColorAttachment10 = 0x8cea;
auto constexpr OpenGLColorAttachment11 = 0x8ceb;
auto constexpr OpenGLColorAttachment12 = 0x8cec;
auto constexpr OpenGLColorAttachment13 = 0x8ced;
auto constexpr OpenGLColorAttachment14 = 0x8cee;
auto constexpr OpenGLColorAttachment15 = 0x8cef;
auto constexpr OpenGLColorAttachment16 = 0x8cf0;
auto constexpr OpenGLColorAttachment17 = 0x8cf1;
auto constexpr OpenGLColorAttachment18 = 0x8cf2;
auto constexpr OpenGLColorAttachment19 = 0x8cf3;
auto constexpr OpenGLColorAttachment2 = 0x8ce2;
auto constexpr OpenGLColorAttachment20 = 0x8cf4;
auto constexpr OpenGLColorAttachment21 = 0x8cf5;
auto constexpr OpenGLColorAttachment22 = 0x8cf6;
auto constexpr OpenGLColorAttachment23 = 0x8cf7;
auto constexpr OpenGLColorAttachment24 = 0x8cf8;
auto constexpr OpenGLColorAttachment25 = 0x8cf9;
auto constexpr OpenGLColorAttachment26 = 0x8cfa;
auto constexpr OpenGLColorAttachment27 = 0x8cfb;
auto constexpr OpenGLColorAttachment28 = 0x8cfc;
auto constexpr OpenGLColorAttachment29 = 0x8cfd;
auto constexpr OpenGLColorAttachment3 = 0x8ce3;
auto constexpr OpenGLColorAttachment30 = 0x8cfe;
auto constexpr OpenGLColorAttachment31 = 0x8cff;
auto constexpr OpenGLColorAttachment4 = 0x8ce4;
auto constexpr OpenGLColorAttachment5 = 0x8ce5;
auto constexpr OpenGLColorAttachment6 = 0x8ce6;
auto constexpr OpenGLColorAttachment7 = 0x8ce7;
auto constexpr OpenGLColorAttachment8 = 0x8ce8;
auto constexpr OpenGLColorAttachment9 = 0x8ce9;
auto constexpr OpenGLColorBufferBit = 0x00004000;
auto constexpr OpenGLColorClearValue = 0x0c22;
auto constexpr OpenGLColorComponents = 0x8283;
auto constexpr OpenGLColorEncoding = 0x8296;
auto constexpr OpenGLColorIndex = 0x1900;
auto constexpr OpenGLColorIndexes = 0x1603;
auto constexpr OpenGLColorLogicOp = 0x0bf2;
auto constexpr OpenGLColorMaterial = 0x0b57;
auto constexpr OpenGLColorMaterialFace = 0x0b55;
auto constexpr OpenGLColorMaterialParameter = 0x0b56;
auto constexpr OpenGLColorRenderable = 0x8286;
auto constexpr OpenGLColorSum = 0x8458;
auto constexpr OpenGLColorTable = 0x80d0;
auto constexpr OpenGLColorWriteMask = 0x0c23;
auto constexpr OpenGLColorburn = 0x929a;
auto constexpr OpenGLColordodge = 0x9299;
auto constexpr OpenGLCombine = 0x8570;
auto constexpr OpenGLCombineAlpha = 0x8572;
auto constexpr OpenGLCombineRgb = 0x8571;
auto constexpr OpenGLCommandBarrierBit = 0x00000040;
auto constexpr OpenGLCompareRToTexture = 0x884e;
auto constexpr OpenGLCompareRefToTexture = 0x884e;
auto constexpr OpenGLCompatibleSubroutines = 0x8e4b;
auto constexpr OpenGLCompile = 0x1300;
auto constexpr OpenGLCompileAndExecute = 0x1301;
auto constexpr OpenGLCompileStatus = 0x8b81;
auto constexpr OpenGLCompressedAlpha = 0x84e9;
auto constexpr OpenGLCompressedIntensity = 0x84ec;
auto constexpr OpenGLCompressedLuminance = 0x84ea;
auto constexpr OpenGLCompressedLuminanceAlpha = 0x84eb;
auto constexpr OpenGLCompressedR11Eac = 0x9270;
auto constexpr OpenGLCompressedRGBA = 0x84ee;
auto constexpr OpenGLCompressedRGBA8Etc2Eac = 0x9278;
auto constexpr OpenGLCompressedRGBAAstc10x10 = 0x93bb;
auto constexpr OpenGLCompressedRGBAAstc10x5 = 0x93b8;
auto constexpr OpenGLCompressedRGBAAstc10x6 = 0x93b9;
auto constexpr OpenGLCompressedRGBAAstc10x8 = 0x93ba;
auto constexpr OpenGLCompressedRGBAAstc12x10 = 0x93bc;
auto constexpr OpenGLCompressedRGBAAstc12x12 = 0x93bd;
auto constexpr OpenGLCompressedRGBAAstc4x4 = 0x93b0;
auto constexpr OpenGLCompressedRGBAAstc5x4 = 0x93b1;
auto constexpr OpenGLCompressedRGBAAstc5x5 = 0x93b2;
auto constexpr OpenGLCompressedRGBAAstc6x5 = 0x93b3;
auto constexpr OpenGLCompressedRGBAAstc6x6 = 0x93b4;
auto constexpr OpenGLCompressedRGBAAstc8x5 = 0x93b5;
auto constexpr OpenGLCompressedRGBAAstc8x6 = 0x93b6;
auto constexpr OpenGLCompressedRGBAAstc8x8 = 0x93b7;
auto constexpr OpenGLCompressedRGBABptcUnorm = 0x8e8c;
auto constexpr OpenGLCompressedRed = 0x8225;
auto constexpr OpenGLCompressedRedRgtc1 = 0x8dbb;
auto constexpr OpenGLCompressedRg = 0x8226;
auto constexpr OpenGLCompressedRg11Eac = 0x9272;
auto constexpr OpenGLCompressedRgRgtc2 = 0x8dbd;
auto constexpr OpenGLCompressedRgb = 0x84ed;
auto constexpr OpenGLCompressedRgb8Etc2 = 0x9274;
auto constexpr OpenGLCompressedRgb8PunchthroughAlpha1Etc2 = 0x9276;
auto constexpr OpenGLCompressedRgbBptcSignedFloat = 0x8e8e;
auto constexpr OpenGLCompressedRgbBptcUnsignedFloat = 0x8e8f;
auto constexpr OpenGLCompressedSRGB = 0x8c48;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x10 = 0x93db;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x5 = 0x93d8;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x6 = 0x93d9;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x8 = 0x93da;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc12x10 = 0x93dc;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc12x12 = 0x93dd;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc4x4 = 0x93d0;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc5x4 = 0x93d1;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc5x5 = 0x93d2;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc6x5 = 0x93d3;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc6x6 = 0x93d4;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc8x5 = 0x93d5;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc8x6 = 0x93d6;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc8x8 = 0x93d7;
auto constexpr OpenGLCompressedSRGB8Alpha8Etc2Eac = 0x9279;
auto constexpr OpenGLCompressedSRGB8Etc2 = 0x9275;
auto constexpr OpenGLCompressedSRGB8PunchthroughAlpha1Etc2 = 0x9277;
auto constexpr OpenGLCompressedSRGBAlpha = 0x8c49;
auto constexpr OpenGLCompressedSRGBAlphaBptcUnorm = 0x8e8d;
auto constexpr OpenGLCompressedSignedR11Eac = 0x9271;
auto constexpr OpenGLCompressedSignedRedRgtc1 = 0x8dbc;
auto constexpr OpenGLCompressedSignedRg11Eac = 0x9273;
auto constexpr OpenGLCompressedSignedRgRgtc2 = 0x8dbe;
auto constexpr OpenGLCompressedSluminance = 0x8c4a;
auto constexpr OpenGLCompressedSluminanceAlpha = 0x8c4b;
auto constexpr OpenGLCompressedTextureFormats = 0x86a3;
auto constexpr OpenGLComputeShader = 0x91b9;
auto constexpr OpenGLComputeShaderBit = 0x00000020;
auto constexpr OpenGLComputeShaderInvocations = 0x82f5;
auto constexpr OpenGLComputeSubroutine = 0x92ed;
auto constexpr OpenGLComputeSubroutineUniform = 0x92f3;
auto constexpr OpenGLComputeTexture = 0x82a0;
auto constexpr OpenGLComputeWorkGroupSize = 0x8267;
auto constexpr OpenGLConditionSatisfied = 0x911c;
auto constexpr OpenGLConstant = 0x8576;
auto constexpr OpenGLConstantAlpha = 0x8003;
auto constexpr OpenGLConstantAttenuation = 0x1207;
auto constexpr OpenGLConstantColor = 0x8001;
auto constexpr OpenGLContextCompatibilityProfileBit = 0x00000002;
auto constexpr OpenGLContextCoreProfileBit = 0x00000001;
auto constexpr OpenGLContextFlagDebugBit = 0x00000002;
auto constexpr OpenGLContextFlagForwardCompatibleBit = 0x00000001;
auto constexpr OpenGLContextFlagNoErrorBit = 0x00000008;
auto constexpr OpenGLContextFlagRobustAccessBit = 0x00000004;
auto constexpr OpenGLContextFlags = 0x821e;
auto constexpr OpenGLContextLost = 0x0507;
auto constexpr OpenGLContextProfileMask = 0x9126;
auto constexpr OpenGLContextReleaseBehavior = 0x82fb;
auto constexpr OpenGLContextReleaseBehaviorFlush = 0x82fc;
auto constexpr OpenGLContextRobustAccess = 0x90f3;
auto constexpr OpenGLConvolution1d = 0x8010;
auto constexpr OpenGLConvolution2d = 0x8011;
auto constexpr OpenGLCoordReplace = 0x8862;
auto constexpr OpenGLCopy = 0x1503;
auto constexpr OpenGLCopyInverted = 0x150c;
auto constexpr OpenGLCopyPixelToken = 0x0706;
auto constexpr OpenGLCopyReadBuffer = 0x8f36;
auto constexpr OpenGLCopyReadBufferBinding = 0x8f36;
auto constexpr OpenGLCopyWriteBuffer = 0x8f37;
auto constexpr OpenGLCopyWriteBufferBinding = 0x8f37;
auto constexpr OpenGLCullFace = 0x0b44;
auto constexpr OpenGLCullFaceMode = 0x0b45;
auto constexpr OpenGLCurrentBit = 0x00000001;
auto constexpr OpenGLCurrentColor = 0x0b00;
auto constexpr OpenGLCurrentFogCoord = 0x8453;
auto constexpr OpenGLCurrentFogCoordinate = 0x8453;
auto constexpr OpenGLCurrentIndex = 0x0b01;
auto constexpr OpenGLCurrentNormal = 0x0b02;
auto constexpr OpenGLCurrentProgram = 0x8b8d;
auto constexpr OpenGLCurrentQuery = 0x8865;
auto constexpr OpenGLCurrentRasterColor = 0x0b04;
auto constexpr OpenGLCurrentRasterDistance = 0x0b09;
auto constexpr OpenGLCurrentRasterIndex = 0x0b05;
auto constexpr OpenGLCurrentRasterPosition = 0x0b07;
auto constexpr OpenGLCurrentRasterPositionValid = 0x0b08;
auto constexpr OpenGLCurrentRasterSecondaryColor = 0x845f;
auto constexpr OpenGLCurrentRasterTextureCoords = 0x0b06;
auto constexpr OpenGLCurrentSecondaryColor = 0x8459;
auto constexpr OpenGLCurrentTextureCoords = 0x0b03;
auto constexpr OpenGLCurrentVertexAttrib = 0x8626;
auto constexpr OpenGLCw = 0x0900;
auto constexpr OpenGLDarken = 0x9297;
auto constexpr OpenGLDebugCallbackFunction = 0x8244;
auto constexpr OpenGLDebugCallbackUserParam = 0x8245;
auto constexpr OpenGLDebugGroupStackDepth = 0x826d;
auto constexpr OpenGLDebugLoggedMessages = 0x9145;
auto constexpr OpenGLDebugNextLoggedMessageLength = 0x8243;
auto constexpr OpenGLDebugOutput = 0x92e0;
auto constexpr OpenGLDebugOutputSynchronous = 0x8242;
auto constexpr OpenGLDebugSeverityHigh = 0x9146;
auto constexpr OpenGLDebugSeverityLow = 0x9148;
auto constexpr OpenGLDebugSeverityMedium = 0x9147;
auto constexpr OpenGLDebugSeverityNotification = 0x826b;
auto constexpr OpenGLDebugSourceApi = 0x8246;
auto constexpr OpenGLDebugSourceApplication = 0x824a;
auto constexpr OpenGLDebugSourceOther = 0x824b;
auto constexpr OpenGLDebugSourceShaderCompiler = 0x8248;
auto constexpr OpenGLDebugSourceThirdParty = 0x8249;
auto constexpr OpenGLDebugSourceWindowSystem = 0x8247;
auto constexpr OpenGLDebugTypeDeprecatedBehavior = 0x824d;
auto constexpr OpenGLDebugTypeError = 0x824c;
auto constexpr OpenGLDebugTypeMarker = 0x8268;
auto constexpr OpenGLDebugTypeOther = 0x8251;
auto constexpr OpenGLDebugTypePerformance = 0x8250;
auto constexpr OpenGLDebugTypePopGroup = 0x826a;
auto constexpr OpenGLDebugTypePortability = 0x824f;
auto constexpr OpenGLDebugTypePushGroup = 0x8269;
auto constexpr OpenGLDebugTypeUndefinedBehavior = 0x824e;
auto constexpr OpenGLDecal = 0x2101;
auto constexpr OpenGLDecr = 0x1e03;
auto constexpr OpenGLDecrWrap = 0x8508;
auto constexpr OpenGLDeleteStatus = 0x8b80;
auto constexpr OpenGLDepth = 0x1801;
auto constexpr OpenGLDepth24Stencil8 = 0x88f0;
auto constexpr OpenGLDepth32fStencil8 = 0x8cad;
auto constexpr OpenGLDepthAttachment = 0x8d00;
auto constexpr OpenGLDepthBias = 0x0d1f;
auto constexpr OpenGLDepthBits = 0x0d56;
auto constexpr OpenGLDepthBufferBit = 0x00000100;
auto constexpr OpenGLDepthClamp = 0x864f;
auto constexpr OpenGLDepthClearValue = 0x0b73;
auto constexpr OpenGLDepthComponent = 0x1902;
auto constexpr OpenGLDepthComponent16 = 0x81a5;
auto constexpr OpenGLDepthComponent24 = 0x81a6;
auto constexpr OpenGLDepthComponent32 = 0x81a7;
auto constexpr OpenGLDepthComponent32f = 0x8cac;
auto constexpr OpenGLDepthComponents = 0x8284;
auto constexpr OpenGLDepthFunc = 0x0b74;
auto constexpr OpenGLDepthRange = 0x0b70;
auto constexpr OpenGLDepthRenderable = 0x8287;
auto constexpr OpenGLDepthScale = 0x0d1e;
auto constexpr OpenGLDepthStencil = 0x84f9;
auto constexpr OpenGLDepthStencilAttachment = 0x821a;
auto constexpr OpenGLDepthStencilTextureMode = 0x90ea;
auto constexpr OpenGLDepthTest = 0x0b71;
auto constexpr OpenGLDepthTextureMode = 0x884b;
auto constexpr OpenGLDepthWriteMask = 0x0b72;
auto constexpr OpenGLDifference = 0x929e;
auto constexpr OpenGLDiffuse = 0x1201;
auto constexpr OpenGLDispatchIndirectBuffer = 0x90ee;
auto constexpr OpenGLDispatchIndirectBufferBinding = 0x90ef;
auto constexpr OpenGLDisplayList = 0x82e7;
auto constexpr OpenGLDither = 0x0bd0;
auto constexpr OpenGLDomain = 0x0a02;
auto constexpr OpenGLDontCare = 0x1100;
auto constexpr OpenGLDot3RGBA = 0x86af;
auto constexpr OpenGLDot3Rgb = 0x86ae;
auto constexpr OpenGLDouble = 0x140a;
auto constexpr OpenGLDoubleMat2 = 0x8f46;
auto constexpr OpenGLDoubleMat2x3 = 0x8f49;
auto constexpr OpenGLDoubleMat2x4 = 0x8f4a;
auto constexpr OpenGLDoubleMat3 = 0x8f47;
auto constexpr OpenGLDoubleMat3x2 = 0x8f4b;
auto constexpr OpenGLDoubleMat3x4 = 0x8f4c;
auto constexpr OpenGLDoubleMat4 = 0x8f48;
auto constexpr OpenGLDoubleMat4x2 = 0x8f4d;
auto constexpr OpenGLDoubleMat4x3 = 0x8f4e;
auto constexpr OpenGLDoubleVec2 = 0x8ffc;
auto constexpr OpenGLDoubleVec3 = 0x8ffd;
auto constexpr OpenGLDoubleVec4 = 0x8ffe;
auto constexpr OpenGLDoublebuffer = 0x0c32;
auto constexpr OpenGLDrawBuffer = 0x0c01;
auto constexpr OpenGLDrawBuffer0 = 0x8825;
auto constexpr OpenGLDrawBuffer1 = 0x8826;
auto constexpr OpenGLDrawBuffer10 = 0x882f;
auto constexpr OpenGLDrawBuffer11 = 0x8830;
auto constexpr OpenGLDrawBuffer12 = 0x8831;
auto constexpr OpenGLDrawBuffer13 = 0x8832;
auto constexpr OpenGLDrawBuffer14 = 0x8833;
auto constexpr OpenGLDrawBuffer15 = 0x8834;
auto constexpr OpenGLDrawBuffer2 = 0x8827;
auto constexpr OpenGLDrawBuffer3 = 0x8828;
auto constexpr OpenGLDrawBuffer4 = 0x8829;
auto constexpr OpenGLDrawBuffer5 = 0x882a;
auto constexpr OpenGLDrawBuffer6 = 0x882b;
auto constexpr OpenGLDrawBuffer7 = 0x882c;
auto constexpr OpenGLDrawBuffer8 = 0x882d;
auto constexpr OpenGLDrawBuffer9 = 0x882e;
auto constexpr OpenGLDrawFramebuffer = 0x8ca9;
auto constexpr OpenGLDrawFramebufferBinding = 0x8ca6;
auto constexpr OpenGLDrawIndirectBuffer = 0x8f3f;
auto constexpr OpenGLDrawIndirectBufferBinding = 0x8f43;
auto constexpr OpenGLDrawPixelToken = 0x0705;
auto constexpr OpenGLDstAlpha = 0x0304;
auto constexpr OpenGLDstColor = 0x0306;
auto constexpr OpenGLDynamicCopy = 0x88ea;
auto constexpr OpenGLDynamicDraw = 0x88e8;
auto constexpr OpenGLDynamicRead = 0x88e9;
auto constexpr OpenGLDynamicStorageBit = 0x0100;
auto constexpr OpenGLEdgeFlag = 0x0b43;
auto constexpr OpenGLEdgeFlagArray = 0x8079;
auto constexpr OpenGLEdgeFlagArrayBufferBinding = 0x889b;
auto constexpr OpenGLEdgeFlagArrayPointer = 0x8093;
auto constexpr OpenGLEdgeFlagArrayStride = 0x808c;
auto constexpr OpenGLElementArrayBarrierBit = 0x00000002;
auto constexpr OpenGLElementArrayBuffer = 0x8893;
auto constexpr OpenGLElementArrayBufferBinding = 0x8895;
auto constexpr OpenGLEmission = 0x1600;
auto constexpr OpenGLEnableBit = 0x00002000;
auto constexpr OpenGLEqual = 0x0202;
auto constexpr OpenGLEquiv = 0x1509;
auto constexpr OpenGLEvalBit = 0x00010000;
auto constexpr OpenGLExclusion = 0x92a0;
auto constexpr OpenGLExp = 0x0800;
auto constexpr OpenGLExp2 = 0x0801;
auto constexpr OpenGLExtensions = 0x1f03;
auto constexpr OpenGLEyeLinear = 0x2400;
auto constexpr OpenGLEyePlane = 0x2502;
auto constexpr OpenGLFastest = 0x1101;
auto constexpr OpenGLFeedback = 0x1c01;
auto constexpr OpenGLFeedbackBufferPointer = 0x0df0;
auto constexpr OpenGLFeedbackBufferSize = 0x0df1;
auto constexpr OpenGLFeedbackBufferType = 0x0df2;
auto constexpr OpenGLFill = 0x1b02;
auto constexpr OpenGLFilter = 0x829a;
auto constexpr OpenGLFirstVertexConvention = 0x8e4d;
auto constexpr OpenGLFixed = 0x140c;
auto constexpr OpenGLFixedOnly = 0x891d;
auto constexpr OpenGLFlat = 0x1d00;
auto constexpr OpenGLFloat = 0x1406;
auto constexpr OpenGLFloat32UnsignedInt248Rev = 0x8dad;
auto constexpr OpenGLFloatMat2 = 0x8b5a;
auto constexpr OpenGLFloatMat2x3 = 0x8b65;
auto constexpr OpenGLFloatMat2x4 = 0x8b66;
auto constexpr OpenGLFloatMat3 = 0x8b5b;
auto constexpr OpenGLFloatMat3x2 = 0x8b67;
auto constexpr OpenGLFloatMat3x4 = 0x8b68;
auto constexpr OpenGLFloatMat4 = 0x8b5c;
auto constexpr OpenGLFloatMat4x2 = 0x8b69;
auto constexpr OpenGLFloatMat4x3 = 0x8b6a;
auto constexpr OpenGLFloatVec2 = 0x8b50;
auto constexpr OpenGLFloatVec3 = 0x8b51;
auto constexpr OpenGLFloatVec4 = 0x8b52;
auto constexpr OpenGLFog = 0x0b60;
auto constexpr OpenGLFogBit = 0x00000080;
auto constexpr OpenGLFogColor = 0x0b66;
auto constexpr OpenGLFogCoord = 0x8451;
auto constexpr OpenGLFogCoordArray = 0x8457;
auto constexpr OpenGLFogCoordArrayBufferBinding = 0x889d;
auto constexpr OpenGLFogCoordArrayPointer = 0x8456;
auto constexpr OpenGLFogCoordArrayStride = 0x8455;
auto constexpr OpenGLFogCoordArrayType = 0x8454;
auto constexpr OpenGLFogCoordSrc = 0x8450;
auto constexpr OpenGLFogCoordinate = 0x8451;
auto constexpr OpenGLFogCoordinateArray = 0x8457;
auto constexpr OpenGLFogCoordinateArrayBufferBinding = 0x889d;
auto constexpr OpenGLFogCoordinateArrayPointer = 0x8456;
auto constexpr OpenGLFogCoordinateArrayStride = 0x8455;
auto constexpr OpenGLFogCoordinateArrayType = 0x8454;
auto constexpr OpenGLFogCoordinateSource = 0x8450;
auto constexpr OpenGLFogDensity = 0x0b62;
auto constexpr OpenGLFogEnd = 0x0b64;
auto constexpr OpenGLFogHint = 0x0c54;
auto constexpr OpenGLFogIndex = 0x0b61;
auto constexpr OpenGLFogMode = 0x0b65;
auto constexpr OpenGLFogStart = 0x0b63;
auto constexpr OpenGLFractionalEven = 0x8e7c;
auto constexpr OpenGLFractionalOdd = 0x8e7b;
auto constexpr OpenGLFragmentDepth = 0x8452;
auto constexpr OpenGLFragmentInterpolationOffsetBits = 0x8e5d;
auto constexpr OpenGLFragmentShader = 0x8b30;
auto constexpr OpenGLFragmentShaderBit = 0x00000002;
auto constexpr OpenGLFragmentShaderDerivativeHint = 0x8b8b;
auto constexpr OpenGLFragmentShaderInvocations = 0x82f4;
auto constexpr OpenGLFragmentSubroutine = 0x92ec;
auto constexpr OpenGLFragmentSubroutineUniform = 0x92f2;
auto constexpr OpenGLFragmentTexture = 0x829f;
auto constexpr OpenGLFramebuffer = 0x8d40;
auto constexpr OpenGLFramebufferAttachmentAlphaSize = 0x8215;
auto constexpr OpenGLFramebufferAttachmentBlueSize = 0x8214;
auto constexpr OpenGLFramebufferAttachmentColorEncoding = 0x8210;
auto constexpr OpenGLFramebufferAttachmentComponentType = 0x8211;
auto constexpr OpenGLFramebufferAttachmentDepthSize = 0x8216;
auto constexpr OpenGLFramebufferAttachmentGreenSize = 0x8213;
auto constexpr OpenGLFramebufferAttachmentLayered = 0x8da7;
auto constexpr OpenGLFramebufferAttachmentObjectName = 0x8cd1;
auto constexpr OpenGLFramebufferAttachmentObjectType = 0x8cd0;
auto constexpr OpenGLFramebufferAttachmentRedSize = 0x8212;
auto constexpr OpenGLFramebufferAttachmentStencilSize = 0x8217;
auto constexpr OpenGLFramebufferAttachmentTextureCubeMapFace = 0x8cd3;
auto constexpr OpenGLFramebufferAttachmentTextureLayer = 0x8cd4;
auto constexpr OpenGLFramebufferAttachmentTextureLevel = 0x8cd2;
auto constexpr OpenGLFramebufferBarrierBit = 0x00000400;
auto constexpr OpenGLFramebufferBinding = 0x8ca6;
auto constexpr OpenGLFramebufferBlend = 0x828b;
auto constexpr OpenGLFramebufferComplete = 0x8cd5;
auto constexpr OpenGLFramebufferDefault = 0x8218;
auto constexpr OpenGLFramebufferDefaultFixedSampleLocations = 0x9314;
auto constexpr OpenGLFramebufferDefaultHeight = 0x9311;
auto constexpr OpenGLFramebufferDefaultLayers = 0x9312;
auto constexpr OpenGLFramebufferDefaultSamples = 0x9313;
auto constexpr OpenGLFramebufferDefaultWidth = 0x9310;
auto constexpr OpenGLFramebufferIncompleteAttachment = 0x8cd6;
auto constexpr OpenGLFramebufferIncompleteDimensions = 0x8cd9;
auto constexpr OpenGLFramebufferIncompleteDrawBuffer = 0x8cdb;
auto constexpr OpenGLFramebufferIncompleteLayerTargets = 0x8da8;
auto constexpr OpenGLFramebufferIncompleteMissingAttachment = 0x8cd7;
auto constexpr OpenGLFramebufferIncompleteMultisample = 0x8d56;
auto constexpr OpenGLFramebufferIncompleteReadBuffer = 0x8cdc;
auto constexpr OpenGLFramebufferRenderable = 0x8289;
auto constexpr OpenGLFramebufferRenderableLayered = 0x828a;
auto constexpr OpenGLFramebufferSRGB = 0x8db9;
auto constexpr OpenGLFramebufferUndefined = 0x8219;
auto constexpr OpenGLFramebufferUnsupported = 0x8cdd;
auto constexpr OpenGLFront = 0x0404;
auto constexpr OpenGLFrontAndBack = 0x0408;
auto constexpr OpenGLFrontFace = 0x0b46;
auto constexpr OpenGLFrontLeft = 0x0400;
auto constexpr OpenGLFrontRight = 0x0401;
auto constexpr OpenGLFullSupport = 0x82b7;
auto constexpr OpenGLFuncAdd = 0x8006;
auto constexpr OpenGLFuncReverseSubtract = 0x800b;
auto constexpr OpenGLFuncSubtract = 0x800a;
auto constexpr OpenGLGenerateMipmap = 0x8191;
auto constexpr OpenGLGenerateMipmapHint = 0x8192;
auto constexpr OpenGLGeometryInputType = 0x8917;
auto constexpr OpenGLGeometryOutputType = 0x8918;
auto constexpr OpenGLGeometryShader = 0x8dd9;
auto constexpr OpenGLGeometryShaderBit = 0x00000004;
auto constexpr OpenGLGeometryShaderInvocations = 0x887f;
auto constexpr OpenGLGeometryShaderPrimitivesEmitted = 0x82f3;
auto constexpr OpenGLGeometrySubroutine = 0x92eb;
auto constexpr OpenGLGeometrySubroutineUniform = 0x92f1;
auto constexpr OpenGLGeometryTexture = 0x829e;
auto constexpr OpenGLGeometryVerticesOut = 0x8916;
auto constexpr OpenGLGequal = 0x0206;
auto constexpr OpenGLGetTextureImageFormat = 0x8291;
auto constexpr OpenGLGetTextureImageType = 0x8292;
auto constexpr OpenGLGreater = 0x0204;
auto constexpr OpenGLGreen = 0x1904;
auto constexpr OpenGLGreenBias = 0x0d19;
auto constexpr OpenGLGreenBits = 0x0d53;
auto constexpr OpenGLGreenInteger = 0x8d95;
auto constexpr OpenGLGreenScale = 0x0d18;
auto constexpr OpenGLGuiltyContextReset = 0x8253;
auto constexpr OpenGLHalfFloat = 0x140b;
auto constexpr OpenGLHardlight = 0x929b;
auto constexpr OpenGLHighFloat = 0x8df2;
auto constexpr OpenGLHighInt = 0x8df5;
auto constexpr OpenGLHintBit = 0x00008000;
auto constexpr OpenGLHistogram = 0x8024;
auto constexpr OpenGLHslColor = 0x92af;
auto constexpr OpenGLHslHue = 0x92ad;
auto constexpr OpenGLHslLuminosity = 0x92b0;
auto constexpr OpenGLHslSaturation = 0x92ae;
auto constexpr OpenGLImage1d = 0x904c;
auto constexpr OpenGLImage1dArray = 0x9052;
auto constexpr OpenGLImage2d = 0x904d;
auto constexpr OpenGLImage2dArray = 0x9053;
auto constexpr OpenGLImage2dMultisample = 0x9055;
auto constexpr OpenGLImage2dMultisampleArray = 0x9056;
auto constexpr OpenGLImage2dRect = 0x904f;
auto constexpr OpenGLImage3d = 0x904e;
auto constexpr OpenGLImageBindingAccess = 0x8f3e;
auto constexpr OpenGLImageBindingFormat = 0x906e;
auto constexpr OpenGLImageBindingLayer = 0x8f3d;
auto constexpr OpenGLImageBindingLayered = 0x8f3c;
auto constexpr OpenGLImageBindingLevel = 0x8f3b;
auto constexpr OpenGLImageBindingName = 0x8f3a;
auto constexpr OpenGLImageBuffer = 0x9051;
auto constexpr OpenGLImageClass1010102 = 0x82c3;
auto constexpr OpenGLImageClass111110 = 0x82c2;
auto constexpr OpenGLImageClass1X16 = 0x82be;
auto constexpr OpenGLImageClass1X32 = 0x82bb;
auto constexpr OpenGLImageClass1X8 = 0x82c1;
auto constexpr OpenGLImageClass2X16 = 0x82bd;
auto constexpr OpenGLImageClass2X32 = 0x82ba;
auto constexpr OpenGLImageClass2X8 = 0x82c0;
auto constexpr OpenGLImageClass4X16 = 0x82bc;
auto constexpr OpenGLImageClass4X32 = 0x82b9;
auto constexpr OpenGLImageClass4X8 = 0x82bf;
auto constexpr OpenGLImageCompatibilityClass = 0x82a8;
auto constexpr OpenGLImageCube = 0x9050;
auto constexpr OpenGLImageCubeMapArray = 0x9054;
auto constexpr OpenGLImageFormatCompatibilityByClass = 0x90c9;
auto constexpr OpenGLImageFormatCompatibilityBySize = 0x90c8;
auto constexpr OpenGLImageFormatCompatibilityType = 0x90c7;
auto constexpr OpenGLImagePixelFormat = 0x82a9;
auto constexpr OpenGLImagePixelType = 0x82aa;
auto constexpr OpenGLImageTexelSize = 0x82a7;
auto constexpr OpenGLImplementationColorReadFormat = 0x8b9b;
auto constexpr OpenGLImplementationColorReadType = 0x8b9a;
auto constexpr OpenGLIncr = 0x1e02;
auto constexpr OpenGLIncrWrap = 0x8507;
auto constexpr OpenGLIndex = 0x8222;
auto constexpr OpenGLIndexArray = 0x8077;
auto constexpr OpenGLIndexArrayBufferBinding = 0x8899;
auto constexpr OpenGLIndexArrayPointer = 0x8091;
auto constexpr OpenGLIndexArrayStride = 0x8086;
auto constexpr OpenGLIndexArrayType = 0x8085;
auto constexpr OpenGLIndexBits = 0x0d51;
auto constexpr OpenGLIndexClearValue = 0x0c20;
auto constexpr OpenGLIndexLogicOp = 0x0bf1;
auto constexpr OpenGLIndexMode = 0x0c30;
auto constexpr OpenGLIndexOffset = 0x0d13;
auto constexpr OpenGLIndexShift = 0x0d12;
auto constexpr OpenGLIndexWriteMask = 0x0c21;
auto constexpr OpenGLInfoLogLength = 0x8b84;
auto constexpr OpenGLInnocentContextReset = 0x8254;
auto constexpr OpenGLInt = 0x1404;
auto constexpr OpenGLInt2101010Rev = 0x8d9f;
auto constexpr OpenGLIntImage1d = 0x9057;
auto constexpr OpenGLIntImage1dArray = 0x905d;
auto constexpr OpenGLIntImage2d = 0x9058;
auto constexpr OpenGLIntImage2dArray = 0x905e;
auto constexpr OpenGLIntImage2dMultisample = 0x9060;
auto constexpr OpenGLIntImage2dMultisampleArray = 0x9061;
auto constexpr OpenGLIntImage2dRect = 0x905a;
auto constexpr OpenGLIntImage3d = 0x9059;
auto constexpr OpenGLIntImageBuffer = 0x905c;
auto constexpr OpenGLIntImageCube = 0x905b;
auto constexpr OpenGLIntImageCubeMapArray = 0x905f;
auto constexpr OpenGLIntSampler1d = 0x8dc9;
auto constexpr OpenGLIntSampler1dArray = 0x8dce;
auto constexpr OpenGLIntSampler2d = 0x8dca;
auto constexpr OpenGLIntSampler2dArray = 0x8dcf;
auto constexpr OpenGLIntSampler2dMultisample = 0x9109;
auto constexpr OpenGLIntSampler2dMultisampleArray = 0x910c;
auto constexpr OpenGLIntSampler2dRect = 0x8dcd;
auto constexpr OpenGLIntSampler3d = 0x8dcb;
auto constexpr OpenGLIntSamplerBuffer = 0x8dd0;
auto constexpr OpenGLIntSamplerCube = 0x8dcc;
auto constexpr OpenGLIntSamplerCubeMapArray = 0x900e;
auto constexpr OpenGLIntVec2 = 0x8b53;
auto constexpr OpenGLIntVec3 = 0x8b54;
auto constexpr OpenGLIntVec4 = 0x8b55;
auto constexpr OpenGLIntensity = 0x8049;
auto constexpr OpenGLIntensity12 = 0x804c;
auto constexpr OpenGLIntensity16 = 0x804d;
auto constexpr OpenGLIntensity4 = 0x804a;
auto constexpr OpenGLIntensity8 = 0x804b;
auto constexpr OpenGLInterleavedAttribs = 0x8c8c;
auto constexpr OpenGLInternalformatAlphaSize = 0x8274;
auto constexpr OpenGLInternalformatAlphaType = 0x827b;
auto constexpr OpenGLInternalformatBlueSize = 0x8273;
auto constexpr OpenGLInternalformatBlueType = 0x827a;
auto constexpr OpenGLInternalformatDepthSize = 0x8275;
auto constexpr OpenGLInternalformatDepthType = 0x827c;
auto constexpr OpenGLInternalformatGreenSize = 0x8272;
auto constexpr OpenGLInternalformatGreenType = 0x8279;
auto constexpr OpenGLInternalformatPreferred = 0x8270;
auto constexpr OpenGLInternalformatRedSize = 0x8271;
auto constexpr OpenGLInternalformatRedType = 0x8278;
auto constexpr OpenGLInternalformatSharedSize = 0x8277;
auto constexpr OpenGLInternalformatStencilSize = 0x8276;
auto constexpr OpenGLInternalformatStencilType = 0x827d;
auto constexpr OpenGLInternalformatSupported = 0x826f;
auto constexpr OpenGLInterpolate = 0x8575;
auto constexpr OpenGLInvalidEnum = 0x0500;
auto constexpr OpenGLInvalidFramebufferOperation = 0x0506;
auto constexpr OpenGLInvalidIndex = 0xffffffff;
auto constexpr OpenGLInvalidOperation = 0x0502;
auto constexpr OpenGLInvalidValue = 0x0501;
auto constexpr OpenGLInvert = 0x150a;
auto constexpr OpenGLIsPerPatch = 0x92e7;
auto constexpr OpenGLIsRowMajor = 0x9300;
auto constexpr OpenGLIsolines = 0x8e7a;
auto constexpr OpenGLKeep = 0x1e00;
auto constexpr OpenGLLastVertexConvention = 0x8e4e;
auto constexpr OpenGLLayerProvokingVertex = 0x825e;
auto constexpr OpenGLLeft = 0x0406;
auto constexpr OpenGLLequal = 0x0203;
auto constexpr OpenGLLess = 0x0201;
auto constexpr OpenGLLight0 = 0x4000;
auto constexpr OpenGLLight1 = 0x4001;
auto constexpr OpenGLLight2 = 0x4002;
auto constexpr OpenGLLight3 = 0x4003;
auto constexpr OpenGLLight4 = 0x4004;
auto constexpr OpenGLLight5 = 0x4005;
auto constexpr OpenGLLight6 = 0x4006;
auto constexpr OpenGLLight7 = 0x4007;
auto constexpr OpenGLLightModelAmbient = 0x0b53;
auto constexpr OpenGLLightModelColorControl = 0x81f8;
auto constexpr OpenGLLightModelLocalViewer = 0x0b51;
auto constexpr OpenGLLightModelTwoSide = 0x0b52;
auto constexpr OpenGLLighten = 0x9298;
auto constexpr OpenGLLighting = 0x0b50;
auto constexpr OpenGLLightingBit = 0x00000040;
auto constexpr OpenGLLine = 0x1b01;
auto constexpr OpenGLLineBit = 0x00000004;
auto constexpr OpenGLLineLoop = 0x0002;
auto constexpr OpenGLLineResetToken = 0x0707;
auto constexpr OpenGLLineSmooth = 0x0b20;
auto constexpr OpenGLLineSmoothHint = 0x0c52;
auto constexpr OpenGLLineStipple = 0x0b24;
auto constexpr OpenGLLineStipplePattern = 0x0b25;
auto constexpr OpenGLLineStippleRepeat = 0x0b26;
auto constexpr OpenGLLineStrip = 0x0003;
auto constexpr OpenGLLineStripAdjacency = 0x000b;
auto constexpr OpenGLLineToken = 0x0702;
auto constexpr OpenGLLineWidth = 0x0b21;
auto constexpr OpenGLLineWidthGranularity = 0x0b23;
auto constexpr OpenGLLineWidthRange = 0x0b22;
auto constexpr OpenGLLinear = 0x2601;
auto constexpr OpenGLLinearAttenuation = 0x1208;
auto constexpr OpenGLLinearMipmapLinear = 0x2703;
auto constexpr OpenGLLinearMipmapNearest = 0x2701;
auto constexpr OpenGLLines = 0x0001;
auto constexpr OpenGLLinesAdjacency = 0x000a;
auto constexpr OpenGLLinkStatus = 0x8b82;
auto constexpr OpenGLListBase = 0x0b32;
auto constexpr OpenGLListBit = 0x00020000;
auto constexpr OpenGLListIndex = 0x0b33;
auto constexpr OpenGLListMode = 0x0b30;
auto constexpr OpenGLLoad = 0x0101;
auto constexpr OpenGLLocation = 0x930e;
auto constexpr OpenGLLocationComponent = 0x934a;
auto constexpr OpenGLLocationIndex = 0x930f;
auto constexpr OpenGLLogicOp = 0x0bf1;
auto constexpr OpenGLLogicOpMode = 0x0bf0;
auto constexpr OpenGLLoseContextOnReset = 0x8252;
auto constexpr OpenGLLowFloat = 0x8df0;
auto constexpr OpenGLLowInt = 0x8df3;
auto constexpr OpenGLLowerLeft = 0x8ca1;
auto constexpr OpenGLLuminance = 0x1909;
auto constexpr OpenGLLuminance12 = 0x8041;
auto constexpr OpenGLLuminance12Alpha12 = 0x8047;
auto constexpr OpenGLLuminance12Alpha4 = 0x8046;
auto constexpr OpenGLLuminance16 = 0x8042;
auto constexpr OpenGLLuminance16Alpha16 = 0x8048;
auto constexpr OpenGLLuminance4 = 0x803f;
auto constexpr OpenGLLuminance4Alpha4 = 0x8043;
auto constexpr OpenGLLuminance6Alpha2 = 0x8044;
auto constexpr OpenGLLuminance8 = 0x8040;
auto constexpr OpenGLLuminance8Alpha8 = 0x8045;
auto constexpr OpenGLLuminanceAlpha = 0x190a;
auto constexpr OpenGLMajorVersion = 0x821b;
auto constexpr OpenGLManualGenerateMipmap = 0x8294;
auto constexpr OpenGLMap1Color4 = 0x0d90;
auto constexpr OpenGLMap1GridDomain = 0x0dd0;
auto constexpr OpenGLMap1GridSegments = 0x0dd1;
auto constexpr OpenGLMap1Index = 0x0d91;
auto constexpr OpenGLMap1Normal = 0x0d92;
auto constexpr OpenGLMap1TextureCoord1 = 0x0d93;
auto constexpr OpenGLMap1TextureCoord2 = 0x0d94;
auto constexpr OpenGLMap1TextureCoord3 = 0x0d95;
auto constexpr OpenGLMap1TextureCoord4 = 0x0d96;
auto constexpr OpenGLMap1Vertex3 = 0x0d97;
auto constexpr OpenGLMap1Vertex4 = 0x0d98;
auto constexpr OpenGLMap2Color4 = 0x0db0;
auto constexpr OpenGLMap2GridDomain = 0x0dd2;
auto constexpr OpenGLMap2GridSegments = 0x0dd3;
auto constexpr OpenGLMap2Index = 0x0db1;
auto constexpr OpenGLMap2Normal = 0x0db2;
auto constexpr OpenGLMap2TextureCoord1 = 0x0db3;
auto constexpr OpenGLMap2TextureCoord2 = 0x0db4;
auto constexpr OpenGLMap2TextureCoord3 = 0x0db5;
auto constexpr OpenGLMap2TextureCoord4 = 0x0db6;
auto constexpr OpenGLMap2Vertex3 = 0x0db7;
auto constexpr OpenGLMap2Vertex4 = 0x0db8;
auto constexpr OpenGLMapCoherentBit = 0x0080;
auto constexpr OpenGLMapColor = 0x0d10;
auto constexpr OpenGLMapFlushExplicitBit = 0x0010;
auto constexpr OpenGLMapInvalidateBufferBit = 0x0008;
auto constexpr OpenGLMapInvalidateRangeBit = 0x0004;
auto constexpr OpenGLMapPersistentBit = 0x0040;
auto constexpr OpenGLMapReadBit = 0x0001;
auto constexpr OpenGLMapStencil = 0x0d11;
auto constexpr OpenGLMapUnsynchronizedBit = 0x0020;
auto constexpr OpenGLMapWriteBit = 0x0002;
auto constexpr OpenGLMatrixMode = 0x0ba0;
auto constexpr OpenGLMatrixStride = 0x92ff;
auto constexpr OpenGLMax = 0x8008;
auto constexpr OpenGLMax3dTextureSize = 0x8073;
auto constexpr OpenGLMaxArrayTextureLayers = 0x88ff;
auto constexpr OpenGLMaxAtomicCounterBufferBindings = 0x92dc;
auto constexpr OpenGLMaxAtomicCounterBufferSize = 0x92d8;
auto constexpr OpenGLMaxAttribStackDepth = 0x0d35;
auto constexpr OpenGLMaxClientAttribStackDepth = 0x0d3b;
auto constexpr OpenGLMaxClipDistances = 0x0d32;
auto constexpr OpenGLMaxClipPlanes = 0x0d32;
auto constexpr OpenGLMaxColorAttachments = 0x8cdf;
auto constexpr OpenGLMaxColorTextureSamples = 0x910e;
auto constexpr OpenGLMaxCombinedAtomicCounterBuffers = 0x92d1;
auto constexpr OpenGLMaxCombinedAtomicCounters = 0x92d7;
auto constexpr OpenGLMaxCombinedClipAndCullDistances = 0x82fa;
auto constexpr OpenGLMaxCombinedComputeUniformComponents = 0x8266;
auto constexpr OpenGLMaxCombinedDimensions = 0x8282;
auto constexpr OpenGLMaxCombinedFragmentUniformComponents = 0x8a33;
auto constexpr OpenGLMaxCombinedGeometryUniformComponents = 0x8a32;
auto constexpr OpenGLMaxCombinedImageUniforms = 0x90cf;
auto constexpr OpenGLMaxCombinedImageUnitsAndFragmentOutputs = 0x8f39;
auto constexpr OpenGLMaxCombinedShaderOutputResources = 0x8f39;
auto constexpr OpenGLMaxCombinedShaderStorageBlocks = 0x90dc;
auto constexpr OpenGLMaxCombinedTessControlUniformComponents = 0x8e1e;
auto constexpr OpenGLMaxCombinedTessEvaluationUniformComponents = 0x8e1f;
auto constexpr OpenGLMaxCombinedTextureImageUnits = 0x8b4d;
auto constexpr OpenGLMaxCombinedUniformBlocks = 0x8a2e;
auto constexpr OpenGLMaxCombinedVertexUniformComponents = 0x8a31;
auto constexpr OpenGLMaxComputeAtomicCounterBuffers = 0x8264;
auto constexpr OpenGLMaxComputeAtomicCounters = 0x8265;
auto constexpr OpenGLMaxComputeImageUniforms = 0x91bd;
auto constexpr OpenGLMaxComputeShaderStorageBlocks = 0x90db;
auto constexpr OpenGLMaxComputeSharedMemorySize = 0x8262;
auto constexpr OpenGLMaxComputeTextureImageUnits = 0x91bc;
auto constexpr OpenGLMaxComputeUniformBlocks = 0x91bb;
auto constexpr OpenGLMaxComputeUniformComponents = 0x8263;
auto constexpr OpenGLMaxComputeWorkGroupCount = 0x91be;
auto constexpr OpenGLMaxComputeWorkGroupInvocations = 0x90eb;
auto constexpr OpenGLMaxComputeWorkGroupSize = 0x91bf;
auto constexpr OpenGLMaxCubeMapTextureSize = 0x851c;
auto constexpr OpenGLMaxCullDistances = 0x82f9;
auto constexpr OpenGLMaxDebugGroupStackDepth = 0x826c;
auto constexpr OpenGLMaxDebugLoggedMessages = 0x9144;
auto constexpr OpenGLMaxDebugMessageLength = 0x9143;
auto constexpr OpenGLMaxDepth = 0x8280;
auto constexpr OpenGLMaxDepthTextureSamples = 0x910f;
auto constexpr OpenGLMaxDrawBuffers = 0x8824;
auto constexpr OpenGLMaxDualSourceDrawBuffers = 0x88fc;
auto constexpr OpenGLMaxElementIndex = 0x8d6b;
auto constexpr OpenGLMaxElementsIndices = 0x80e9;
auto constexpr OpenGLMaxElementsVertices = 0x80e8;
auto constexpr OpenGLMaxEvalOrder = 0x0d30;
auto constexpr OpenGLMaxFragmentAtomicCounterBuffers = 0x92d0;
auto constexpr OpenGLMaxFragmentAtomicCounters = 0x92d6;
auto constexpr OpenGLMaxFragmentImageUniforms = 0x90ce;
auto constexpr OpenGLMaxFragmentInputComponents = 0x9125;
auto constexpr OpenGLMaxFragmentInterpolationOffset = 0x8e5c;
auto constexpr OpenGLMaxFragmentShaderStorageBlocks = 0x90da;
auto constexpr OpenGLMaxFragmentUniformBlocks = 0x8a2d;
auto constexpr OpenGLMaxFragmentUniformComponents = 0x8b49;
auto constexpr OpenGLMaxFragmentUniformVectors = 0x8dfd;
auto constexpr OpenGLMaxFramebufferHeight = 0x9316;
auto constexpr OpenGLMaxFramebufferLayers = 0x9317;
auto constexpr OpenGLMaxFramebufferSamples = 0x9318;
auto constexpr OpenGLMaxFramebufferWidth = 0x9315;
auto constexpr OpenGLMaxGeometryAtomicCounterBuffers = 0x92cf;
auto constexpr OpenGLMaxGeometryAtomicCounters = 0x92d5;
auto constexpr OpenGLMaxGeometryImageUniforms = 0x90cd;
auto constexpr OpenGLMaxGeometryInputComponents = 0x9123;
auto constexpr OpenGLMaxGeometryOutputComponents = 0x9124;
auto constexpr OpenGLMaxGeometryOutputVertices = 0x8de0;
auto constexpr OpenGLMaxGeometryShaderInvocations = 0x8e5a;
auto constexpr OpenGLMaxGeometryShaderStorageBlocks = 0x90d7;
auto constexpr OpenGLMaxGeometryTextureImageUnits = 0x8c29;
auto constexpr OpenGLMaxGeometryTotalOutputComponents = 0x8de1;
auto constexpr OpenGLMaxGeometryUniformBlocks = 0x8a2c;
auto constexpr OpenGLMaxGeometryUniformComponents = 0x8ddf;
auto constexpr OpenGLMaxHeight = 0x827f;
auto constexpr OpenGLMaxImageSamples = 0x906d;
auto constexpr OpenGLMaxImageUnits = 0x8f38;
auto constexpr OpenGLMaxIntegerSamples = 0x9110;
auto constexpr OpenGLMaxLabelLength = 0x82e8;
auto constexpr OpenGLMaxLayers = 0x8281;
auto constexpr OpenGLMaxLights = 0x0d31;
auto constexpr OpenGLMaxListNesting = 0x0b31;
auto constexpr OpenGLMaxModelviewStackDepth = 0x0d36;
auto constexpr OpenGLMaxNameLength = 0x92f6;
auto constexpr OpenGLMaxNameStackDepth = 0x0d37;
auto constexpr OpenGLMaxNumActiveVariables = 0x92f7;
auto constexpr OpenGLMaxNumCompatibleSubroutines = 0x92f8;
auto constexpr OpenGLMaxPatchVertices = 0x8e7d;
auto constexpr OpenGLMaxPixelMapTable = 0x0d34;
auto constexpr OpenGLMaxProgramTexelOffset = 0x8905;
auto constexpr OpenGLMaxProgramTextureGatherOffset = 0x8e5f;
auto constexpr OpenGLMaxProjectionStackDepth = 0x0d38;
auto constexpr OpenGLMaxRectangleTextureSize = 0x84f8;
auto constexpr OpenGLMaxRenderbufferSize = 0x84e8;
auto constexpr OpenGLMaxSampleMaskWords = 0x8e59;
auto constexpr OpenGLMaxSamples = 0x8d57;
auto constexpr OpenGLMaxServerWaitTimeout = 0x9111;
auto constexpr OpenGLMaxShaderStorageBlockSize = 0x90de;
auto constexpr OpenGLMaxShaderStorageBufferBindings = 0x90dd;
auto constexpr OpenGLMaxSubroutineUniformLocations = 0x8de8;
auto constexpr OpenGLMaxSubroutines = 0x8de7;
auto constexpr OpenGLMaxTessControlAtomicCounterBuffers = 0x92cd;
auto constexpr OpenGLMaxTessControlAtomicCounters = 0x92d3;
auto constexpr OpenGLMaxTessControlImageUniforms = 0x90cb;
auto constexpr OpenGLMaxTessControlInputComponents = 0x886c;
auto constexpr OpenGLMaxTessControlOutputComponents = 0x8e83;
auto constexpr OpenGLMaxTessControlShaderStorageBlocks = 0x90d8;
auto constexpr OpenGLMaxTessControlTextureImageUnits = 0x8e81;
auto constexpr OpenGLMaxTessControlTotalOutputComponents = 0x8e85;
auto constexpr OpenGLMaxTessControlUniformBlocks = 0x8e89;
auto constexpr OpenGLMaxTessControlUniformComponents = 0x8e7f;
auto constexpr OpenGLMaxTessEvaluationAtomicCounterBuffers = 0x92ce;
auto constexpr OpenGLMaxTessEvaluationAtomicCounters = 0x92d4;
auto constexpr OpenGLMaxTessEvaluationImageUniforms = 0x90cc;
auto constexpr OpenGLMaxTessEvaluationInputComponents = 0x886d;
auto constexpr OpenGLMaxTessEvaluationOutputComponents = 0x8e86;
auto constexpr OpenGLMaxTessEvaluationShaderStorageBlocks = 0x90d9;
auto constexpr OpenGLMaxTessEvaluationTextureImageUnits = 0x8e82;
auto constexpr OpenGLMaxTessEvaluationUniformBlocks = 0x8e8a;
auto constexpr OpenGLMaxTessEvaluationUniformComponents = 0x8e80;
auto constexpr OpenGLMaxTessGenLevel = 0x8e7e;
auto constexpr OpenGLMaxTessPatchComponents = 0x8e84;
auto constexpr OpenGLMaxTextureBufferSize = 0x8c2b;
auto constexpr OpenGLMaxTextureCoords = 0x8871;
auto constexpr OpenGLMaxTextureImageUnits = 0x8872;
auto constexpr OpenGLMaxTextureLodBias = 0x84fd;
auto constexpr OpenGLMaxTextureMaxAnisotropy = 0x84ff;
auto constexpr OpenGLMaxTextureSize = 0x0d33;
auto constexpr OpenGLMaxTextureStackDepth = 0x0d39;
auto constexpr OpenGLMaxTextureUnits = 0x84e2;
auto constexpr OpenGLMaxTransformFeedbackBuffers = 0x8e70;
auto constexpr OpenGLMaxTransformFeedbackInterleavedComponents = 0x8c8a;
auto constexpr OpenGLMaxTransformFeedbackSeparateAttribs = 0x8c8b;
auto constexpr OpenGLMaxTransformFeedbackSeparateComponents = 0x8c80;
auto constexpr OpenGLMaxUniformBlockSize = 0x8a30;
auto constexpr OpenGLMaxUniformBufferBindings = 0x8a2f;
auto constexpr OpenGLMaxUniformLocations = 0x826e;
auto constexpr OpenGLMaxVaryingComponents = 0x8b4b;
auto constexpr OpenGLMaxVaryingFloats = 0x8b4b;
auto constexpr OpenGLMaxVaryingVectors = 0x8dfc;
auto constexpr OpenGLMaxVertexAtomicCounterBuffers = 0x92cc;
auto constexpr OpenGLMaxVertexAtomicCounters = 0x92d2;
auto constexpr OpenGLMaxVertexAttribBindings = 0x82da;
auto constexpr OpenGLMaxVertexAttribRelativeOffset = 0x82d9;
auto constexpr OpenGLMaxVertexAttribStride = 0x82e5;
auto constexpr OpenGLMaxVertexAttribs = 0x8869;
auto constexpr OpenGLMaxVertexImageUniforms = 0x90ca;
auto constexpr OpenGLMaxVertexOutputComponents = 0x9122;
auto constexpr OpenGLMaxVertexShaderStorageBlocks = 0x90d6;
auto constexpr OpenGLMaxVertexStreams = 0x8e71;
auto constexpr OpenGLMaxVertexTextureImageUnits = 0x8b4c;
auto constexpr OpenGLMaxVertexUniformBlocks = 0x8a2b;
auto constexpr OpenGLMaxVertexUniformComponents = 0x8b4a;
auto constexpr OpenGLMaxVertexUniformVectors = 0x8dfb;
auto constexpr OpenGLMaxViewportDims = 0x0d3a;
auto constexpr OpenGLMaxViewports = 0x825b;
auto constexpr OpenGLMaxWidth = 0x827e;
auto constexpr OpenGLMediumFloat = 0x8df1;
auto constexpr OpenGLMediumInt = 0x8df4;
auto constexpr OpenGLMin = 0x8007;
auto constexpr OpenGLMinFragmentInterpolationOffset = 0x8e5b;
auto constexpr OpenGLMinMapBufferAlignment = 0x90bc;
auto constexpr OpenGLMinProgramTexelOffset = 0x8904;
auto constexpr OpenGLMinProgramTextureGatherOffset = 0x8e5e;
auto constexpr OpenGLMinSampleShadingValue = 0x8c37;
auto constexpr OpenGLMinmax = 0x802e;
auto constexpr OpenGLMinorVersion = 0x821c;
auto constexpr OpenGLMipmap = 0x8293;
auto constexpr OpenGLMirrorClampToEdge = 0x8743;
auto constexpr OpenGLMirroredRepeat = 0x8370;
auto constexpr OpenGLModelview = 0x1700;
auto constexpr OpenGLModelviewMatrix = 0x0ba6;
auto constexpr OpenGLModelviewStackDepth = 0x0ba3;
auto constexpr OpenGLModulate = 0x2100;
auto constexpr OpenGLMult = 0x0103;
auto constexpr OpenGLMultiply = 0x9294;
auto constexpr OpenGLMultisample = 0x809d;
auto constexpr OpenGLMultisampleBit = 0x20000000;
auto constexpr OpenGLMultisampleLineWidthGranularity = 0x9382;
auto constexpr OpenGLMultisampleLineWidthRange = 0x9381;
auto constexpr OpenGLN3fV3f = 0x2a25;
auto constexpr OpenGLNameLength = 0x92f9;
auto constexpr OpenGLNameStackDepth = 0x0d70;
auto constexpr OpenGLNand = 0x150e;
auto constexpr OpenGLNearest = 0x2600;
auto constexpr OpenGLNearestMipmapLinear = 0x2702;
auto constexpr OpenGLNearestMipmapNearest = 0x2700;
auto constexpr OpenGLNegativeOneToOne = 0x935e;
auto constexpr OpenGLNever = 0x0200;
auto constexpr OpenGLNicest = 0x1102;
auto constexpr OpenGLNoResetNotification = 0x8261;
auto constexpr OpenGLNoop = 0x1505;
auto constexpr OpenGLNor = 0x1508;
auto constexpr OpenGLNormalArray = 0x8075;
auto constexpr OpenGLNormalArrayBufferBinding = 0x8897;
auto constexpr OpenGLNormalArrayPointer = 0x808f;
auto constexpr OpenGLNormalArrayStride = 0x807f;
auto constexpr OpenGLNormalArrayType = 0x807e;
auto constexpr OpenGLNormalMap = 0x8511;
auto constexpr OpenGLNormalize = 0x0ba1;
auto constexpr OpenGLNotequal = 0x0205;
auto constexpr OpenGLNumActiveVariables = 0x9304;
auto constexpr OpenGLNumCompatibleSubroutines = 0x8e4a;
auto constexpr OpenGLNumCompressedTextureFormats = 0x86a2;
auto constexpr OpenGLNumExtensions = 0x821d;
auto constexpr OpenGLNumProgramBinaryFormats = 0x87fe;
auto constexpr OpenGLNumSampleCounts = 0x9380;
auto constexpr OpenGLNumShaderBinaryFormats = 0x8df9;
auto constexpr OpenGLNumShadingLanguageVersions = 0x82e9;
auto constexpr OpenGLNumSpirVExtensions = 0x9554;
auto constexpr OpenGLObjectLinear = 0x2401;
auto constexpr OpenGLObjectPlane = 0x2501;
auto constexpr OpenGLObjectType = 0x9112;
auto constexpr OpenGLOffset = 0x92fc;
auto constexpr OpenGLOneMinusConstantAlpha = 0x8004;
auto constexpr OpenGLOneMinusConstantColor = 0x8002;
auto constexpr OpenGLOneMinusDstAlpha = 0x0305;
auto constexpr OpenGLOneMinusDstColor = 0x0307;
auto constexpr OpenGLOneMinusSrc1Alpha = 0x88fb;
auto constexpr OpenGLOneMinusSrc1Color = 0x88fa;
auto constexpr OpenGLOneMinusSrcAlpha = 0x0303;
auto constexpr OpenGLOneMinusSrcColor = 0x0301;
auto constexpr OpenGLOperand0Alpha = 0x8598;
auto constexpr OpenGLOperand0Rgb = 0x8590;
auto constexpr OpenGLOperand1Alpha = 0x8599;
auto constexpr OpenGLOperand1Rgb = 0x8591;
auto constexpr OpenGLOperand2Alpha = 0x859a;
auto constexpr OpenGLOperand2Rgb = 0x8592;
auto constexpr OpenGLOr = 0x1507;
auto constexpr OpenGLOrInverted = 0x150d;
auto constexpr OpenGLOrReverse = 0x150b;
auto constexpr OpenGLOrder = 0x0a01;
auto constexpr OpenGLOutOfMemory = 0x0505;
auto constexpr OpenGLOverlay = 0x9296;
auto constexpr OpenGLPackAlignment = 0x0d05;
auto constexpr OpenGLPackCompressedBlockDepth = 0x912d;
auto constexpr OpenGLPackCompressedBlockHeight = 0x912c;
auto constexpr OpenGLPackCompressedBlockSize = 0x912e;
auto constexpr OpenGLPackCompressedBlockWidth = 0x912b;
auto constexpr OpenGLPackImageHeight = 0x806c;
auto constexpr OpenGLPackLSBFirst = 0x0d01;
auto constexpr OpenGLPackRowLength = 0x0d02;
auto constexpr OpenGLPackSkipImages = 0x806b;
auto constexpr OpenGLPackSkipPixels = 0x0d04;
auto constexpr OpenGLPackSkipRows = 0x0d03;
auto constexpr OpenGLPackSwapBytes = 0x0d00;
auto constexpr OpenGLParameterBuffer = 0x80ee;
auto constexpr OpenGLParameterBufferBinding = 0x80ef;
auto constexpr OpenGLPassThroughToken = 0x0700;
auto constexpr OpenGLPatchDefaultInnerLevel = 0x8e73;
auto constexpr OpenGLPatchDefaultOuterLevel = 0x8e74;
auto constexpr OpenGLPatchVertices = 0x8e72;
auto constexpr OpenGLPatches = 0x000e;
auto constexpr OpenGLPerspectiveCorrectionHint = 0x0c50;
auto constexpr OpenGLPixelBufferBarrierBit = 0x00000080;
auto constexpr OpenGLPixelMapAToA = 0x0c79;
auto constexpr OpenGLPixelMapAToASize = 0x0cb9;
auto constexpr OpenGLPixelMapBToB = 0x0c78;
auto constexpr OpenGLPixelMapBToBSize = 0x0cb8;
auto constexpr OpenGLPixelMapGToG = 0x0c77;
auto constexpr OpenGLPixelMapGToGSize = 0x0cb7;
auto constexpr OpenGLPixelMapIToA = 0x0c75;
auto constexpr OpenGLPixelMapIToASize = 0x0cb5;
auto constexpr OpenGLPixelMapIToB = 0x0c74;
auto constexpr OpenGLPixelMapIToBSize = 0x0cb4;
auto constexpr OpenGLPixelMapIToG = 0x0c73;
auto constexpr OpenGLPixelMapIToGSize = 0x0cb3;
auto constexpr OpenGLPixelMapIToI = 0x0c70;
auto constexpr OpenGLPixelMapIToISize = 0x0cb0;
auto constexpr OpenGLPixelMapIToR = 0x0c72;
auto constexpr OpenGLPixelMapIToRSize = 0x0cb2;
auto constexpr OpenGLPixelMapRToR = 0x0c76;
auto constexpr OpenGLPixelMapRToRSize = 0x0cb6;
auto constexpr OpenGLPixelMapSToS = 0x0c71;
auto constexpr OpenGLPixelMapSToSSize = 0x0cb1;
auto constexpr OpenGLPixelModeBit = 0x00000020;
auto constexpr OpenGLPixelPackBuffer = 0x88eb;
auto constexpr OpenGLPixelPackBufferBinding = 0x88ed;
auto constexpr OpenGLPixelUnpackBuffer = 0x88ec;
auto constexpr OpenGLPixelUnpackBufferBinding = 0x88ef;
auto constexpr OpenGLPoint = 0x1b00;
auto constexpr OpenGLPointBit = 0x00000002;
auto constexpr OpenGLPointDistanceAttenuation = 0x8129;
auto constexpr OpenGLPointFadeThresholdSize = 0x8128;
auto constexpr OpenGLPointSize = 0x0b11;
auto constexpr OpenGLPointSizeGranularity = 0x0b13;
auto constexpr OpenGLPointSizeMax = 0x8127;
auto constexpr OpenGLPointSizeMin = 0x8126;
auto constexpr OpenGLPointSizeRange = 0x0b12;
auto constexpr OpenGLPointSmooth = 0x0b10;
auto constexpr OpenGLPointSmoothHint = 0x0c51;
auto constexpr OpenGLPointSprite = 0x8861;
auto constexpr OpenGLPointSpriteCoordOrigin = 0x8ca0;
auto constexpr OpenGLPointToken = 0x0701;
auto constexpr OpenGLPoints = 0x0000;
auto constexpr OpenGLPolygon = 0x0009;
auto constexpr OpenGLPolygonBit = 0x00000008;
auto constexpr OpenGLPolygonMode = 0x0b40;
auto constexpr OpenGLPolygonOffsetClamp = 0x8e1b;
auto constexpr OpenGLPolygonOffsetFactor = 0x8038;
auto constexpr OpenGLPolygonOffsetFill = 0x8037;
auto constexpr OpenGLPolygonOffsetLine = 0x2a02;
auto constexpr OpenGLPolygonOffsetPoint = 0x2a01;
auto constexpr OpenGLPolygonOffsetUnits = 0x2a00;
auto constexpr OpenGLPolygonSmooth = 0x0b41;
auto constexpr OpenGLPolygonSmoothHint = 0x0c53;
auto constexpr OpenGLPolygonStipple = 0x0b42;
auto constexpr OpenGLPolygonStippleBit = 0x00000010;
auto constexpr OpenGLPolygonToken = 0x0703;
auto constexpr OpenGLPosition = 0x1203;
auto constexpr OpenGLPostColorMatrixColorTable = 0x80d2;
auto constexpr OpenGLPostConvolutionColorTable = 0x80d1;
auto constexpr OpenGLPrevious = 0x8578;
auto constexpr OpenGLPrimaryColor = 0x8577;
auto constexpr OpenGLPrimitiveBoundingBox = 0x92be;
auto constexpr OpenGLPrimitiveRestart = 0x8f9d;
auto constexpr OpenGLPrimitiveRestartFixedIndex = 0x8d69;
auto constexpr OpenGLPrimitiveRestartForPatchesSupported = 0x8221;
auto constexpr OpenGLPrimitiveRestartIndex = 0x8f9e;
auto constexpr OpenGLPrimitivesGenerated = 0x8c87;
auto constexpr OpenGLPrimitivesSubmitted = 0x82ef;
auto constexpr OpenGLProgram = 0x82e2;
auto constexpr OpenGLProgramBinaryFormats = 0x87ff;
auto constexpr OpenGLProgramBinaryLength = 0x8741;
auto constexpr OpenGLProgramBinaryRetrievableHint = 0x8257;
auto constexpr OpenGLProgramInput = 0x92e3;
auto constexpr OpenGLProgramOutput = 0x92e4;
auto constexpr OpenGLProgramPipeline = 0x82e4;
auto constexpr OpenGLProgramPipelineBinding = 0x825a;
auto constexpr OpenGLProgramPointSize = 0x8642;
auto constexpr OpenGLProgramSeparable = 0x8258;
auto constexpr OpenGLProjection = 0x1701;
auto constexpr OpenGLProjectionMatrix = 0x0ba7;
auto constexpr OpenGLProjectionStackDepth = 0x0ba4;
auto constexpr OpenGLProvokingVertex = 0x8e4f;
auto constexpr OpenGLProxyColorTable = 0x80d3;
auto constexpr OpenGLProxyHistogram = 0x8025;
auto constexpr OpenGLProxyPostColorMatrixColorTable = 0x80d5;
auto constexpr OpenGLProxyPostConvolutionColorTable = 0x80d4;
auto constexpr OpenGLProxyTexture1d = 0x8063;
auto constexpr OpenGLProxyTexture1dArray = 0x8c19;
auto constexpr OpenGLProxyTexture2d = 0x8064;
auto constexpr OpenGLProxyTexture2dArray = 0x8c1b;
auto constexpr OpenGLProxyTexture2dMultisample = 0x9101;
auto constexpr OpenGLProxyTexture2dMultisampleArray = 0x9103;
auto constexpr OpenGLProxyTexture3d = 0x8070;
auto constexpr OpenGLProxyTextureCubeMap = 0x851b;
auto constexpr OpenGLProxyTextureCubeMapArray = 0x900b;
auto constexpr OpenGLProxyTextureRectangle = 0x84f7;
auto constexpr OpenGLQ = 0x2003;
auto constexpr OpenGLQuadStrip = 0x0008;
auto constexpr OpenGLQuadraticAttenuation = 0x1209;
auto constexpr OpenGLQuads = 0x0007;
auto constexpr OpenGLQuadsFollowProvokingVertexConvention = 0x8e4c;
auto constexpr OpenGLQuery = 0x82e3;
auto constexpr OpenGLQueryBuffer = 0x9192;
auto constexpr OpenGLQueryBufferBarrierBit = 0x00008000;
auto constexpr OpenGLQueryBufferBinding = 0x9193;
auto constexpr OpenGLQueryByRegionNoWait = 0x8e16;
auto constexpr OpenGLQueryByRegionNoWaitInverted = 0x8e1a;
auto constexpr OpenGLQueryByRegionWait = 0x8e15;
auto constexpr OpenGLQueryByRegionWaitInverted = 0x8e19;
auto constexpr OpenGLQueryCounterBits = 0x8864;
auto constexpr OpenGLQueryNoWait = 0x8e14;
auto constexpr OpenGLQueryNoWaitInverted = 0x8e18;
auto constexpr OpenGLQueryResult = 0x8866;
auto constexpr OpenGLQueryResultAvailable = 0x8867;
auto constexpr OpenGLQueryResultNoWait = 0x9194;
auto constexpr OpenGLQueryTarget = 0x82ea;
auto constexpr OpenGLQueryWait = 0x8e13;
auto constexpr OpenGLQueryWaitInverted = 0x8e17;
auto constexpr OpenGLR = 0x2002;
auto constexpr OpenGLR11fG11fB10f = 0x8c3a;
auto constexpr OpenGLR16 = 0x822a;
auto constexpr OpenGLR16Snorm = 0x8f98;
auto constexpr OpenGLR16f = 0x822d;
auto constexpr OpenGLR16i = 0x8233;
auto constexpr OpenGLR16ui = 0x8234;
auto constexpr OpenGLR32f = 0x822e;
auto constexpr OpenGLR32i = 0x8235;
auto constexpr OpenGLR32ui = 0x8236;
auto constexpr OpenGLR3G3B2 = 0x2a10;
auto constexpr OpenGLR8 = 0x8229;
auto constexpr OpenGLR8Snorm = 0x8f94;
auto constexpr OpenGLR8i = 0x8231;
auto constexpr OpenGLR8ui = 0x8232;
auto constexpr OpenGLRGBA = 0x1908;
auto constexpr OpenGLRGBA12 = 0x805a;
auto constexpr OpenGLRGBA16 = 0x805b;
auto constexpr OpenGLRGBA16Snorm = 0x8f9b;
auto constexpr OpenGLRGBA16f = 0x881a;
auto constexpr OpenGLRGBA16i = 0x8d88;
auto constexpr OpenGLRGBA16ui = 0x8d76;
auto constexpr OpenGLRGBA2 = 0x8055;
auto constexpr OpenGLRGBA32f = 0x8814;
auto constexpr OpenGLRGBA32i = 0x8d82;
auto constexpr OpenGLRGBA32ui = 0x8d70;
auto constexpr OpenGLRGBA4 = 0x8056;
auto constexpr OpenGLRGBA8 = 0x8058;
auto constexpr OpenGLRGBA8Snorm = 0x8f97;
auto constexpr OpenGLRGBA8i = 0x8d8e;
auto constexpr OpenGLRGBA8ui = 0x8d7c;
auto constexpr OpenGLRGBAInteger = 0x8d99;
auto constexpr OpenGLRGBAMode = 0x0c31;
auto constexpr OpenGLRasterizerDiscard = 0x8c89;
auto constexpr OpenGLReadBuffer = 0x0c02;
auto constexpr OpenGLReadFramebuffer = 0x8ca8;
auto constexpr OpenGLReadFramebufferBinding = 0x8caa;
auto constexpr OpenGLReadOnly = 0x88b8;
auto constexpr OpenGLReadPixels = 0x828c;
auto constexpr OpenGLReadPixelsFormat = 0x828d;
auto constexpr OpenGLReadPixelsType = 0x828e;
auto constexpr OpenGLReadWrite = 0x88ba;
auto constexpr OpenGLRed = 0x1903;
auto constexpr OpenGLRedBias = 0x0d15;
auto constexpr OpenGLRedBits = 0x0d52;
auto constexpr OpenGLRedInteger = 0x8d94;
auto constexpr OpenGLRedScale = 0x0d14;
auto constexpr OpenGLReferencedByComputeShader = 0x930b;
auto constexpr OpenGLReferencedByFragmentShader = 0x930a;
auto constexpr OpenGLReferencedByGeometryShader = 0x9309;
auto constexpr OpenGLReferencedByTessControlShader = 0x9307;
auto constexpr OpenGLReferencedByTessEvaluationShader = 0x9308;
auto constexpr OpenGLReferencedByVertexShader = 0x9306;
auto constexpr OpenGLReflectionMap = 0x8512;
auto constexpr OpenGLRender = 0x1c00;
auto constexpr OpenGLRenderMode = 0x0c40;
auto constexpr OpenGLRenderbuffer = 0x8d41;
auto constexpr OpenGLRenderbufferAlphaSize = 0x8d53;
auto constexpr OpenGLRenderbufferBinding = 0x8ca7;
auto constexpr OpenGLRenderbufferBlueSize = 0x8d52;
auto constexpr OpenGLRenderbufferDepthSize = 0x8d54;
auto constexpr OpenGLRenderbufferGreenSize = 0x8d51;
auto constexpr OpenGLRenderbufferHeight = 0x8d43;
auto constexpr OpenGLRenderbufferInternalFormat = 0x8d44;
auto constexpr OpenGLRenderbufferRedSize = 0x8d50;
auto constexpr OpenGLRenderbufferSamples = 0x8cab;
auto constexpr OpenGLRenderbufferStencilSize = 0x8d55;
auto constexpr OpenGLRenderbufferWidth = 0x8d42;
auto constexpr OpenGLRenderer = 0x1f01;
auto constexpr OpenGLRepeat = 0x2901;
auto constexpr OpenGLReplace = 0x1e01;
auto constexpr OpenGLRescaleNormal = 0x803a;
auto constexpr OpenGLResetNotificationStrategy = 0x8256;
auto constexpr OpenGLReturn = 0x0102;
auto constexpr OpenGLRg = 0x8227;
auto constexpr OpenGLRg16 = 0x822c;
auto constexpr OpenGLRg16Snorm = 0x8f99;
auto constexpr OpenGLRg16f = 0x822f;
auto constexpr OpenGLRg16i = 0x8239;
auto constexpr OpenGLRg16ui = 0x823a;
auto constexpr OpenGLRg32f = 0x8230;
auto constexpr OpenGLRg32i = 0x823b;
auto constexpr OpenGLRg32ui = 0x823c;
auto constexpr OpenGLRg8 = 0x822b;
auto constexpr OpenGLRg8Snorm = 0x8f95;
auto constexpr OpenGLRg8i = 0x8237;
auto constexpr OpenGLRg8ui = 0x8238;
auto constexpr OpenGLRgInteger = 0x8228;
auto constexpr OpenGLRgb = 0x1907;
auto constexpr OpenGLRgb10 = 0x8052;
auto constexpr OpenGLRgb10A2 = 0x8059;
auto constexpr OpenGLRgb10A2ui = 0x906f;
auto constexpr OpenGLRgb12 = 0x8053;
auto constexpr OpenGLRgb16 = 0x8054;
auto constexpr OpenGLRgb16Snorm = 0x8f9a;
auto constexpr OpenGLRgb16f = 0x881b;
auto constexpr OpenGLRgb16i = 0x8d89;
auto constexpr OpenGLRgb16ui = 0x8d77;
auto constexpr OpenGLRgb32f = 0x8815;
auto constexpr OpenGLRgb32i = 0x8d83;
auto constexpr OpenGLRgb32ui = 0x8d71;
auto constexpr OpenGLRgb4 = 0x804f;
auto constexpr OpenGLRgb5 = 0x8050;
auto constexpr OpenGLRgb565 = 0x8d62;
auto constexpr OpenGLRgb5A1 = 0x8057;
auto constexpr OpenGLRgb8 = 0x8051;
auto constexpr OpenGLRgb8Snorm = 0x8f96;
auto constexpr OpenGLRgb8i = 0x8d8f;
auto constexpr OpenGLRgb8ui = 0x8d7d;
auto constexpr OpenGLRgb9E5 = 0x8c3d;
auto constexpr OpenGLRgbInteger = 0x8d98;
auto constexpr OpenGLRgbScale = 0x8573;
auto constexpr OpenGLRight = 0x0407;
auto constexpr OpenGLS = 0x2000;
auto constexpr OpenGLSRGB = 0x8c40;
auto constexpr OpenGLSRGB8 = 0x8c41;
auto constexpr OpenGLSRGB8Alpha8 = 0x8c43;
auto constexpr OpenGLSRGBAlpha = 0x8c42;
auto constexpr OpenGLSRGBRead = 0x8297;
auto constexpr OpenGLSRGBWrite = 0x8298;
auto constexpr OpenGLSampleAlphaToCoverage = 0x809e;
auto constexpr OpenGLSampleAlphaToOne = 0x809f;
auto constexpr OpenGLSampleBuffers = 0x80a8;
auto constexpr OpenGLSampleCoverage = 0x80a0;
auto constexpr OpenGLSampleCoverageInvert = 0x80ab;
auto constexpr OpenGLSampleCoverageValue = 0x80aa;
auto constexpr OpenGLSampleMask = 0x8e51;
auto constexpr OpenGLSampleMaskValue = 0x8e52;
auto constexpr OpenGLSamplePosition = 0x8e50;
auto constexpr OpenGLSampleShading = 0x8c36;
auto constexpr OpenGLSampler = 0x82e6;
auto constexpr OpenGLSampler1d = 0x8b5d;
auto constexpr OpenGLSampler1dArray = 0x8dc0;
auto constexpr OpenGLSampler1dArrayShadow = 0x8dc3;
auto constexpr OpenGLSampler1dShadow = 0x8b61;
auto constexpr OpenGLSampler2d = 0x8b5e;
auto constexpr OpenGLSampler2dArray = 0x8dc1;
auto constexpr OpenGLSampler2dArrayShadow = 0x8dc4;
auto constexpr OpenGLSampler2dMultisample = 0x9108;
auto constexpr OpenGLSampler2dMultisampleArray = 0x910b;
auto constexpr OpenGLSampler2dRect = 0x8b63;
auto constexpr OpenGLSampler2dRectShadow = 0x8b64;
auto constexpr OpenGLSampler2dShadow = 0x8b62;
auto constexpr OpenGLSampler3d = 0x8b5f;
auto constexpr OpenGLSamplerBinding = 0x8919;
auto constexpr OpenGLSamplerBuffer = 0x8dc2;
auto constexpr OpenGLSamplerCube = 0x8b60;
auto constexpr OpenGLSamplerCubeMapArray = 0x900c;
auto constexpr OpenGLSamplerCubeMapArrayShadow = 0x900d;
auto constexpr OpenGLSamplerCubeShadow = 0x8dc5;
auto constexpr OpenGLSamples = 0x80a9;
auto constexpr OpenGLSamplesPassed = 0x8914;
auto constexpr OpenGLScissorBit = 0x00080000;
auto constexpr OpenGLScissorBox = 0x0c10;
auto constexpr OpenGLScissorTest = 0x0c11;
auto constexpr OpenGLScreen = 0x9295;
auto constexpr OpenGLSecondaryColorArray = 0x845e;
auto constexpr OpenGLSecondaryColorArrayBufferBinding = 0x889c;
auto constexpr OpenGLSecondaryColorArrayPointer = 0x845d;
auto constexpr OpenGLSecondaryColorArraySize = 0x845a;
auto constexpr OpenGLSecondaryColorArrayStride = 0x845c;
auto constexpr OpenGLSecondaryColorArrayType = 0x845b;
auto constexpr OpenGLSelect = 0x1c02;
auto constexpr OpenGLSelectionBufferPointer = 0x0df3;
auto constexpr OpenGLSelectionBufferSize = 0x0df4;
auto constexpr OpenGLSeparable2d = 0x8012;
auto constexpr OpenGLSeparateAttribs = 0x8c8d;
auto constexpr OpenGLSeparateSpecularColor = 0x81fa;
auto constexpr OpenGLSet = 0x150f;
auto constexpr OpenGLShadeModel = 0x0b54;
auto constexpr OpenGLShader = 0x82e1;
auto constexpr OpenGLShaderBinaryFormatSpirV = 0x9551;
auto constexpr OpenGLShaderBinaryFormats = 0x8df8;
auto constexpr OpenGLShaderCompiler = 0x8dfa;
auto constexpr OpenGLShaderImageAccessBarrierBit = 0x00000020;
auto constexpr OpenGLShaderImageAtomic = 0x82a6;
auto constexpr OpenGLShaderImageLoad = 0x82a4;
auto constexpr OpenGLShaderImageStore = 0x82a5;
auto constexpr OpenGLShaderSourceLength = 0x8b88;
auto constexpr OpenGLShaderStorageBarrierBit = 0x00002000;
auto constexpr OpenGLShaderStorageBlock = 0x92e6;
auto constexpr OpenGLShaderStorageBuffer = 0x90d2;
auto constexpr OpenGLShaderStorageBufferBinding = 0x90d3;
auto constexpr OpenGLShaderStorageBufferOffsetAlignment = 0x90df;
auto constexpr OpenGLShaderStorageBufferSize = 0x90d5;
auto constexpr OpenGLShaderStorageBufferStart = 0x90d4;
auto constexpr OpenGLShaderType = 0x8b4f;
auto constexpr OpenGLShadingLanguageVersion = 0x8b8c;
auto constexpr OpenGLShininess = 0x1601;
auto constexpr OpenGLShort = 0x1402;
auto constexpr OpenGLSignaled = 0x9119;
auto constexpr OpenGLSignedNormalized = 0x8f9c;
auto constexpr OpenGLSimultaneousTextureAndDepthTest = 0x82ac;
auto constexpr OpenGLSimultaneousTextureAndDepthWrite = 0x82ae;
auto constexpr OpenGLSimultaneousTextureAndStencilTest = 0x82ad;
auto constexpr OpenGLSimultaneousTextureAndStencilWrite = 0x82af;
auto constexpr OpenGLSingleColor = 0x81f9;
auto constexpr OpenGLSluminance = 0x8c46;
auto constexpr OpenGLSluminance8 = 0x8c47;
auto constexpr OpenGLSluminance8Alpha8 = 0x8c45;
auto constexpr OpenGLSluminanceAlpha = 0x8c44;
auto constexpr OpenGLSmooth = 0x1d01;
auto constexpr OpenGLSmoothLineWidthGranularity = 0x0b23;
auto constexpr OpenGLSmoothLineWidthRange = 0x0b22;
auto constexpr OpenGLSmoothPointSizeGranularity = 0x0b13;
auto constexpr OpenGLSmoothPointSizeRange = 0x0b12;
auto constexpr OpenGLSoftlight = 0x929c;
auto constexpr OpenGLSource0Alpha = 0x8588;
auto constexpr OpenGLSource0Rgb = 0x8580;
auto constexpr OpenGLSource1Alpha = 0x8589;
auto constexpr OpenGLSource1Rgb = 0x8581;
auto constexpr OpenGLSource2Alpha = 0x858a;
auto constexpr OpenGLSource2Rgb = 0x8582;
auto constexpr OpenGLSpecular = 0x1202;
auto constexpr OpenGLSphereMap = 0x2402;
auto constexpr OpenGLSpirVBinary = 0x9552;
auto constexpr OpenGLSpirVExtensions = 0x9553;
auto constexpr OpenGLSpotCutoff = 0x1206;
auto constexpr OpenGLSpotDirection = 0x1204;
auto constexpr OpenGLSpotExponent = 0x1205;
auto constexpr OpenGLSrc0Alpha = 0x8588;
auto constexpr OpenGLSrc0Rgb = 0x8580;
auto constexpr OpenGLSrc1Alpha = 0x8589;
auto constexpr OpenGLSrc1Color = 0x88f9;
auto constexpr OpenGLSrc1Rgb = 0x8581;
auto constexpr OpenGLSrc2Alpha = 0x858a;
auto constexpr OpenGLSrc2Rgb = 0x8582;
auto constexpr OpenGLSrcAlpha = 0x0302;
auto constexpr OpenGLSrcAlphaSaturate = 0x0308;
auto constexpr OpenGLSrcColor = 0x0300;
auto constexpr OpenGLStackOverflow = 0x0503;
auto constexpr OpenGLStackUnderflow = 0x0504;
auto constexpr OpenGLStaticCopy = 0x88e6;
auto constexpr OpenGLStaticDraw = 0x88e4;
auto constexpr OpenGLStaticRead = 0x88e5;
auto constexpr OpenGLStencil = 0x1802;
auto constexpr OpenGLStencilAttachment = 0x8d20;
auto constexpr OpenGLStencilBackFail = 0x8801;
auto constexpr OpenGLStencilBackFunc = 0x8800;
auto constexpr OpenGLStencilBackPassDepthFail = 0x8802;
auto constexpr OpenGLStencilBackPassDepthPass = 0x8803;
auto constexpr OpenGLStencilBackRef = 0x8ca3;
auto constexpr OpenGLStencilBackValueMask = 0x8ca4;
auto constexpr OpenGLStencilBackWriteMask = 0x8ca5;
auto constexpr OpenGLStencilBits = 0x0d57;
auto constexpr OpenGLStencilBufferBit = 0x00000400;
auto constexpr OpenGLStencilClearValue = 0x0b91;
auto constexpr OpenGLStencilComponents = 0x8285;
auto constexpr OpenGLStencilFail = 0x0b94;
auto constexpr OpenGLStencilFunc = 0x0b92;
auto constexpr OpenGLStencilIndex = 0x1901;
auto constexpr OpenGLStencilIndex1 = 0x8d46;
auto constexpr OpenGLStencilIndex16 = 0x8d49;
auto constexpr OpenGLStencilIndex4 = 0x8d47;
auto constexpr OpenGLStencilIndex8 = 0x8d48;
auto constexpr OpenGLStencilPassDepthFail = 0x0b95;
auto constexpr OpenGLStencilPassDepthPass = 0x0b96;
auto constexpr OpenGLStencilRef = 0x0b97;
auto constexpr OpenGLStencilRenderable = 0x8288;
auto constexpr OpenGLStencilTest = 0x0b90;
auto constexpr OpenGLStencilValueMask = 0x0b93;
auto constexpr OpenGLStencilWriteMask = 0x0b98;
auto constexpr OpenGLStereo = 0x0c33;
auto constexpr OpenGLStreamCopy = 0x88e2;
auto constexpr OpenGLStreamDraw = 0x88e0;
auto constexpr OpenGLStreamRead = 0x88e1;
auto constexpr OpenGLSubpixelBits = 0x0d50;
auto constexpr OpenGLSubtract = 0x84e7;
auto constexpr OpenGLSyncCondition = 0x9113;
auto constexpr OpenGLSyncFence = 0x9116;
auto constexpr OpenGLSyncFlags = 0x9115;
auto constexpr OpenGLSyncFlushCommandsBit = 0x00000001;
auto constexpr OpenGLSyncGpuCommandsComplete = 0x9117;
auto constexpr OpenGLSyncStatus = 0x9114;
auto constexpr OpenGLT = 0x2001;
auto constexpr OpenGLT2fC3fV3f = 0x2a2a;
auto constexpr OpenGLT2fC4fN3fV3f = 0x2a2c;
auto constexpr OpenGLT2fC4ubV3f = 0x2a29;
auto constexpr OpenGLT2fN3fV3f = 0x2a2b;
auto constexpr OpenGLT2fV3f = 0x2a27;
auto constexpr OpenGLT4fC4fN3fV4f = 0x2a2d;
auto constexpr OpenGLT4fV4f = 0x2a28;
auto constexpr OpenGLTessControlOutputVertices = 0x8e75;
auto constexpr OpenGLTessControlShader = 0x8e88;
auto constexpr OpenGLTessControlShaderBit = 0x00000008;
auto constexpr OpenGLTessControlShaderPatches = 0x82f1;
auto constexpr OpenGLTessControlSubroutine = 0x92e9;
auto constexpr OpenGLTessControlSubroutineUniform = 0x92ef;
auto constexpr OpenGLTessControlTexture = 0x829c;
auto constexpr OpenGLTessEvaluationShader = 0x8e87;
auto constexpr OpenGLTessEvaluationShaderBit = 0x00000010;
auto constexpr OpenGLTessEvaluationShaderInvocations = 0x82f2;
auto constexpr OpenGLTessEvaluationSubroutine = 0x92ea;
auto constexpr OpenGLTessEvaluationSubroutineUniform = 0x92f0;
auto constexpr OpenGLTessEvaluationTexture = 0x829d;
auto constexpr OpenGLTessGenMode = 0x8e76;
auto constexpr OpenGLTessGenPointMode = 0x8e79;
auto constexpr OpenGLTessGenSpacing = 0x8e77;
auto constexpr OpenGLTessGenVertexOrder = 0x8e78;
auto constexpr OpenGLTexture = 0x1702;
auto constexpr OpenGLTexture0 = 0x84c0;
auto constexpr OpenGLTexture1 = 0x84c1;
auto constexpr OpenGLTexture10 = 0x84ca;
auto constexpr OpenGLTexture11 = 0x84cb;
auto constexpr OpenGLTexture12 = 0x84cc;
auto constexpr OpenGLTexture13 = 0x84cd;
auto constexpr OpenGLTexture14 = 0x84ce;
auto constexpr OpenGLTexture15 = 0x84cf;
auto constexpr OpenGLTexture16 = 0x84d0;
auto constexpr OpenGLTexture17 = 0x84d1;
auto constexpr OpenGLTexture18 = 0x84d2;
auto constexpr OpenGLTexture19 = 0x84d3;
auto constexpr OpenGLTexture1d = 0x0de0;
auto constexpr OpenGLTexture1dArray = 0x8c18;
auto constexpr OpenGLTexture2 = 0x84c2;
auto constexpr OpenGLTexture20 = 0x84d4;
auto constexpr OpenGLTexture21 = 0x84d5;
auto constexpr OpenGLTexture22 = 0x84d6;
auto constexpr OpenGLTexture23 = 0x84d7;
auto constexpr OpenGLTexture24 = 0x84d8;
auto constexpr OpenGLTexture25 = 0x84d9;
auto constexpr OpenGLTexture26 = 0x84da;
auto constexpr OpenGLTexture27 = 0x84db;
auto constexpr OpenGLTexture28 = 0x84dc;
auto constexpr OpenGLTexture29 = 0x84dd;
auto constexpr OpenGLTexture2d = 0x0de1;
auto constexpr OpenGLTexture2dArray = 0x8c1a;
auto constexpr OpenGLTexture2dMultisample = 0x9100;
auto constexpr OpenGLTexture2dMultisampleArray = 0x9102;
auto constexpr OpenGLTexture3 = 0x84c3;
auto constexpr OpenGLTexture30 = 0x84de;
auto constexpr OpenGLTexture31 = 0x84df;
auto constexpr OpenGLTexture3d = 0x806f;
auto constexpr OpenGLTexture4 = 0x84c4;
auto constexpr OpenGLTexture5 = 0x84c5;
auto constexpr OpenGLTexture6 = 0x84c6;
auto constexpr OpenGLTexture7 = 0x84c7;
auto constexpr OpenGLTexture8 = 0x84c8;
auto constexpr OpenGLTexture9 = 0x84c9;
auto constexpr OpenGLTextureAlphaSize = 0x805f;
auto constexpr OpenGLTextureAlphaType = 0x8c13;
auto constexpr OpenGLTextureBaseLevel = 0x813c;
auto constexpr OpenGLTextureBinding1d = 0x8068;
auto constexpr OpenGLTextureBinding1dArray = 0x8c1c;
auto constexpr OpenGLTextureBinding2d = 0x8069;
auto constexpr OpenGLTextureBinding2dArray = 0x8c1d;
auto constexpr OpenGLTextureBinding2dMultisample = 0x9104;
auto constexpr OpenGLTextureBinding2dMultisampleArray = 0x9105;
auto constexpr OpenGLTextureBinding3d = 0x806a;
auto constexpr OpenGLTextureBindingBuffer = 0x8c2c;
auto constexpr OpenGLTextureBindingCubeMap = 0x8514;
auto constexpr OpenGLTextureBindingCubeMapArray = 0x900a;
auto constexpr OpenGLTextureBindingRectangle = 0x84f6;
auto constexpr OpenGLTextureBit = 0x00040000;
auto constexpr OpenGLTextureBlueSize = 0x805e;
auto constexpr OpenGLTextureBlueType = 0x8c12;
auto constexpr OpenGLTextureBorder = 0x1005;
auto constexpr OpenGLTextureBorderColor = 0x1004;
auto constexpr OpenGLTextureBuffer = 0x8c2a;
auto constexpr OpenGLTextureBufferBinding = 0x8c2a;
auto constexpr OpenGLTextureBufferDataStoreBinding = 0x8c2d;
auto constexpr OpenGLTextureBufferOffset = 0x919d;
auto constexpr OpenGLTextureBufferOffsetAlignment = 0x919f;
auto constexpr OpenGLTextureBufferSize = 0x919e;
auto constexpr OpenGLTextureCompareFunc = 0x884d;
auto constexpr OpenGLTextureCompareMode = 0x884c;
auto constexpr OpenGLTextureComponents = 0x1003;
auto constexpr OpenGLTextureCompressed = 0x86a1;
auto constexpr OpenGLTextureCompressedBlockHeight = 0x82b2;
auto constexpr OpenGLTextureCompressedBlockSize = 0x82b3;
auto constexpr OpenGLTextureCompressedBlockWidth = 0x82b1;
auto constexpr OpenGLTextureCompressedImageSize = 0x86a0;
auto constexpr OpenGLTextureCompressionHint = 0x84ef;
auto constexpr OpenGLTextureCoordArray = 0x8078;
auto constexpr OpenGLTextureCoordArrayBufferBinding = 0x889a;
auto constexpr OpenGLTextureCoordArrayPointer = 0x8092;
auto constexpr OpenGLTextureCoordArraySize = 0x8088;
auto constexpr OpenGLTextureCoordArrayStride = 0x808a;
auto constexpr OpenGLTextureCoordArrayType = 0x8089;
auto constexpr OpenGLTextureCubeMap = 0x8513;
auto constexpr OpenGLTextureCubeMapArray = 0x9009;
auto constexpr OpenGLTextureCubeMapNegativeX = 0x8516;
auto constexpr OpenGLTextureCubeMapNegativeY = 0x8518;
auto constexpr OpenGLTextureCubeMapNegativeZ = 0x851a;
auto constexpr OpenGLTextureCubeMapPositiveX = 0x8515;
auto constexpr OpenGLTextureCubeMapPositiveY = 0x8517;
auto constexpr OpenGLTextureCubeMapPositiveZ = 0x8519;
auto constexpr OpenGLTextureCubeMapSeamless = 0x884f;
auto constexpr OpenGLTextureDepth = 0x8071;
auto constexpr OpenGLTextureDepthSize = 0x884a;
auto constexpr OpenGLTextureDepthType = 0x8c16;
auto constexpr OpenGLTextureEnv = 0x2300;
auto constexpr OpenGLTextureEnvColor = 0x2201;
auto constexpr OpenGLTextureEnvMode = 0x2200;
auto constexpr OpenGLTextureFetchBarrierBit = 0x00000008;
auto constexpr OpenGLTextureFilterControl = 0x8500;
auto constexpr OpenGLTextureFixedSampleLocations = 0x9107;
auto constexpr OpenGLTextureGather = 0x82a2;
auto constexpr OpenGLTextureGatherShadow = 0x82a3;
auto constexpr OpenGLTextureGenMode = 0x2500;
auto constexpr OpenGLTextureGenQ = 0x0c63;
auto constexpr OpenGLTextureGenR = 0x0c62;
auto constexpr OpenGLTextureGenS = 0x0c60;
auto constexpr OpenGLTextureGenT = 0x0c61;
auto constexpr OpenGLTextureGreenSize = 0x805d;
auto constexpr OpenGLTextureGreenType = 0x8c11;
auto constexpr OpenGLTextureHeight = 0x1001;
auto constexpr OpenGLTextureImageFormat = 0x828f;
auto constexpr OpenGLTextureImageType = 0x8290;
auto constexpr OpenGLTextureImmutableFormat = 0x912f;
auto constexpr OpenGLTextureImmutableLevels = 0x82df;
auto constexpr OpenGLTextureIntensitySize = 0x8061;
auto constexpr OpenGLTextureIntensityType = 0x8c15;
auto constexpr OpenGLTextureInternalFormat = 0x1003;
auto constexpr OpenGLTextureLodBias = 0x8501;
auto constexpr OpenGLTextureLuminanceSize = 0x8060;
auto constexpr OpenGLTextureLuminanceType = 0x8c14;
auto constexpr OpenGLTextureMagFilter = 0x2800;
auto constexpr OpenGLTextureMatrix = 0x0ba8;
auto constexpr OpenGLTextureMaxAnisotropy = 0x84fe;
auto constexpr OpenGLTextureMaxLevel = 0x813d;
auto constexpr OpenGLTextureMaxLod = 0x813b;
auto constexpr OpenGLTextureMinFilter = 0x2801;
auto constexpr OpenGLTextureMinLod = 0x813a;
auto constexpr OpenGLTexturePriority = 0x8066;
auto constexpr OpenGLTextureRectangle = 0x84f5;
auto constexpr OpenGLTextureRedSize = 0x805c;
auto constexpr OpenGLTextureRedType = 0x8c10;
auto constexpr OpenGLTextureResident = 0x8067;
auto constexpr OpenGLTextureSamples = 0x9106;
auto constexpr OpenGLTextureShadow = 0x82a1;
auto constexpr OpenGLTextureSharedSize = 0x8c3f;
auto constexpr OpenGLTextureStackDepth = 0x0ba5;
auto constexpr OpenGLTextureStencilSize = 0x88f1;
auto constexpr OpenGLTextureSwizzleA = 0x8e45;
auto constexpr OpenGLTextureSwizzleB = 0x8e44;
auto constexpr OpenGLTextureSwizzleG = 0x8e43;
auto constexpr OpenGLTextureSwizzleR = 0x8e42;
auto constexpr OpenGLTextureSwizzleRGBA = 0x8e46;
auto constexpr OpenGLTextureTarget = 0x1006;
auto constexpr OpenGLTextureUpdateBarrierBit = 0x00000100;
auto constexpr OpenGLTextureView = 0x82b5;
auto constexpr OpenGLTextureViewMinLayer = 0x82dd;
auto constexpr OpenGLTextureViewMinLevel = 0x82db;
auto constexpr OpenGLTextureViewNumLayers = 0x82de;
auto constexpr OpenGLTextureViewNumLevels = 0x82dc;
auto constexpr OpenGLTextureWidth = 0x1000;
auto constexpr OpenGLTextureWrapR = 0x8072;
auto constexpr OpenGLTextureWrapS = 0x2802;
auto constexpr OpenGLTextureWrapT = 0x2803;
auto constexpr OpenGLTimeElapsed = 0x88bf;
auto constexpr OpenGLTimeoutExpired = 0x911b;
auto constexpr OpenGLTimeoutIgnored = 0xffffffffffffffff;
auto constexpr OpenGLTimestamp = 0x8e28;
auto constexpr OpenGLTopLevelArraySize = 0x930c;
auto constexpr OpenGLTopLevelArrayStride = 0x930d;
auto constexpr OpenGLTransformBit = 0x00001000;
auto constexpr OpenGLTransformFeedback = 0x8e22;
auto constexpr OpenGLTransformFeedbackActive = 0x8e24;
auto constexpr OpenGLTransformFeedbackBarrierBit = 0x00000800;
auto constexpr OpenGLTransformFeedbackBinding = 0x8e25;
auto constexpr OpenGLTransformFeedbackBuffer = 0x8c8e;
auto constexpr OpenGLTransformFeedbackBufferActive = 0x8e24;
auto constexpr OpenGLTransformFeedbackBufferBinding = 0x8c8f;
auto constexpr OpenGLTransformFeedbackBufferIndex = 0x934b;
auto constexpr OpenGLTransformFeedbackBufferMode = 0x8c7f;
auto constexpr OpenGLTransformFeedbackBufferPaused = 0x8e23;
auto constexpr OpenGLTransformFeedbackBufferSize = 0x8c85;
auto constexpr OpenGLTransformFeedbackBufferStart = 0x8c84;
auto constexpr OpenGLTransformFeedbackBufferStride = 0x934c;
auto constexpr OpenGLTransformFeedbackOverflow = 0x82ec;
auto constexpr OpenGLTransformFeedbackPaused = 0x8e23;
auto constexpr OpenGLTransformFeedbackPrimitivesWritten = 0x8c88;
auto constexpr OpenGLTransformFeedbackStreamOverflow = 0x82ed;
auto constexpr OpenGLTransformFeedbackVarying = 0x92f4;
auto constexpr OpenGLTransformFeedbackVaryingMaxLength = 0x8c76;
auto constexpr OpenGLTransformFeedbackVaryings = 0x8c83;
auto constexpr OpenGLTransposeColorMatrix = 0x84e6;
auto constexpr OpenGLTransposeModelviewMatrix = 0x84e3;
auto constexpr OpenGLTransposeProjectionMatrix = 0x84e4;
auto constexpr OpenGLTransposeTextureMatrix = 0x84e5;
auto constexpr OpenGLTriangleFan = 0x0006;
auto constexpr OpenGLTriangleStrip = 0x0005;
auto constexpr OpenGLTriangleStripAdjacency = 0x000d;
auto constexpr OpenGLTriangles = 0x0004;
auto constexpr OpenGLTrianglesAdjacency = 0x000c;
auto constexpr OpenGLType = 0x92fa;
auto constexpr OpenGLUndefinedVertex = 0x8260;
auto constexpr OpenGLUniform = 0x92e1;
auto constexpr OpenGLUniformArrayStride = 0x8a3c;
auto constexpr OpenGLUniformAtomicCounterBufferIndex = 0x92da;
auto constexpr OpenGLUniformBarrierBit = 0x00000004;
auto constexpr OpenGLUniformBlock = 0x92e2;
auto constexpr OpenGLUniformBlockActiveUniformIndices = 0x8a43;
auto constexpr OpenGLUniformBlockActiveUniforms = 0x8a42;
auto constexpr OpenGLUniformBlockBinding = 0x8a3f;
auto constexpr OpenGLUniformBlockDataSize = 0x8a40;
auto constexpr OpenGLUniformBlockIndex = 0x8a3a;
auto constexpr OpenGLUniformBlockNameLength = 0x8a41;
auto constexpr OpenGLUniformBlockReferencedByComputeShader = 0x90ec;
auto constexpr OpenGLUniformBlockReferencedByFragmentShader = 0x8a46;
auto constexpr OpenGLUniformBlockReferencedByGeometryShader = 0x8a45;
auto constexpr OpenGLUniformBlockReferencedByTessControlShader = 0x84f0;
auto constexpr OpenGLUniformBlockReferencedByTessEvaluationShader = 0x84f1;
auto constexpr OpenGLUniformBlockReferencedByVertexShader = 0x8a44;
auto constexpr OpenGLUniformBuffer = 0x8a11;
auto constexpr OpenGLUniformBufferBinding = 0x8a28;
auto constexpr OpenGLUniformBufferOffsetAlignment = 0x8a34;
auto constexpr OpenGLUniformBufferSize = 0x8a2a;
auto constexpr OpenGLUniformBufferStart = 0x8a29;
auto constexpr OpenGLUniformIsRowMajor = 0x8a3e;
auto constexpr OpenGLUniformMatrixStride = 0x8a3d;
auto constexpr OpenGLUniformNameLength = 0x8a39;
auto constexpr OpenGLUniformOffset = 0x8a3b;
auto constexpr OpenGLUniformSize = 0x8a38;
auto constexpr OpenGLUniformType = 0x8a37;
auto constexpr OpenGLUnknownContextReset = 0x8255;
auto constexpr OpenGLUnpackAlignment = 0x0cf5;
auto constexpr OpenGLUnpackCompressedBlockDepth = 0x9129;
auto constexpr OpenGLUnpackCompressedBlockHeight = 0x9128;
auto constexpr OpenGLUnpackCompressedBlockSize = 0x912a;
auto constexpr OpenGLUnpackCompressedBlockWidth = 0x9127;
auto constexpr OpenGLUnpackImageHeight = 0x806e;
auto constexpr OpenGLUnpackLSBFirst = 0x0cf1;
auto constexpr OpenGLUnpackRowLength = 0x0cf2;
auto constexpr OpenGLUnpackSkipImages = 0x806d;
auto constexpr OpenGLUnpackSkipPixels = 0x0cf4;
auto constexpr OpenGLUnpackSkipRows = 0x0cf3;
auto constexpr OpenGLUnpackSwapBytes = 0x0cf0;
auto constexpr OpenGLUnsignaled = 0x9118;
auto constexpr OpenGLUnsignedByte = 0x1401;
auto constexpr OpenGLUnsignedByte233Rev = 0x8362;
auto constexpr OpenGLUnsignedByte332 = 0x8032;
auto constexpr OpenGLUnsignedInt = 0x1405;
auto constexpr OpenGLUnsignedInt1010102 = 0x8036;
auto constexpr OpenGLUnsignedInt10f11f11fRev = 0x8c3b;
auto constexpr OpenGLUnsignedInt2101010Rev = 0x8368;
auto constexpr OpenGLUnsignedInt248 = 0x84fa;
auto constexpr OpenGLUnsignedInt5999Rev = 0x8c3e;
auto constexpr OpenGLUnsignedInt8888 = 0x8035;
auto constexpr OpenGLUnsignedInt8888Rev = 0x8367;
auto constexpr OpenGLUnsignedIntAtomicCounter = 0x92db;
auto constexpr OpenGLUnsignedIntImage1d = 0x9062;
auto constexpr OpenGLUnsignedIntImage1dArray = 0x9068;
auto constexpr OpenGLUnsignedIntImage2d = 0x9063;
auto constexpr OpenGLUnsignedIntImage2dArray = 0x9069;
auto constexpr OpenGLUnsignedIntImage2dMultisample = 0x906b;
auto constexpr OpenGLUnsignedIntImage2dMultisampleArray = 0x906c;
auto constexpr OpenGLUnsignedIntImage2dRect = 0x9065;
auto constexpr OpenGLUnsignedIntImage3d = 0x9064;
auto constexpr OpenGLUnsignedIntImageBuffer = 0x9067;
auto constexpr OpenGLUnsignedIntImageCube = 0x9066;
auto constexpr OpenGLUnsignedIntImageCubeMapArray = 0x906a;
auto constexpr OpenGLUnsignedIntSampler1d = 0x8dd1;
auto constexpr OpenGLUnsignedIntSampler1dArray = 0x8dd6;
auto constexpr OpenGLUnsignedIntSampler2d = 0x8dd2;
auto constexpr OpenGLUnsignedIntSampler2dArray = 0x8dd7;
auto constexpr OpenGLUnsignedIntSampler2dMultisample = 0x910a;
auto constexpr OpenGLUnsignedIntSampler2dMultisampleArray = 0x910d;
auto constexpr OpenGLUnsignedIntSampler2dRect = 0x8dd5;
auto constexpr OpenGLUnsignedIntSampler3d = 0x8dd3;
auto constexpr OpenGLUnsignedIntSamplerBuffer = 0x8dd8;
auto constexpr OpenGLUnsignedIntSamplerCube = 0x8dd4;
auto constexpr OpenGLUnsignedIntSamplerCubeMapArray = 0x900f;
auto constexpr OpenGLUnsignedIntVec2 = 0x8dc6;
auto constexpr OpenGLUnsignedIntVec3 = 0x8dc7;
auto constexpr OpenGLUnsignedIntVec4 = 0x8dc8;
auto constexpr OpenGLUnsignedNormalized = 0x8c17;
auto constexpr OpenGLUnsignedShort = 0x1403;
auto constexpr OpenGLUnsignedShort1555Rev = 0x8366;
auto constexpr OpenGLUnsignedShort4444 = 0x8033;
auto constexpr OpenGLUnsignedShort4444Rev = 0x8365;
auto constexpr OpenGLUnsignedShort5551 = 0x8034;
auto constexpr OpenGLUnsignedShort565 = 0x8363;
auto constexpr OpenGLUnsignedShort565Rev = 0x8364;
auto constexpr OpenGLUpperLeft = 0x8ca2;
auto constexpr OpenGLV2f = 0x2a20;
auto constexpr OpenGLV3f = 0x2a21;
auto constexpr OpenGLValidateStatus = 0x8b83;
auto constexpr OpenGLVendor = 0x1f00;
auto constexpr OpenGLVersion = 0x1f02;
auto constexpr OpenGLVertexArray = 0x8074;
auto constexpr OpenGLVertexArrayBinding = 0x85b5;
auto constexpr OpenGLVertexArrayBufferBinding = 0x8896;
auto constexpr OpenGLVertexArrayPointer = 0x808e;
auto constexpr OpenGLVertexArraySize = 0x807a;
auto constexpr OpenGLVertexArrayStride = 0x807c;
auto constexpr OpenGLVertexArrayType = 0x807b;
auto constexpr OpenGLVertexAttribArrayBarrierBit = 0x00000001;
auto constexpr OpenGLVertexAttribArrayBufferBinding = 0x889f;
auto constexpr OpenGLVertexAttribArrayDivisor = 0x88fe;
auto constexpr OpenGLVertexAttribArrayEnabled = 0x8622;
auto constexpr OpenGLVertexAttribArrayInteger = 0x88fd;
auto constexpr OpenGLVertexAttribArrayLong = 0x874e;
auto constexpr OpenGLVertexAttribArrayNormalized = 0x886a;
auto constexpr OpenGLVertexAttribArrayPointer = 0x8645;
auto constexpr OpenGLVertexAttribArraySize = 0x8623;
auto constexpr OpenGLVertexAttribArrayStride = 0x8624;
auto constexpr OpenGLVertexAttribArrayType = 0x8625;
auto constexpr OpenGLVertexAttribBinding = 0x82d4;
auto constexpr OpenGLVertexAttribRelativeOffset = 0x82d5;
auto constexpr OpenGLVertexBindingBuffer = 0x8f4f;
auto constexpr OpenGLVertexBindingDivisor = 0x82d6;
auto constexpr OpenGLVertexBindingOffset = 0x82d7;
auto constexpr OpenGLVertexBindingStride = 0x82d8;
auto constexpr OpenGLVertexProgramPointSize = 0x8642;
auto constexpr OpenGLVertexProgramTwoSide = 0x8643;
auto constexpr OpenGLVertexShader = 0x8b31;
auto constexpr OpenGLVertexShaderBit = 0x00000001;
auto constexpr OpenGLVertexShaderInvocations = 0x82f0;
auto constexpr OpenGLVertexSubroutine = 0x92e8;
auto constexpr OpenGLVertexSubroutineUniform = 0x92ee;
auto constexpr OpenGLVertexTexture = 0x829b;
auto constexpr OpenGLVerticesSubmitted = 0x82ee;
auto constexpr OpenGLViewClass128Bits = 0x82c4;
auto constexpr OpenGLViewClass16Bits = 0x82ca;
auto constexpr OpenGLViewClass24Bits = 0x82c9;
auto constexpr OpenGLViewClass32Bits = 0x82c8;
auto constexpr OpenGLViewClass48Bits = 0x82c7;
auto constexpr OpenGLViewClass64Bits = 0x82c6;
auto constexpr OpenGLViewClass8Bits = 0x82cb;
auto constexpr OpenGLViewClass96Bits = 0x82c5;
auto constexpr OpenGLViewClassBptcFloat = 0x82d3;
auto constexpr OpenGLViewClassBptcUnorm = 0x82d2;
auto constexpr OpenGLViewClassRgtc1Red = 0x82d0;
auto constexpr OpenGLViewClassRgtc2Rg = 0x82d1;
auto constexpr OpenGLViewClassS3tcDxt1RGBA = 0x82cd;
auto constexpr OpenGLViewClassS3tcDxt1Rgb = 0x82cc;
auto constexpr OpenGLViewClassS3tcDxt3RGBA = 0x82ce;
auto constexpr OpenGLViewClassS3tcDxt5RGBA = 0x82cf;
auto constexpr OpenGLViewCompatibilityClass = 0x82b6;
auto constexpr OpenGLViewport = 0x0ba2;
auto constexpr OpenGLViewportBit = 0x00000800;
auto constexpr OpenGLViewportBoundsRange = 0x825d;
auto constexpr OpenGLViewportIndexProvokingVertex = 0x825f;
auto constexpr OpenGLViewportSubpixelBits = 0x825c;
auto constexpr OpenGLWaitFailed = 0x911d;
auto constexpr OpenGLWeightArrayBufferBinding = 0x889e;
auto constexpr OpenGLWriteOnly = 0x88b9;
auto constexpr OpenGLXor = 0x1506;
auto constexpr OpenGLZeroToOne = 0x935f;
auto constexpr OpenGLZoomX = 0x0d16;
auto constexpr OpenGLZoomY = 0x0d17;

} /* namespace boom */