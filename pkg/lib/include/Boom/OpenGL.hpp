#pragma once

#include <optional>
#include <Boom/Memory.hpp>

namespace boom {

struct __OpenGLImpl;

class Window;
class OpenGL;

struct OpenGLOptions {
    std::optional<std::shared_ptr<boom::OpenGL>> shared;
    std::optional<std::shared_ptr<boom::Window>> window;
    std::optional<std::int32_t> majorVersion;
    std::optional<std::int32_t> minorVersion;
};

class OpenGL final : public boom::Shared {
public:
    OpenGL(boom::OpenGLOptions const& = {});
    void cullFace(std::uint32_t mode);
    void frontFace(std::uint32_t mode);
    void hint(std::uint32_t target, std::uint32_t mode);
    void lineWidth(float width);
    void pointSize(float size);
    void polygonMode(std::uint32_t face, std::uint32_t mode);
    void scissor(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void texParameterf(std::uint32_t target, std::uint32_t pname, float param);
    void texParameterfv(std::uint32_t target, std::uint32_t pname, float const* params);
    void texParameteri(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void texParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texImage1D(std::uint32_t target, std::int32_t level, std::int32_t internalformat, std::int32_t width, std::int32_t border, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texImage2D(std::uint32_t target, std::int32_t level, std::int32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t border, std::uint32_t format, std::uint32_t type, void const* pixels);
    void drawBuffer(std::uint32_t buf);
    void clear(std::uint32_t mask);
    void clearColor(float red, float green, float blue, float alpha);
    void clearStencil(std::int32_t s);
    void clearDepth(double depth);
    void stencilMask(std::uint32_t mask);
    void colorMask(std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha);
    void depthMask(std::uint8_t flag);
    void disable(std::uint32_t cap);
    void enable(std::uint32_t cap);
    void finish();
    void flush();
    void blendFunc(std::uint32_t sfactor, std::uint32_t dfactor);
    void logicOp(std::uint32_t opcode);
    void stencilFunc(std::uint32_t func, std::int32_t ref, std::uint32_t mask);
    void stencilOp(std::uint32_t fail, std::uint32_t zfail, std::uint32_t zpass);
    void depthFunc(std::uint32_t func);
    void pixelStoref(std::uint32_t pname, float param);
    void pixelStorei(std::uint32_t pname, std::int32_t param);
    void readBuffer(std::uint32_t src);
    void readPixels(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void* pixels);
    void getBooleanv(std::uint32_t pname, std::uint8_t* data);
    void getDoublev(std::uint32_t pname, double* data);
    void getFloatv(std::uint32_t pname, float* data);
    void getIntegerv(std::uint32_t pname, std::int32_t* data);
    void getTexImage(std::uint32_t target, std::int32_t level, std::uint32_t format, std::uint32_t type, void* pixels);
    void getTexParameterfv(std::uint32_t target, std::uint32_t pname, float* params);
    void getTexParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTexLevelParameterfv(std::uint32_t target, std::int32_t level, std::uint32_t pname, float* params);
    void getTexLevelParameteriv(std::uint32_t target, std::int32_t level, std::uint32_t pname, std::int32_t* params);
    void depthRange(double n, double f);
    void viewport(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void drawArrays(std::uint32_t mode, std::int32_t first, std::int32_t count);
    void drawElements(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices);
    void polygonOffset(float factor, float units);
    void copyTexImage1D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t border);
    void copyTexImage2D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::int32_t border);
    void copyTexSubImage1D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t x, std::int32_t y, std::int32_t width);
    void copyTexSubImage2D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void texSubImage1D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texSubImage2D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void const* pixels);
    void bindTexture(std::uint32_t target, std::uint32_t texture);
    void deleteTextures(std::int32_t n, std::uint32_t const* textures);
    void genTextures(std::int32_t n, std::uint32_t* textures);
    void drawRangeElements(std::uint32_t mode, std::uint32_t start, std::uint32_t end, std::int32_t count, std::uint32_t type, void const* indices);
    void texImage3D(std::uint32_t target, std::int32_t level, std::int32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::int32_t border, std::uint32_t format, std::uint32_t type, void const* pixels);
    void texSubImage3D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, void const* pixels);
    void copyTexSubImage3D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void activeTexture(std::uint32_t texture);
    void sampleCoverage(float value, std::uint8_t invert);
    void compressedTexImage3D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::int32_t border, std::int32_t imageSize, void const* data);
    void compressedTexImage2D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t border, std::int32_t imageSize, void const* data);
    void compressedTexImage1D(std::uint32_t target, std::int32_t level, std::uint32_t internalformat, std::int32_t width, std::int32_t border, std::int32_t imageSize, void const* data);
    void compressedTexSubImage3D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTexSubImage2D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTexSubImage1D(std::uint32_t target, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::int32_t imageSize, void const* data);
    void getCompressedTexImage(std::uint32_t target, std::int32_t level, void* img);
    void blendFuncSeparate(std::uint32_t sfactorRGB, std::uint32_t dfactorRGB, std::uint32_t sfactorAlpha, std::uint32_t dfactorAlpha);
    void multiDrawArrays(std::uint32_t mode, std::int32_t const* first, std::int32_t const* count, std::int32_t drawcount);
    void multiDrawElements(std::uint32_t mode, std::int32_t const* count, std::uint32_t type, void const* const* indices, std::int32_t drawcount);
    void pointParameterf(std::uint32_t pname, float param);
    void pointParameterfv(std::uint32_t pname, float const* params);
    void pointParameteri(std::uint32_t pname, std::int32_t param);
    void pointParameteriv(std::uint32_t pname, std::int32_t const* params);
    void blendColor(float red, float green, float blue, float alpha);
    void blendEquation(std::uint32_t mode);
    void genQueries(std::int32_t n, std::uint32_t* ids);
    void deleteQueries(std::int32_t n, std::uint32_t const* ids);
    void beginQuery(std::uint32_t target, std::uint32_t id);
    void endQuery(std::uint32_t target);
    void getQueryiv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getQueryObjectiv(std::uint32_t id, std::uint32_t pname, std::int32_t* params);
    void getQueryObjectuiv(std::uint32_t id, std::uint32_t pname, std::uint32_t* params);
    void bindBuffer(std::uint32_t target, std::uint32_t buffer);
    void deleteBuffers(std::int32_t n, std::uint32_t const* buffers);
    void genBuffers(std::int32_t n, std::uint32_t* buffers);
    void bufferData(std::uint32_t target, std::int64_t size, void const* data, std::uint32_t usage);
    void bufferSubData(std::uint32_t target, std::intptr_t offset, std::int64_t size, void const* data);
    void getBufferSubData(std::uint32_t target, std::intptr_t offset, std::int64_t size, void* data);
    void getBufferParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getBufferPointerv(std::uint32_t target, std::uint32_t pname, void** params);
    void blendEquationSeparate(std::uint32_t modeRGB, std::uint32_t modeAlpha);
    void drawBuffers(std::int32_t n, std::uint32_t const* bufs);
    void stencilOpSeparate(std::uint32_t face, std::uint32_t sfail, std::uint32_t dpfail, std::uint32_t dppass);
    void stencilFuncSeparate(std::uint32_t face, std::uint32_t func, std::int32_t ref, std::uint32_t mask);
    void stencilMaskSeparate(std::uint32_t face, std::uint32_t mask);
    void attachShader(std::uint32_t program, std::uint32_t shader);
    void bindAttribLocation(std::uint32_t program, std::uint32_t index, char const* name);
    void compileShader(std::uint32_t shader);
    void deleteProgram(std::uint32_t program);
    void deleteShader(std::uint32_t shader);
    void detachShader(std::uint32_t program, std::uint32_t shader);
    void disableVertexAttribArray(std::uint32_t index);
    void enableVertexAttribArray(std::uint32_t index);
    void getActiveAttrib(std::uint32_t program, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, std::int32_t* size, std::uint32_t* type, char* name);
    void getActiveUniform(std::uint32_t program, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, std::int32_t* size, std::uint32_t* type, char* name);
    void getAttachedShaders(std::uint32_t program, std::int32_t maxCount, std::int32_t* count, std::uint32_t* shaders);
    void getProgramiv(std::uint32_t program, std::uint32_t pname, std::int32_t* params);
    void getProgramInfoLog(std::uint32_t program, std::int32_t bufSize, std::int32_t* length, char* infoLog);
    void getShaderiv(std::uint32_t shader, std::uint32_t pname, std::int32_t* params);
    void getShaderInfoLog(std::uint32_t shader, std::int32_t bufSize, std::int32_t* length, char* infoLog);
    void getShaderSource(std::uint32_t shader, std::int32_t bufSize, std::int32_t* length, char* source);
    void getUniformfv(std::uint32_t program, std::int32_t location, float* params);
    void getUniformiv(std::uint32_t program, std::int32_t location, std::int32_t* params);
    void getVertexAttribdv(std::uint32_t index, std::uint32_t pname, double* params);
    void getVertexAttribfv(std::uint32_t index, std::uint32_t pname, float* params);
    void getVertexAttribiv(std::uint32_t index, std::uint32_t pname, std::int32_t* params);
    void getVertexAttribPointerv(std::uint32_t index, std::uint32_t pname, void** pointer);
    void linkProgram(std::uint32_t program);
    void shaderSource(std::uint32_t shader, std::int32_t count, char const** string, std::int32_t const* length);
    void useProgram(std::uint32_t program);
    void uniform1f(std::int32_t location, float v0);
    void uniform2f(std::int32_t location, float v0, float v1);
    void uniform3f(std::int32_t location, float v0, float v1, float v2);
    void uniform4f(std::int32_t location, float v0, float v1, float v2, float v3);
    void uniform1i(std::int32_t location, std::int32_t v0);
    void uniform2i(std::int32_t location, std::int32_t v0, std::int32_t v1);
    void uniform3i(std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2);
    void uniform4i(std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2, std::int32_t v3);
    void uniform1fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform2fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform3fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform4fv(std::int32_t location, std::int32_t count, float const* value);
    void uniform1iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform2iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform3iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniform4iv(std::int32_t location, std::int32_t count, std::int32_t const* value);
    void uniformMatrix2fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix3fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix4fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void validateProgram(std::uint32_t program);
    void vertexAttrib1d(std::uint32_t index, double x);
    void vertexAttrib1dv(std::uint32_t index, double const* v);
    void vertexAttrib1f(std::uint32_t index, float x);
    void vertexAttrib1fv(std::uint32_t index, float const* v);
    void vertexAttrib1s(std::uint32_t index, std::int16_t x);
    void vertexAttrib1sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib2d(std::uint32_t index, double x, double y);
    void vertexAttrib2dv(std::uint32_t index, double const* v);
    void vertexAttrib2f(std::uint32_t index, float x, float y);
    void vertexAttrib2fv(std::uint32_t index, float const* v);
    void vertexAttrib2s(std::uint32_t index, std::int16_t x, std::int16_t y);
    void vertexAttrib2sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib3d(std::uint32_t index, double x, double y, double z);
    void vertexAttrib3dv(std::uint32_t index, double const* v);
    void vertexAttrib3f(std::uint32_t index, float x, float y, float z);
    void vertexAttrib3fv(std::uint32_t index, float const* v);
    void vertexAttrib3s(std::uint32_t index, std::int16_t x, std::int16_t y, std::int16_t z);
    void vertexAttrib3sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib4Nbv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4Niv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4Nsv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib4Nub(std::uint32_t index, std::uint8_t x, std::uint8_t y, std::uint8_t z, std::uint8_t w);
    void vertexAttrib4Nubv(std::uint32_t index, std::uint8_t const* v);
    void vertexAttrib4Nuiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttrib4Nusv(std::uint32_t index, std::uint16_t const* v);
    void vertexAttrib4bv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4d(std::uint32_t index, double x, double y, double z, double w);
    void vertexAttrib4dv(std::uint32_t index, double const* v);
    void vertexAttrib4f(std::uint32_t index, float x, float y, float z, float w);
    void vertexAttrib4fv(std::uint32_t index, float const* v);
    void vertexAttrib4iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttrib4s(std::uint32_t index, std::int16_t x, std::int16_t y, std::int16_t z, std::int16_t w);
    void vertexAttrib4sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttrib4ubv(std::uint32_t index, std::uint8_t const* v);
    void vertexAttrib4uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttrib4usv(std::uint32_t index, std::uint16_t const* v);
    void vertexAttribPointer(std::uint32_t index, std::int32_t size, std::uint32_t type, std::uint8_t normalized, std::int32_t stride, void const* pointer);
    void uniformMatrix2x3fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix3x2fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix2x4fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix4x2fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix3x4fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void uniformMatrix4x3fv(std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void colorMaski(std::uint32_t index, std::uint8_t r, std::uint8_t g, std::uint8_t b, std::uint8_t a);
    void getBooleani_v(std::uint32_t target, std::uint32_t index, std::uint8_t* data);
    void getIntegeri_v(std::uint32_t target, std::uint32_t index, std::int32_t* data);
    void enablei(std::uint32_t target, std::uint32_t index);
    void disablei(std::uint32_t target, std::uint32_t index);
    void beginTransformFeedback(std::uint32_t primitiveMode);
    void endTransformFeedback();
    void bindBufferRange(std::uint32_t target, std::uint32_t index, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void bindBufferBase(std::uint32_t target, std::uint32_t index, std::uint32_t buffer);
    void transformFeedbackVaryings(std::uint32_t program, std::int32_t count, char const* const* varyings, std::uint32_t bufferMode);
    void getTransformFeedbackVarying(std::uint32_t program, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, std::int32_t* size, std::uint32_t* type, char* name);
    void clampColor(std::uint32_t target, std::uint32_t clamp);
    void beginConditionalRender(std::uint32_t id, std::uint32_t mode);
    void endConditionalRender();
    void vertexAttribIPointer(std::uint32_t index, std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void getVertexAttribIiv(std::uint32_t index, std::uint32_t pname, std::int32_t* params);
    void getVertexAttribIuiv(std::uint32_t index, std::uint32_t pname, std::uint32_t* params);
    void vertexAttribI1i(std::uint32_t index, std::int32_t x);
    void vertexAttribI2i(std::uint32_t index, std::int32_t x, std::int32_t y);
    void vertexAttribI3i(std::uint32_t index, std::int32_t x, std::int32_t y, std::int32_t z);
    void vertexAttribI4i(std::uint32_t index, std::int32_t x, std::int32_t y, std::int32_t z, std::int32_t w);
    void vertexAttribI1ui(std::uint32_t index, std::uint32_t x);
    void vertexAttribI2ui(std::uint32_t index, std::uint32_t x, std::uint32_t y);
    void vertexAttribI3ui(std::uint32_t index, std::uint32_t x, std::uint32_t y, std::uint32_t z);
    void vertexAttribI4ui(std::uint32_t index, std::uint32_t x, std::uint32_t y, std::uint32_t z, std::uint32_t w);
    void vertexAttribI1iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI2iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI3iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI4iv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI1uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI2uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI3uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI4uiv(std::uint32_t index, std::uint32_t const* v);
    void vertexAttribI4bv(std::uint32_t index, std::int32_t const* v);
    void vertexAttribI4sv(std::uint32_t index, std::int16_t const* v);
    void vertexAttribI4ubv(std::uint32_t index, std::uint8_t const* v);
    void vertexAttribI4usv(std::uint32_t index, std::uint16_t const* v);
    void getUniformuiv(std::uint32_t program, std::int32_t location, std::uint32_t* params);
    void bindFragDataLocation(std::uint32_t program, std::uint32_t color, char const* name);
    void uniform1ui(std::int32_t location, std::uint32_t v0);
    void uniform2ui(std::int32_t location, std::uint32_t v0, std::uint32_t v1);
    void uniform3ui(std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2);
    void uniform4ui(std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2, std::uint32_t v3);
    void uniform1uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniform2uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniform3uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void uniform4uiv(std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void texParameterIiv(std::uint32_t target, std::uint32_t pname, std::int32_t const* params);
    void texParameterIuiv(std::uint32_t target, std::uint32_t pname, std::uint32_t const* params);
    void getTexParameterIiv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getTexParameterIuiv(std::uint32_t target, std::uint32_t pname, std::uint32_t* params);
    void clearBufferiv(std::uint32_t buffer, std::int32_t drawbuffer, std::int32_t const* value);
    void clearBufferuiv(std::uint32_t buffer, std::int32_t drawbuffer, std::uint32_t const* value);
    void clearBufferfv(std::uint32_t buffer, std::int32_t drawbuffer, float const* value);
    void clearBufferfi(std::uint32_t buffer, std::int32_t drawbuffer, float depth, std::int32_t stencil);
    void bindRenderbuffer(std::uint32_t target, std::uint32_t renderbuffer);
    void deleteRenderbuffers(std::int32_t n, std::uint32_t const* renderbuffers);
    void genRenderbuffers(std::int32_t n, std::uint32_t* renderbuffers);
    void renderbufferStorage(std::uint32_t target, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void getRenderbufferParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void bindFramebuffer(std::uint32_t target, std::uint32_t framebuffer);
    void deleteFramebuffers(std::int32_t n, std::uint32_t const* framebuffers);
    void genFramebuffers(std::int32_t n, std::uint32_t* framebuffers);
    void framebufferTexture1D(std::uint32_t target, std::uint32_t attachment, std::uint32_t textarget, std::uint32_t texture, std::int32_t level);
    void framebufferTexture2D(std::uint32_t target, std::uint32_t attachment, std::uint32_t textarget, std::uint32_t texture, std::int32_t level);
    void framebufferTexture3D(std::uint32_t target, std::uint32_t attachment, std::uint32_t textarget, std::uint32_t texture, std::int32_t level, std::int32_t zoffset);
    void framebufferRenderbuffer(std::uint32_t target, std::uint32_t attachment, std::uint32_t renderbuffertarget, std::uint32_t renderbuffer);
    void getFramebufferAttachmentParameteriv(std::uint32_t target, std::uint32_t attachment, std::uint32_t pname, std::int32_t* params);
    void generateMipmap(std::uint32_t target);
    void blitFramebuffer(std::int32_t srcX0, std::int32_t srcY0, std::int32_t srcX1, std::int32_t srcY1, std::int32_t dstX0, std::int32_t dstY0, std::int32_t dstX1, std::int32_t dstY1, std::uint32_t mask, std::uint32_t filter);
    void renderbufferStorageMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void framebufferTextureLayer(std::uint32_t target, std::uint32_t attachment, std::uint32_t texture, std::int32_t level, std::int32_t layer);
    void flushMappedBufferRange(std::uint32_t target, std::intptr_t offset, std::int64_t length);
    void bindVertexArray(std::uint32_t array);
    void deleteVertexArrays(std::int32_t n, std::uint32_t const* arrays);
    void genVertexArrays(std::int32_t n, std::uint32_t* arrays);
    void drawArraysInstanced(std::uint32_t mode, std::int32_t first, std::int32_t count, std::int32_t instancecount);
    void drawElementsInstanced(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount);
    void texBuffer(std::uint32_t target, std::uint32_t internalformat, std::uint32_t buffer);
    void primitiveRestartIndex(std::uint32_t index);
    void copyBufferSubData(std::uint32_t readTarget, std::uint32_t writeTarget, std::intptr_t readOffset, std::intptr_t writeOffset, std::int64_t size);
    void getUniformIndices(std::uint32_t program, std::int32_t uniformCount, char const* const* uniformNames, std::uint32_t* uniformIndices);
    void getActiveUniformsiv(std::uint32_t program, std::int32_t uniformCount, std::uint32_t const* uniformIndices, std::uint32_t pname, std::int32_t* params);
    void getActiveUniformName(std::uint32_t program, std::uint32_t uniformIndex, std::int32_t bufSize, std::int32_t* length, char* uniformName);
    void getActiveUniformBlockiv(std::uint32_t program, std::uint32_t uniformBlockIndex, std::uint32_t pname, std::int32_t* params);
    void getActiveUniformBlockName(std::uint32_t program, std::uint32_t uniformBlockIndex, std::int32_t bufSize, std::int32_t* length, char* uniformBlockName);
    void uniformBlockBinding(std::uint32_t program, std::uint32_t uniformBlockIndex, std::uint32_t uniformBlockBinding);
    void drawElementsBaseVertex(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t basevertex);
    void drawRangeElementsBaseVertex(std::uint32_t mode, std::uint32_t start, std::uint32_t end, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t basevertex);
    void drawElementsInstancedBaseVertex(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount, std::int32_t basevertex);
    void multiDrawElementsBaseVertex(std::uint32_t mode, std::int32_t const* count, std::uint32_t type, void const* const* indices, std::int32_t drawcount, std::int32_t const* basevertex);
    void provokingVertex(std::uint32_t mode);
    void deleteSync(void* sync);
    void waitSync(void* sync, std::uint32_t flags, std::uint64_t timeout);
    void getInteger64v(std::uint32_t pname, std::int64_t* data);
    void getSynciv(void* sync, std::uint32_t pname, std::int32_t count, std::int32_t* length, std::int32_t* values);
    void getInteger64i_v(std::uint32_t target, std::uint32_t index, std::int64_t* data);
    void getBufferParameteri64v(std::uint32_t target, std::uint32_t pname, std::int64_t* params);
    void framebufferTexture(std::uint32_t target, std::uint32_t attachment, std::uint32_t texture, std::int32_t level);
    void texImage2DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::uint8_t fixedsamplelocations);
    void texImage3DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint8_t fixedsamplelocations);
    void getMultisamplefv(std::uint32_t pname, std::uint32_t index, float* val);
    void sampleMaski(std::uint32_t maskNumber, std::uint32_t mask);
    void bindFragDataLocationIndexed(std::uint32_t program, std::uint32_t colorNumber, std::uint32_t index, char const* name);
    void genSamplers(std::int32_t count, std::uint32_t* samplers);
    void deleteSamplers(std::int32_t count, std::uint32_t const* samplers);
    void bindSampler(std::uint32_t unit, std::uint32_t sampler);
    void samplerParameteri(std::uint32_t sampler, std::uint32_t pname, std::int32_t param);
    void samplerParameteriv(std::uint32_t sampler, std::uint32_t pname, std::int32_t const* param);
    void samplerParameterf(std::uint32_t sampler, std::uint32_t pname, float param);
    void samplerParameterfv(std::uint32_t sampler, std::uint32_t pname, float const* param);
    void samplerParameterIiv(std::uint32_t sampler, std::uint32_t pname, std::int32_t const* param);
    void samplerParameterIuiv(std::uint32_t sampler, std::uint32_t pname, std::uint32_t const* param);
    void getSamplerParameteriv(std::uint32_t sampler, std::uint32_t pname, std::int32_t* params);
    void getSamplerParameterIiv(std::uint32_t sampler, std::uint32_t pname, std::int32_t* params);
    void getSamplerParameterfv(std::uint32_t sampler, std::uint32_t pname, float* params);
    void getSamplerParameterIuiv(std::uint32_t sampler, std::uint32_t pname, std::uint32_t* params);
    void queryCounter(std::uint32_t id, std::uint32_t target);
    void getQueryObjecti64v(std::uint32_t id, std::uint32_t pname, std::int64_t* params);
    void getQueryObjectui64v(std::uint32_t id, std::uint32_t pname, std::uint64_t* params);
    void vertexAttribDivisor(std::uint32_t index, std::uint32_t divisor);
    void vertexAttribP1ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP1uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribP2ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP2uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribP3ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP3uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexAttribP4ui(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t value);
    void vertexAttribP4uiv(std::uint32_t index, std::uint32_t type, std::uint8_t normalized, std::uint32_t const* value);
    void vertexP2ui(std::uint32_t type, std::uint32_t value);
    void vertexP2uiv(std::uint32_t type, std::uint32_t const* value);
    void vertexP3ui(std::uint32_t type, std::uint32_t value);
    void vertexP3uiv(std::uint32_t type, std::uint32_t const* value);
    void vertexP4ui(std::uint32_t type, std::uint32_t value);
    void vertexP4uiv(std::uint32_t type, std::uint32_t const* value);
    void texCoordP1ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP1uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordP2ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP2uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordP3ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP3uiv(std::uint32_t type, std::uint32_t const* coords);
    void texCoordP4ui(std::uint32_t type, std::uint32_t coords);
    void texCoordP4uiv(std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP1ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP1uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP2ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP2uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP3ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP3uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void multiTexCoordP4ui(std::uint32_t texture, std::uint32_t type, std::uint32_t coords);
    void multiTexCoordP4uiv(std::uint32_t texture, std::uint32_t type, std::uint32_t const* coords);
    void normalP3ui(std::uint32_t type, std::uint32_t coords);
    void normalP3uiv(std::uint32_t type, std::uint32_t const* coords);
    void colorP3ui(std::uint32_t type, std::uint32_t color);
    void colorP3uiv(std::uint32_t type, std::uint32_t const* color);
    void colorP4ui(std::uint32_t type, std::uint32_t color);
    void colorP4uiv(std::uint32_t type, std::uint32_t const* color);
    void secondaryColorP3ui(std::uint32_t type, std::uint32_t color);
    void secondaryColorP3uiv(std::uint32_t type, std::uint32_t const* color);
    void minSampleShading(float value);
    void blendEquationi(std::uint32_t buf, std::uint32_t mode);
    void blendEquationSeparatei(std::uint32_t buf, std::uint32_t modeRGB, std::uint32_t modeAlpha);
    void blendFunci(std::uint32_t buf, std::uint32_t src, std::uint32_t dst);
    void blendFuncSeparatei(std::uint32_t buf, std::uint32_t srcRGB, std::uint32_t dstRGB, std::uint32_t srcAlpha, std::uint32_t dstAlpha);
    void drawArraysIndirect(std::uint32_t mode, void const* indirect);
    void drawElementsIndirect(std::uint32_t mode, std::uint32_t type, void const* indirect);
    void uniform1d(std::int32_t location, double x);
    void uniform2d(std::int32_t location, double x, double y);
    void uniform3d(std::int32_t location, double x, double y, double z);
    void uniform4d(std::int32_t location, double x, double y, double z, double w);
    void uniform1dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform2dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform3dv(std::int32_t location, std::int32_t count, double const* value);
    void uniform4dv(std::int32_t location, std::int32_t count, double const* value);
    void uniformMatrix2dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix3dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix4dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix2x3dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix2x4dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix3x2dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix3x4dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix4x2dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void uniformMatrix4x3dv(std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void getUniformdv(std::uint32_t program, std::int32_t location, double* params);
    void getActiveSubroutineUniformiv(std::uint32_t program, std::uint32_t shadertype, std::uint32_t index, std::uint32_t pname, std::int32_t* values);
    void getActiveSubroutineUniformName(std::uint32_t program, std::uint32_t shadertype, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, char* name);
    void getActiveSubroutineName(std::uint32_t program, std::uint32_t shadertype, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, char* name);
    void uniformSubroutinesuiv(std::uint32_t shadertype, std::int32_t count, std::uint32_t const* indices);
    void getUniformSubroutineuiv(std::uint32_t shadertype, std::int32_t location, std::uint32_t* params);
    void getProgramStageiv(std::uint32_t program, std::uint32_t shadertype, std::uint32_t pname, std::int32_t* values);
    void patchParameteri(std::uint32_t pname, std::int32_t value);
    void patchParameterfv(std::uint32_t pname, float const* values);
    void bindTransformFeedback(std::uint32_t target, std::uint32_t id);
    void deleteTransformFeedbacks(std::int32_t n, std::uint32_t const* ids);
    void genTransformFeedbacks(std::int32_t n, std::uint32_t* ids);
    void pauseTransformFeedback();
    void resumeTransformFeedback();
    void drawTransformFeedback(std::uint32_t mode, std::uint32_t id);
    void drawTransformFeedbackStream(std::uint32_t mode, std::uint32_t id, std::uint32_t stream);
    void beginQueryIndexed(std::uint32_t target, std::uint32_t index, std::uint32_t id);
    void endQueryIndexed(std::uint32_t target, std::uint32_t index);
    void getQueryIndexediv(std::uint32_t target, std::uint32_t index, std::uint32_t pname, std::int32_t* params);
    void releaseShaderCompiler();
    void shaderBinary(std::int32_t count, std::uint32_t const* shaders, std::uint32_t binaryFormat, void const* binary, std::int32_t length);
    void getShaderPrecisionFormat(std::uint32_t shadertype, std::uint32_t precisiontype, std::int32_t* range, std::int32_t* precision);
    void depthRangef(float n, float f);
    void clearDepthf(float d);
    void getProgramBinary(std::uint32_t program, std::int32_t bufSize, std::int32_t* length, std::uint32_t* binaryFormat, void* binary);
    void programBinary(std::uint32_t program, std::uint32_t binaryFormat, void const* binary, std::int32_t length);
    void programParameteri(std::uint32_t program, std::uint32_t pname, std::int32_t value);
    void useProgramStages(std::uint32_t pipeline, std::uint32_t stages, std::uint32_t program);
    void activeShaderProgram(std::uint32_t pipeline, std::uint32_t program);
    void bindProgramPipeline(std::uint32_t pipeline);
    void deleteProgramPipelines(std::int32_t n, std::uint32_t const* pipelines);
    void genProgramPipelines(std::int32_t n, std::uint32_t* pipelines);
    void getProgramPipelineiv(std::uint32_t pipeline, std::uint32_t pname, std::int32_t* params);
    void programUniform1i(std::uint32_t program, std::int32_t location, std::int32_t v0);
    void programUniform1iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform1f(std::uint32_t program, std::int32_t location, float v0);
    void programUniform1fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform1d(std::uint32_t program, std::int32_t location, double v0);
    void programUniform1dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform1ui(std::uint32_t program, std::int32_t location, std::uint32_t v0);
    void programUniform1uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniform2i(std::uint32_t program, std::int32_t location, std::int32_t v0, std::int32_t v1);
    void programUniform2iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform2f(std::uint32_t program, std::int32_t location, float v0, float v1);
    void programUniform2fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform2d(std::uint32_t program, std::int32_t location, double v0, double v1);
    void programUniform2dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform2ui(std::uint32_t program, std::int32_t location, std::uint32_t v0, std::uint32_t v1);
    void programUniform2uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniform3i(std::uint32_t program, std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2);
    void programUniform3iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform3f(std::uint32_t program, std::int32_t location, float v0, float v1, float v2);
    void programUniform3fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform3d(std::uint32_t program, std::int32_t location, double v0, double v1, double v2);
    void programUniform3dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform3ui(std::uint32_t program, std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2);
    void programUniform3uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniform4i(std::uint32_t program, std::int32_t location, std::int32_t v0, std::int32_t v1, std::int32_t v2, std::int32_t v3);
    void programUniform4iv(std::uint32_t program, std::int32_t location, std::int32_t count, std::int32_t const* value);
    void programUniform4f(std::uint32_t program, std::int32_t location, float v0, float v1, float v2, float v3);
    void programUniform4fv(std::uint32_t program, std::int32_t location, std::int32_t count, float const* value);
    void programUniform4d(std::uint32_t program, std::int32_t location, double v0, double v1, double v2, double v3);
    void programUniform4dv(std::uint32_t program, std::int32_t location, std::int32_t count, double const* value);
    void programUniform4ui(std::uint32_t program, std::int32_t location, std::uint32_t v0, std::uint32_t v1, std::uint32_t v2, std::uint32_t v3);
    void programUniform4uiv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint32_t const* value);
    void programUniformMatrix2fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix3fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix4fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix2dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix3dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix4dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix2x3fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix3x2fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix2x4fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix4x2fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix3x4fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix4x3fv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, float const* value);
    void programUniformMatrix2x3dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix3x2dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix2x4dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix4x2dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix3x4dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void programUniformMatrix4x3dv(std::uint32_t program, std::int32_t location, std::int32_t count, std::uint8_t transpose, double const* value);
    void validateProgramPipeline(std::uint32_t pipeline);
    void getProgramPipelineInfoLog(std::uint32_t pipeline, std::int32_t bufSize, std::int32_t* length, char* infoLog);
    void vertexAttribL1d(std::uint32_t index, double x);
    void vertexAttribL2d(std::uint32_t index, double x, double y);
    void vertexAttribL3d(std::uint32_t index, double x, double y, double z);
    void vertexAttribL4d(std::uint32_t index, double x, double y, double z, double w);
    void vertexAttribL1dv(std::uint32_t index, double const* v);
    void vertexAttribL2dv(std::uint32_t index, double const* v);
    void vertexAttribL3dv(std::uint32_t index, double const* v);
    void vertexAttribL4dv(std::uint32_t index, double const* v);
    void vertexAttribLPointer(std::uint32_t index, std::int32_t size, std::uint32_t type, std::int32_t stride, void const* pointer);
    void getVertexAttribLdv(std::uint32_t index, std::uint32_t pname, double* params);
    void viewportArrayv(std::uint32_t first, std::int32_t count, float const* v);
    void viewportIndexedf(std::uint32_t index, float x, float y, float w, float h);
    void viewportIndexedfv(std::uint32_t index, float const* v);
    void scissorArrayv(std::uint32_t first, std::int32_t count, std::int32_t const* v);
    void scissorIndexed(std::uint32_t index, std::int32_t left, std::int32_t bottom, std::int32_t width, std::int32_t height);
    void scissorIndexedv(std::uint32_t index, std::int32_t const* v);
    void depthRangeArrayv(std::uint32_t first, std::int32_t count, double const* v);
    void depthRangeIndexed(std::uint32_t index, double n, double f);
    void getFloati_v(std::uint32_t target, std::uint32_t index, float* data);
    void getDoublei_v(std::uint32_t target, std::uint32_t index, double* data);
    void drawArraysInstancedBaseInstance(std::uint32_t mode, std::int32_t first, std::int32_t count, std::int32_t instancecount, std::uint32_t baseinstance);
    void drawElementsInstancedBaseInstance(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount, std::uint32_t baseinstance);
    void drawElementsInstancedBaseVertexBaseInstance(std::uint32_t mode, std::int32_t count, std::uint32_t type, void const* indices, std::int32_t instancecount, std::int32_t basevertex, std::uint32_t baseinstance);
    void getInternalformativ(std::uint32_t target, std::uint32_t internalformat, std::uint32_t pname, std::int32_t count, std::int32_t* params);
    void getActiveAtomicCounterBufferiv(std::uint32_t program, std::uint32_t bufferIndex, std::uint32_t pname, std::int32_t* params);
    void bindImageTexture(std::uint32_t unit, std::uint32_t texture, std::int32_t level, std::uint8_t layered, std::int32_t layer, std::uint32_t access, std::uint32_t format);
    void memoryBarrier(std::uint32_t barriers);
    void texStorage1D(std::uint32_t target, std::int32_t levels, std::uint32_t internalformat, std::int32_t width);
    void texStorage2D(std::uint32_t target, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void texStorage3D(std::uint32_t target, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth);
    void drawTransformFeedbackInstanced(std::uint32_t mode, std::uint32_t id, std::int32_t instancecount);
    void drawTransformFeedbackStreamInstanced(std::uint32_t mode, std::uint32_t id, std::uint32_t stream, std::int32_t instancecount);
    void clearBufferData(std::uint32_t target, std::uint32_t internalformat, std::uint32_t format, std::uint32_t type, void const* data);
    void clearBufferSubData(std::uint32_t target, std::uint32_t internalformat, std::intptr_t offset, std::int64_t size, std::uint32_t format, std::uint32_t type, void const* data);
    void dispatchCompute(std::uint32_t num_groups_x, std::uint32_t num_groups_y, std::uint32_t num_groups_z);
    void dispatchComputeIndirect(std::intptr_t indirect);
    void copyImageSubData(std::uint32_t srcName, std::uint32_t srcTarget, std::int32_t srcLevel, std::int32_t srcX, std::int32_t srcY, std::int32_t srcZ, std::uint32_t dstName, std::uint32_t dstTarget, std::int32_t dstLevel, std::int32_t dstX, std::int32_t dstY, std::int32_t dstZ, std::int32_t srcWidth, std::int32_t srcHeight, std::int32_t srcDepth);
    void framebufferParameteri(std::uint32_t target, std::uint32_t pname, std::int32_t param);
    void getFramebufferParameteriv(std::uint32_t target, std::uint32_t pname, std::int32_t* params);
    void getInternalformati64v(std::uint32_t target, std::uint32_t internalformat, std::uint32_t pname, std::int32_t count, std::int64_t* params);
    void invalidateTexSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth);
    void invalidateTexImage(std::uint32_t texture, std::int32_t level);
    void invalidateBufferSubData(std::uint32_t buffer, std::intptr_t offset, std::int64_t length);
    void invalidateBufferData(std::uint32_t buffer);
    void invalidateFramebuffer(std::uint32_t target, std::int32_t numAttachments, std::uint32_t const* attachments);
    void invalidateSubFramebuffer(std::uint32_t target, std::int32_t numAttachments, std::uint32_t const* attachments, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void multiDrawArraysIndirect(std::uint32_t mode, void const* indirect, std::int32_t drawcount, std::int32_t stride);
    void multiDrawElementsIndirect(std::uint32_t mode, std::uint32_t type, void const* indirect, std::int32_t drawcount, std::int32_t stride);
    void getProgramInterfaceiv(std::uint32_t program, std::uint32_t programInterface, std::uint32_t pname, std::int32_t* params);
    void getProgramResourceName(std::uint32_t program, std::uint32_t programInterface, std::uint32_t index, std::int32_t bufSize, std::int32_t* length, char* name);
    void getProgramResourceiv(std::uint32_t program, std::uint32_t programInterface, std::uint32_t index, std::int32_t propCount, std::uint32_t const* props, std::int32_t count, std::int32_t* length, std::int32_t* params);
    void shaderStorageBlockBinding(std::uint32_t program, std::uint32_t storageBlockIndex, std::uint32_t storageBlockBinding);
    void texBufferRange(std::uint32_t target, std::uint32_t internalformat, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void texStorage2DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::uint8_t fixedsamplelocations);
    void texStorage3DMultisample(std::uint32_t target, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint8_t fixedsamplelocations);
    void textureView(std::uint32_t texture, std::uint32_t target, std::uint32_t origtexture, std::uint32_t internalformat, std::uint32_t minlevel, std::uint32_t numlevels, std::uint32_t minlayer, std::uint32_t numlayers);
    void bindVertexBuffer(std::uint32_t bindingindex, std::uint32_t buffer, std::intptr_t offset, std::int32_t stride);
    void vertexAttribFormat(std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint8_t normalized, std::uint32_t relativeoffset);
    void vertexAttribIFormat(std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexAttribLFormat(std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexAttribBinding(std::uint32_t attribindex, std::uint32_t bindingindex);
    void vertexBindingDivisor(std::uint32_t bindingindex, std::uint32_t divisor);
    void debugMessageControl(std::uint32_t source, std::uint32_t type, std::uint32_t severity, std::int32_t count, std::uint32_t const* ids, std::uint8_t enabled);
    void debugMessageInsert(std::uint32_t source, std::uint32_t type, std::uint32_t id, std::uint32_t severity, std::int32_t length, char const* buf);
    void debugMessageCallback(void* callback, void const* userParam);
    void pushDebugGroup(std::uint32_t source, std::uint32_t id, std::int32_t length, char const* message);
    void popDebugGroup();
    void objectLabel(std::uint32_t identifier, std::uint32_t name, std::int32_t length, char const* label);
    void getObjectLabel(std::uint32_t identifier, std::uint32_t name, std::int32_t bufSize, std::int32_t* length, char* label);
    void objectPtrLabel(void const* ptr, std::int32_t length, char const* label);
    void getObjectPtrLabel(void const* ptr, std::int32_t bufSize, std::int32_t* length, char* label);
    void getPointerv(std::uint32_t pname, void** params);
    void bufferStorage(std::uint32_t target, std::int64_t size, void const* data, std::uint32_t flags);
    void clearTexImage(std::uint32_t texture, std::int32_t level, std::uint32_t format, std::uint32_t type, void const* data);
    void clearTexSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, void const* data);
    void bindBuffersBase(std::uint32_t target, std::uint32_t first, std::int32_t count, std::uint32_t const* buffers);
    void bindBuffersRange(std::uint32_t target, std::uint32_t first, std::int32_t count, std::uint32_t const* buffers, std::intptr_t const* offsets, std::int64_t const* sizes);
    void bindTextures(std::uint32_t first, std::int32_t count, std::uint32_t const* textures);
    void bindSamplers(std::uint32_t first, std::int32_t count, std::uint32_t const* samplers);
    void bindImageTextures(std::uint32_t first, std::int32_t count, std::uint32_t const* textures);
    void bindVertexBuffers(std::uint32_t first, std::int32_t count, std::uint32_t const* buffers, std::intptr_t const* offsets, std::int32_t const* strides);
    void clipControl(std::uint32_t origin, std::uint32_t depth);
    void createTransformFeedbacks(std::int32_t n, std::uint32_t* ids);
    void transformFeedbackBufferBase(std::uint32_t xfb, std::uint32_t index, std::uint32_t buffer);
    void transformFeedbackBufferRange(std::uint32_t xfb, std::uint32_t index, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void getTransformFeedbackiv(std::uint32_t xfb, std::uint32_t pname, std::int32_t* param);
    void getTransformFeedbacki_v(std::uint32_t xfb, std::uint32_t pname, std::uint32_t index, std::int32_t* param);
    void getTransformFeedbacki64_v(std::uint32_t xfb, std::uint32_t pname, std::uint32_t index, std::int64_t* param);
    void createBuffers(std::int32_t n, std::uint32_t* buffers);
    void namedBufferStorage(std::uint32_t buffer, std::int64_t size, void const* data, std::uint32_t flags);
    void namedBufferData(std::uint32_t buffer, std::int64_t size, void const* data, std::uint32_t usage);
    void namedBufferSubData(std::uint32_t buffer, std::intptr_t offset, std::int64_t size, void const* data);
    void copyNamedBufferSubData(std::uint32_t readBuffer, std::uint32_t writeBuffer, std::intptr_t readOffset, std::intptr_t writeOffset, std::int64_t size);
    void clearNamedBufferData(std::uint32_t buffer, std::uint32_t internalformat, std::uint32_t format, std::uint32_t type, void const* data);
    void clearNamedBufferSubData(std::uint32_t buffer, std::uint32_t internalformat, std::intptr_t offset, std::int64_t size, std::uint32_t format, std::uint32_t type, void const* data);
    void flushMappedNamedBufferRange(std::uint32_t buffer, std::intptr_t offset, std::int64_t length);
    void getNamedBufferParameteriv(std::uint32_t buffer, std::uint32_t pname, std::int32_t* params);
    void getNamedBufferParameteri64v(std::uint32_t buffer, std::uint32_t pname, std::int64_t* params);
    void getNamedBufferPointerv(std::uint32_t buffer, std::uint32_t pname, void** params);
    void getNamedBufferSubData(std::uint32_t buffer, std::intptr_t offset, std::int64_t size, void* data);
    void createFramebuffers(std::int32_t n, std::uint32_t* framebuffers);
    void namedFramebufferRenderbuffer(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t renderbuffertarget, std::uint32_t renderbuffer);
    void namedFramebufferParameteri(std::uint32_t framebuffer, std::uint32_t pname, std::int32_t param);
    void namedFramebufferTexture(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t texture, std::int32_t level);
    void namedFramebufferTextureLayer(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t texture, std::int32_t level, std::int32_t layer);
    void namedFramebufferDrawBuffer(std::uint32_t framebuffer, std::uint32_t buf);
    void namedFramebufferDrawBuffers(std::uint32_t framebuffer, std::int32_t n, std::uint32_t const* bufs);
    void namedFramebufferReadBuffer(std::uint32_t framebuffer, std::uint32_t src);
    void invalidateNamedFramebufferData(std::uint32_t framebuffer, std::int32_t numAttachments, std::uint32_t const* attachments);
    void invalidateNamedFramebufferSubData(std::uint32_t framebuffer, std::int32_t numAttachments, std::uint32_t const* attachments, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void clearNamedFramebufferiv(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, std::int32_t const* value);
    void clearNamedFramebufferuiv(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, std::uint32_t const* value);
    void clearNamedFramebufferfv(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, float const* value);
    void clearNamedFramebufferfi(std::uint32_t framebuffer, std::uint32_t buffer, std::int32_t drawbuffer, float depth, std::int32_t stencil);
    void blitNamedFramebuffer(std::uint32_t readFramebuffer, std::uint32_t drawFramebuffer, std::int32_t srcX0, std::int32_t srcY0, std::int32_t srcX1, std::int32_t srcY1, std::int32_t dstX0, std::int32_t dstY0, std::int32_t dstX1, std::int32_t dstY1, std::uint32_t mask, std::uint32_t filter);
    void getNamedFramebufferParameteriv(std::uint32_t framebuffer, std::uint32_t pname, std::int32_t* param);
    void getNamedFramebufferAttachmentParameteriv(std::uint32_t framebuffer, std::uint32_t attachment, std::uint32_t pname, std::int32_t* params);
    void createRenderbuffers(std::int32_t n, std::uint32_t* renderbuffers);
    void namedRenderbufferStorage(std::uint32_t renderbuffer, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void namedRenderbufferStorageMultisample(std::uint32_t renderbuffer, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void getNamedRenderbufferParameteriv(std::uint32_t renderbuffer, std::uint32_t pname, std::int32_t* params);
    void createTextures(std::uint32_t target, std::int32_t n, std::uint32_t* textures);
    void textureBuffer(std::uint32_t texture, std::uint32_t internalformat, std::uint32_t buffer);
    void textureBufferRange(std::uint32_t texture, std::uint32_t internalformat, std::uint32_t buffer, std::intptr_t offset, std::int64_t size);
    void textureStorage1D(std::uint32_t texture, std::int32_t levels, std::uint32_t internalformat, std::int32_t width);
    void textureStorage2D(std::uint32_t texture, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height);
    void textureStorage3D(std::uint32_t texture, std::int32_t levels, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth);
    void textureStorage2DMultisample(std::uint32_t texture, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::uint8_t fixedsamplelocations);
    void textureStorage3DMultisample(std::uint32_t texture, std::int32_t samples, std::uint32_t internalformat, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint8_t fixedsamplelocations);
    void textureSubImage1D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::uint32_t type, void const* pixels);
    void textureSubImage2D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, void const* pixels);
    void textureSubImage3D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, void const* pixels);
    void compressedTextureSubImage1D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t width, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTextureSubImage2D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t width, std::int32_t height, std::uint32_t format, std::int32_t imageSize, void const* data);
    void compressedTextureSubImage3D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::int32_t imageSize, void const* data);
    void copyTextureSubImage1D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t x, std::int32_t y, std::int32_t width);
    void copyTextureSubImage2D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void copyTextureSubImage3D(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height);
    void textureParameterf(std::uint32_t texture, std::uint32_t pname, float param);
    void textureParameterfv(std::uint32_t texture, std::uint32_t pname, float const* param);
    void textureParameteri(std::uint32_t texture, std::uint32_t pname, std::int32_t param);
    void textureParameterIiv(std::uint32_t texture, std::uint32_t pname, std::int32_t const* params);
    void textureParameterIuiv(std::uint32_t texture, std::uint32_t pname, std::uint32_t const* params);
    void textureParameteriv(std::uint32_t texture, std::uint32_t pname, std::int32_t const* param);
    void generateTextureMipmap(std::uint32_t texture);
    void bindTextureUnit(std::uint32_t unit, std::uint32_t texture);
    void getTextureImage(std::uint32_t texture, std::int32_t level, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* pixels);
    void getCompressedTextureImage(std::uint32_t texture, std::int32_t level, std::int32_t bufSize, void* pixels);
    void getTextureLevelParameterfv(std::uint32_t texture, std::int32_t level, std::uint32_t pname, float* params);
    void getTextureLevelParameteriv(std::uint32_t texture, std::int32_t level, std::uint32_t pname, std::int32_t* params);
    void getTextureParameterfv(std::uint32_t texture, std::uint32_t pname, float* params);
    void getTextureParameterIiv(std::uint32_t texture, std::uint32_t pname, std::int32_t* params);
    void getTextureParameterIuiv(std::uint32_t texture, std::uint32_t pname, std::uint32_t* params);
    void getTextureParameteriv(std::uint32_t texture, std::uint32_t pname, std::int32_t* params);
    void createVertexArrays(std::int32_t n, std::uint32_t* arrays);
    void disableVertexArrayAttrib(std::uint32_t vaobj, std::uint32_t index);
    void enableVertexArrayAttrib(std::uint32_t vaobj, std::uint32_t index);
    void vertexArrayElementBuffer(std::uint32_t vaobj, std::uint32_t buffer);
    void vertexArrayVertexBuffer(std::uint32_t vaobj, std::uint32_t bindingindex, std::uint32_t buffer, std::intptr_t offset, std::int32_t stride);
    void vertexArrayVertexBuffers(std::uint32_t vaobj, std::uint32_t first, std::int32_t count, std::uint32_t const* buffers, std::intptr_t const* offsets, std::int32_t const* strides);
    void vertexArrayAttribBinding(std::uint32_t vaobj, std::uint32_t attribindex, std::uint32_t bindingindex);
    void vertexArrayAttribFormat(std::uint32_t vaobj, std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint8_t normalized, std::uint32_t relativeoffset);
    void vertexArrayAttribIFormat(std::uint32_t vaobj, std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexArrayAttribLFormat(std::uint32_t vaobj, std::uint32_t attribindex, std::int32_t size, std::uint32_t type, std::uint32_t relativeoffset);
    void vertexArrayBindingDivisor(std::uint32_t vaobj, std::uint32_t bindingindex, std::uint32_t divisor);
    void getVertexArrayiv(std::uint32_t vaobj, std::uint32_t pname, std::int32_t* param);
    void getVertexArrayIndexediv(std::uint32_t vaobj, std::uint32_t index, std::uint32_t pname, std::int32_t* param);
    void getVertexArrayIndexed64iv(std::uint32_t vaobj, std::uint32_t index, std::uint32_t pname, std::int64_t* param);
    void createSamplers(std::int32_t n, std::uint32_t* samplers);
    void createProgramPipelines(std::int32_t n, std::uint32_t* pipelines);
    void createQueries(std::uint32_t target, std::int32_t n, std::uint32_t* ids);
    void getQueryBufferObjecti64v(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryBufferObjectiv(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryBufferObjectui64v(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void getQueryBufferObjectuiv(std::uint32_t id, std::uint32_t buffer, std::uint32_t pname, std::intptr_t offset);
    void memoryBarrierByRegion(std::uint32_t barriers);
    void getTextureSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* pixels);
    void getCompressedTextureSubImage(std::uint32_t texture, std::int32_t level, std::int32_t xoffset, std::int32_t yoffset, std::int32_t zoffset, std::int32_t width, std::int32_t height, std::int32_t depth, std::int32_t bufSize, void* pixels);
    void getnCompressedTexImage(std::uint32_t target, std::int32_t lod, std::int32_t bufSize, void* pixels);
    void getnTexImage(std::uint32_t target, std::int32_t level, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* pixels);
    void getnUniformdv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, double* params);
    void getnUniformfv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, float* params);
    void getnUniformiv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, std::int32_t* params);
    void getnUniformuiv(std::uint32_t program, std::int32_t location, std::int32_t bufSize, std::uint32_t* params);
    void readnPixels(std::int32_t x, std::int32_t y, std::int32_t width, std::int32_t height, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* data);
    void getnMapdv(std::uint32_t target, std::uint32_t query, std::int32_t bufSize, double* v);
    void getnMapfv(std::uint32_t target, std::uint32_t query, std::int32_t bufSize, float* v);
    void getnMapiv(std::uint32_t target, std::uint32_t query, std::int32_t bufSize, std::int32_t* v);
    void getnPixelMapfv(std::uint32_t map, std::int32_t bufSize, float* values);
    void getnPixelMapuiv(std::uint32_t map, std::int32_t bufSize, std::uint32_t* values);
    void getnPixelMapusv(std::uint32_t map, std::int32_t bufSize, std::uint16_t* values);
    void getnPolygonStipple(std::int32_t bufSize, std::uint8_t* pattern);
    void getnColorTable(std::uint32_t target, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* table);
    void getnConvolutionFilter(std::uint32_t target, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* image);
    void getnSeparableFilter(std::uint32_t target, std::uint32_t format, std::uint32_t type, std::int32_t rowBufSize, void* row, std::int32_t columnBufSize, void* column, void* span);
    void getnHistogram(std::uint32_t target, std::uint8_t reset, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* values);
    void getnMinmax(std::uint32_t target, std::uint8_t reset, std::uint32_t format, std::uint32_t type, std::int32_t bufSize, void* values);
    void textureBarrier();
    void specializeShader(std::uint32_t shader, char const* pEntryPoint, std::uint32_t numSpecializationConstants, std::uint32_t const* pConstantIndex, std::uint32_t const* pConstantValue);
    void multiDrawArraysIndirectCount(std::uint32_t mode, void const* indirect, std::intptr_t drawcount, std::int32_t maxdrawcount, std::int32_t stride);
    void multiDrawElementsIndirectCount(std::uint32_t mode, std::uint32_t type, void const* indirect, std::intptr_t drawcount, std::int32_t maxdrawcount, std::int32_t stride);
    void polygonOffsetClamp(float factor, float units, float clamp);
    void blendBarrier();
    void primitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW);
    void swap();
    virtual ~OpenGL();
private:
    boom::__OpenGLImpl* _impl;
    void _current();
    void _bootstrap();
    void _implInit(boom::OpenGLOptions const&);
    void _implDone();
    void _implSwap();
    void _implCurrent();
    void _implBootstrap();
};

auto constexpr OpenGLColorBufferBit = 0x00004000;
auto constexpr OpenGLDepthBufferBit = 0x00000100;
auto constexpr OpenGLStencilBufferBit = 0x00000400;
auto constexpr OpenGLFalse = 0;
auto constexpr OpenGLTrue = 1;
auto constexpr OpenGLPoints = 0x0000;
auto constexpr OpenGLLines = 0x0001;
auto constexpr OpenGLLineLoop = 0x0002;
auto constexpr OpenGLLineStrip = 0x0003;
auto constexpr OpenGLTriangles = 0x0004;
auto constexpr OpenGLTriangleStrip = 0x0005;
auto constexpr OpenGLTriangleFan = 0x0006;
auto constexpr OpenGLNever = 0x0200;
auto constexpr OpenGLLess = 0x0201;
auto constexpr OpenGLEqual = 0x0202;
auto constexpr OpenGLLequal = 0x0203;
auto constexpr OpenGLGreater = 0x0204;
auto constexpr OpenGLNotequal = 0x0205;
auto constexpr OpenGLGequal = 0x0206;
auto constexpr OpenGLAlways = 0x0207;
auto constexpr OpenGLZero = 0;
auto constexpr OpenGLOne = 1;
auto constexpr OpenGLSrcColor = 0x0300;
auto constexpr OpenGLOneMinusSrcColor = 0x0301;
auto constexpr OpenGLSrcAlpha = 0x0302;
auto constexpr OpenGLOneMinusSrcAlpha = 0x0303;
auto constexpr OpenGLDstAlpha = 0x0304;
auto constexpr OpenGLOneMinusDstAlpha = 0x0305;
auto constexpr OpenGLDstColor = 0x0306;
auto constexpr OpenGLOneMinusDstColor = 0x0307;
auto constexpr OpenGLSrcAlphaSaturate = 0x0308;
auto constexpr OpenGLNone = 0;
auto constexpr OpenGLFrontLeft = 0x0400;
auto constexpr OpenGLFrontRight = 0x0401;
auto constexpr OpenGLBackLeft = 0x0402;
auto constexpr OpenGLBackRight = 0x0403;
auto constexpr OpenGLFront = 0x0404;
auto constexpr OpenGLBack = 0x0405;
auto constexpr OpenGLLeft = 0x0406;
auto constexpr OpenGLRight = 0x0407;
auto constexpr OpenGLFrontAndBack = 0x0408;
auto constexpr OpenGLNoError = 0;
auto constexpr OpenGLInvalidEnum = 0x0500;
auto constexpr OpenGLInvalidValue = 0x0501;
auto constexpr OpenGLInvalidOperation = 0x0502;
auto constexpr OpenGLOutOfMemory = 0x0505;
auto constexpr OpenGLCw = 0x0900;
auto constexpr OpenGLCcw = 0x0901;
auto constexpr OpenGLPointSize = 0x0B11;
auto constexpr OpenGLPointSizeRange = 0x0B12;
auto constexpr OpenGLPointSizeGranularity = 0x0B13;
auto constexpr OpenGLLineSmooth = 0x0B20;
auto constexpr OpenGLLineWidth = 0x0B21;
auto constexpr OpenGLLineWidthRange = 0x0B22;
auto constexpr OpenGLLineWidthGranularity = 0x0B23;
auto constexpr OpenGLPolygonMode = 0x0B40;
auto constexpr OpenGLPolygonSmooth = 0x0B41;
auto constexpr OpenGLCullFace = 0x0B44;
auto constexpr OpenGLCullFaceMode = 0x0B45;
auto constexpr OpenGLFrontFace = 0x0B46;
auto constexpr OpenGLDepthRange = 0x0B70;
auto constexpr OpenGLDepthTest = 0x0B71;
auto constexpr OpenGLDepthWritemask = 0x0B72;
auto constexpr OpenGLDepthClearValue = 0x0B73;
auto constexpr OpenGLDepthFunc = 0x0B74;
auto constexpr OpenGLStencilTest = 0x0B90;
auto constexpr OpenGLStencilClearValue = 0x0B91;
auto constexpr OpenGLStencilFunc = 0x0B92;
auto constexpr OpenGLStencilValueMask = 0x0B93;
auto constexpr OpenGLStencilFail = 0x0B94;
auto constexpr OpenGLStencilPassDepthFail = 0x0B95;
auto constexpr OpenGLStencilPassDepthPass = 0x0B96;
auto constexpr OpenGLStencilRef = 0x0B97;
auto constexpr OpenGLStencilWritemask = 0x0B98;
auto constexpr OpenGLViewport = 0x0BA2;
auto constexpr OpenGLDither = 0x0BD0;
auto constexpr OpenGLBlendDst = 0x0BE0;
auto constexpr OpenGLBlendSrc = 0x0BE1;
auto constexpr OpenGLBlend = 0x0BE2;
auto constexpr OpenGLLogicOpMode = 0x0BF0;
auto constexpr OpenGLDrawBuffer = 0x0C01;
auto constexpr OpenGLReadBuffer = 0x0C02;
auto constexpr OpenGLScissorBox = 0x0C10;
auto constexpr OpenGLScissorTest = 0x0C11;
auto constexpr OpenGLColorClearValue = 0x0C22;
auto constexpr OpenGLColorWritemask = 0x0C23;
auto constexpr OpenGLDoublebuffer = 0x0C32;
auto constexpr OpenGLStereo = 0x0C33;
auto constexpr OpenGLLineSmoothHint = 0x0C52;
auto constexpr OpenGLPolygonSmoothHint = 0x0C53;
auto constexpr OpenGLUnpackSwapBytes = 0x0CF0;
auto constexpr OpenGLUnpackLsbFirst = 0x0CF1;
auto constexpr OpenGLUnpackRowLength = 0x0CF2;
auto constexpr OpenGLUnpackSkipRows = 0x0CF3;
auto constexpr OpenGLUnpackSkipPixels = 0x0CF4;
auto constexpr OpenGLUnpackAlignment = 0x0CF5;
auto constexpr OpenGLPackSwapBytes = 0x0D00;
auto constexpr OpenGLPackLsbFirst = 0x0D01;
auto constexpr OpenGLPackRowLength = 0x0D02;
auto constexpr OpenGLPackSkipRows = 0x0D03;
auto constexpr OpenGLPackSkipPixels = 0x0D04;
auto constexpr OpenGLPackAlignment = 0x0D05;
auto constexpr OpenGLMaxTextureSize = 0x0D33;
auto constexpr OpenGLMaxViewportDims = 0x0D3A;
auto constexpr OpenGLSubpixelBits = 0x0D50;
auto constexpr OpenGLTexture1d = 0x0DE0;
auto constexpr OpenGLTexture2d = 0x0DE1;
auto constexpr OpenGLTextureWidth = 0x1000;
auto constexpr OpenGLTextureHeight = 0x1001;
auto constexpr OpenGLTextureBorderColor = 0x1004;
auto constexpr OpenGLDontCare = 0x1100;
auto constexpr OpenGLFastest = 0x1101;
auto constexpr OpenGLNicest = 0x1102;
auto constexpr OpenGLByte = 0x1400;
auto constexpr OpenGLUnsignedByte = 0x1401;
auto constexpr OpenGLShort = 0x1402;
auto constexpr OpenGLUnsignedShort = 0x1403;
auto constexpr OpenGLInt = 0x1404;
auto constexpr OpenGLUnsignedInt = 0x1405;
auto constexpr OpenGLFloat = 0x1406;
auto constexpr OpenGLClear = 0x1500;
auto constexpr OpenGLAnd = 0x1501;
auto constexpr OpenGLAndReverse = 0x1502;
auto constexpr OpenGLCopy = 0x1503;
auto constexpr OpenGLAndInverted = 0x1504;
auto constexpr OpenGLNoop = 0x1505;
auto constexpr OpenGLXor = 0x1506;
auto constexpr OpenGLOr = 0x1507;
auto constexpr OpenGLNor = 0x1508;
auto constexpr OpenGLEquiv = 0x1509;
auto constexpr OpenGLInvert = 0x150A;
auto constexpr OpenGLOrReverse = 0x150B;
auto constexpr OpenGLCopyInverted = 0x150C;
auto constexpr OpenGLOrInverted = 0x150D;
auto constexpr OpenGLNand = 0x150E;
auto constexpr OpenGLSet = 0x150F;
auto constexpr OpenGLTexture = 0x1702;
auto constexpr OpenGLColor = 0x1800;
auto constexpr OpenGLDepth = 0x1801;
auto constexpr OpenGLStencil = 0x1802;
auto constexpr OpenGLStencilIndex = 0x1901;
auto constexpr OpenGLDepthComponent = 0x1902;
auto constexpr OpenGLRed = 0x1903;
auto constexpr OpenGLGreen = 0x1904;
auto constexpr OpenGLBlue = 0x1905;
auto constexpr OpenGLAlpha = 0x1906;
auto constexpr OpenGLRGB = 0x1907;
auto constexpr OpenGLRGBA = 0x1908;
auto constexpr OpenGLPoint = 0x1B00;
auto constexpr OpenGLLine = 0x1B01;
auto constexpr OpenGLFill = 0x1B02;
auto constexpr OpenGLKeep = 0x1E00;
auto constexpr OpenGLReplace = 0x1E01;
auto constexpr OpenGLIncr = 0x1E02;
auto constexpr OpenGLDecr = 0x1E03;
auto constexpr OpenGLVendor = 0x1F00;
auto constexpr OpenGLRenderer = 0x1F01;
auto constexpr OpenGLVersion = 0x1F02;
auto constexpr OpenGLExtensions = 0x1F03;
auto constexpr OpenGLNearest = 0x2600;
auto constexpr OpenGLLinear = 0x2601;
auto constexpr OpenGLNearestMipmapNearest = 0x2700;
auto constexpr OpenGLLinearMipmapNearest = 0x2701;
auto constexpr OpenGLNearestMipmapLinear = 0x2702;
auto constexpr OpenGLLinearMipmapLinear = 0x2703;
auto constexpr OpenGLTextureMagFilter = 0x2800;
auto constexpr OpenGLTextureMinFilter = 0x2801;
auto constexpr OpenGLTextureWrapS = 0x2802;
auto constexpr OpenGLTextureWrapT = 0x2803;
auto constexpr OpenGLRepeat = 0x2901;
auto constexpr OpenGLColorLogicOp = 0x0BF2;
auto constexpr OpenGLPolygonOffsetUnits = 0x2A00;
auto constexpr OpenGLPolygonOffsetPoint = 0x2A01;
auto constexpr OpenGLPolygonOffsetLine = 0x2A02;
auto constexpr OpenGLPolygonOffsetFill = 0x8037;
auto constexpr OpenGLPolygonOffsetFactor = 0x8038;
auto constexpr OpenGLTextureBinding1d = 0x8068;
auto constexpr OpenGLTextureBinding2d = 0x8069;
auto constexpr OpenGLTextureInternalFormat = 0x1003;
auto constexpr OpenGLTextureRedSize = 0x805C;
auto constexpr OpenGLTextureGreenSize = 0x805D;
auto constexpr OpenGLTextureBlueSize = 0x805E;
auto constexpr OpenGLTextureAlphaSize = 0x805F;
auto constexpr OpenGLDouble = 0x140A;
auto constexpr OpenGLProxyTexture1d = 0x8063;
auto constexpr OpenGLProxyTexture2d = 0x8064;
auto constexpr OpenGLR3G3B2 = 0x2A10;
auto constexpr OpenGLRGB4 = 0x804F;
auto constexpr OpenGLRGB5 = 0x8050;
auto constexpr OpenGLRGB8 = 0x8051;
auto constexpr OpenGLRGB10 = 0x8052;
auto constexpr OpenGLRGB12 = 0x8053;
auto constexpr OpenGLRGB16 = 0x8054;
auto constexpr OpenGLRGBA2 = 0x8055;
auto constexpr OpenGLRGBA4 = 0x8056;
auto constexpr OpenGLRGB5A1 = 0x8057;
auto constexpr OpenGLRGBA8 = 0x8058;
auto constexpr OpenGLRGB10A2 = 0x8059;
auto constexpr OpenGLRGBA12 = 0x805A;
auto constexpr OpenGLRGBA16 = 0x805B;
auto constexpr OpenGLUnsignedByte332 = 0x8032;
auto constexpr OpenGLUnsignedShort4444 = 0x8033;
auto constexpr OpenGLUnsignedShort5551 = 0x8034;
auto constexpr OpenGLUnsignedInt8888 = 0x8035;
auto constexpr OpenGLUnsignedInt1010102 = 0x8036;
auto constexpr OpenGLTextureBinding3d = 0x806A;
auto constexpr OpenGLPackSkipImages = 0x806B;
auto constexpr OpenGLPackImageHeight = 0x806C;
auto constexpr OpenGLUnpackSkipImages = 0x806D;
auto constexpr OpenGLUnpackImageHeight = 0x806E;
auto constexpr OpenGLTexture3d = 0x806F;
auto constexpr OpenGLProxyTexture3d = 0x8070;
auto constexpr OpenGLTextureDepth = 0x8071;
auto constexpr OpenGLTextureWrapR = 0x8072;
auto constexpr OpenGLMax3dTextureSize = 0x8073;
auto constexpr OpenGLUnsignedByte233Rev = 0x8362;
auto constexpr OpenGLUnsignedShort565 = 0x8363;
auto constexpr OpenGLUnsignedShort565Rev = 0x8364;
auto constexpr OpenGLUnsignedShort4444Rev = 0x8365;
auto constexpr OpenGLUnsignedShort1555Rev = 0x8366;
auto constexpr OpenGLUnsignedInt8888Rev = 0x8367;
auto constexpr OpenGLUnsignedInt2101010Rev = 0x8368;
auto constexpr OpenGLBGR = 0x80E0;
auto constexpr OpenGLBGRA = 0x80E1;
auto constexpr OpenGLMaxElementsVertices = 0x80E8;
auto constexpr OpenGLMaxElementsIndices = 0x80E9;
auto constexpr OpenGLClampToEdge = 0x812F;
auto constexpr OpenGLTextureMinLod = 0x813A;
auto constexpr OpenGLTextureMaxLod = 0x813B;
auto constexpr OpenGLTextureBaseLevel = 0x813C;
auto constexpr OpenGLTextureMaxLevel = 0x813D;
auto constexpr OpenGLSmoothPointSizeRange = 0x0B12;
auto constexpr OpenGLSmoothPointSizeGranularity = 0x0B13;
auto constexpr OpenGLSmoothLineWidthRange = 0x0B22;
auto constexpr OpenGLSmoothLineWidthGranularity = 0x0B23;
auto constexpr OpenGLAliasedLineWidthRange = 0x846E;
auto constexpr OpenGLTexture0 = 0x84C0;
auto constexpr OpenGLTexture1 = 0x84C1;
auto constexpr OpenGLTexture2 = 0x84C2;
auto constexpr OpenGLTexture3 = 0x84C3;
auto constexpr OpenGLTexture4 = 0x84C4;
auto constexpr OpenGLTexture5 = 0x84C5;
auto constexpr OpenGLTexture6 = 0x84C6;
auto constexpr OpenGLTexture7 = 0x84C7;
auto constexpr OpenGLTexture8 = 0x84C8;
auto constexpr OpenGLTexture9 = 0x84C9;
auto constexpr OpenGLTexture10 = 0x84CA;
auto constexpr OpenGLTexture11 = 0x84CB;
auto constexpr OpenGLTexture12 = 0x84CC;
auto constexpr OpenGLTexture13 = 0x84CD;
auto constexpr OpenGLTexture14 = 0x84CE;
auto constexpr OpenGLTexture15 = 0x84CF;
auto constexpr OpenGLTexture16 = 0x84D0;
auto constexpr OpenGLTexture17 = 0x84D1;
auto constexpr OpenGLTexture18 = 0x84D2;
auto constexpr OpenGLTexture19 = 0x84D3;
auto constexpr OpenGLTexture20 = 0x84D4;
auto constexpr OpenGLTexture21 = 0x84D5;
auto constexpr OpenGLTexture22 = 0x84D6;
auto constexpr OpenGLTexture23 = 0x84D7;
auto constexpr OpenGLTexture24 = 0x84D8;
auto constexpr OpenGLTexture25 = 0x84D9;
auto constexpr OpenGLTexture26 = 0x84DA;
auto constexpr OpenGLTexture27 = 0x84DB;
auto constexpr OpenGLTexture28 = 0x84DC;
auto constexpr OpenGLTexture29 = 0x84DD;
auto constexpr OpenGLTexture30 = 0x84DE;
auto constexpr OpenGLTexture31 = 0x84DF;
auto constexpr OpenGLActiveTexture = 0x84E0;
auto constexpr OpenGLMultisample = 0x809D;
auto constexpr OpenGLSampleAlphaToCoverage = 0x809E;
auto constexpr OpenGLSampleAlphaToOne = 0x809F;
auto constexpr OpenGLSampleCoverage = 0x80A0;
auto constexpr OpenGLSampleBuffers = 0x80A8;
auto constexpr OpenGLSamples = 0x80A9;
auto constexpr OpenGLSampleCoverageValue = 0x80AA;
auto constexpr OpenGLSampleCoverageInvert = 0x80AB;
auto constexpr OpenGLTextureCubeMap = 0x8513;
auto constexpr OpenGLTextureBindingCubeMap = 0x8514;
auto constexpr OpenGLTextureCubeMapPositiveX = 0x8515;
auto constexpr OpenGLTextureCubeMapNegativeX = 0x8516;
auto constexpr OpenGLTextureCubeMapPositiveY = 0x8517;
auto constexpr OpenGLTextureCubeMapNegativeY = 0x8518;
auto constexpr OpenGLTextureCubeMapPositiveZ = 0x8519;
auto constexpr OpenGLTextureCubeMapNegativeZ = 0x851A;
auto constexpr OpenGLProxyTextureCubeMap = 0x851B;
auto constexpr OpenGLMaxCubeMapTextureSize = 0x851C;
auto constexpr OpenGLCompressedRGB = 0x84ED;
auto constexpr OpenGLCompressedRGBA = 0x84EE;
auto constexpr OpenGLTextureCompressionHint = 0x84EF;
auto constexpr OpenGLTextureCompressedImageSize = 0x86A0;
auto constexpr OpenGLTextureCompressed = 0x86A1;
auto constexpr OpenGLNumCompressedTextureFormats = 0x86A2;
auto constexpr OpenGLCompressedTextureFormats = 0x86A3;
auto constexpr OpenGLClampToBorder = 0x812D;
auto constexpr OpenGLBlendDstRGB = 0x80C8;
auto constexpr OpenGLBlendSrcRGB = 0x80C9;
auto constexpr OpenGLBlendDstAlpha = 0x80CA;
auto constexpr OpenGLBlendSrcAlpha = 0x80CB;
auto constexpr OpenGLPointFadeThresholdSize = 0x8128;
auto constexpr OpenGLDepthComponent16 = 0x81A5;
auto constexpr OpenGLDepthComponent24 = 0x81A6;
auto constexpr OpenGLDepthComponent32 = 0x81A7;
auto constexpr OpenGLMirroredRepeat = 0x8370;
auto constexpr OpenGLMaxTextureLodBias = 0x84FD;
auto constexpr OpenGLTextureLodBias = 0x8501;
auto constexpr OpenGLIncrWrap = 0x8507;
auto constexpr OpenGLDecrWrap = 0x8508;
auto constexpr OpenGLTextureDepthSize = 0x884A;
auto constexpr OpenGLTextureCompareMode = 0x884C;
auto constexpr OpenGLTextureCompareFunc = 0x884D;
auto constexpr OpenGLBlendColor = 0x8005;
auto constexpr OpenGLBlendEquation = 0x8009;
auto constexpr OpenGLConstantColor = 0x8001;
auto constexpr OpenGLOneMinusConstantColor = 0x8002;
auto constexpr OpenGLConstantAlpha = 0x8003;
auto constexpr OpenGLOneMinusConstantAlpha = 0x8004;
auto constexpr OpenGLFuncAdd = 0x8006;
auto constexpr OpenGLFuncReverseSubtract = 0x800B;
auto constexpr OpenGLFuncSubtract = 0x800A;
auto constexpr OpenGLMin = 0x8007;
auto constexpr OpenGLMax = 0x8008;
auto constexpr OpenGLBufferSize = 0x8764;
auto constexpr OpenGLBufferUsage = 0x8765;
auto constexpr OpenGLQueryCounterBits = 0x8864;
auto constexpr OpenGLCurrentQuery = 0x8865;
auto constexpr OpenGLQueryResult = 0x8866;
auto constexpr OpenGLQueryResultAvailable = 0x8867;
auto constexpr OpenGLArrayBuffer = 0x8892;
auto constexpr OpenGLElementArrayBuffer = 0x8893;
auto constexpr OpenGLArrayBufferBinding = 0x8894;
auto constexpr OpenGLElementArrayBufferBinding = 0x8895;
auto constexpr OpenGLVertexAttribArrayBufferBinding = 0x889F;
auto constexpr OpenGLReadOnly = 0x88B8;
auto constexpr OpenGLWriteOnly = 0x88B9;
auto constexpr OpenGLReadWrite = 0x88BA;
auto constexpr OpenGLBufferAccess = 0x88BB;
auto constexpr OpenGLBufferMapped = 0x88BC;
auto constexpr OpenGLBufferMapPointer = 0x88BD;
auto constexpr OpenGLStreamDraw = 0x88E0;
auto constexpr OpenGLStreamRead = 0x88E1;
auto constexpr OpenGLStreamCopy = 0x88E2;
auto constexpr OpenGLStaticDraw = 0x88E4;
auto constexpr OpenGLStaticRead = 0x88E5;
auto constexpr OpenGLStaticCopy = 0x88E6;
auto constexpr OpenGLDynamicDraw = 0x88E8;
auto constexpr OpenGLDynamicRead = 0x88E9;
auto constexpr OpenGLDynamicCopy = 0x88EA;
auto constexpr OpenGLSamplesPassed = 0x8914;
auto constexpr OpenGLSrc1Alpha = 0x8589;
auto constexpr OpenGLBlendEquationRGB = 0x8009;
auto constexpr OpenGLVertexAttribArrayEnabled = 0x8622;
auto constexpr OpenGLVertexAttribArraySize = 0x8623;
auto constexpr OpenGLVertexAttribArrayStride = 0x8624;
auto constexpr OpenGLVertexAttribArrayType = 0x8625;
auto constexpr OpenGLCurrentVertexAttrib = 0x8626;
auto constexpr OpenGLVertexProgramPointSize = 0x8642;
auto constexpr OpenGLVertexAttribArrayPointer = 0x8645;
auto constexpr OpenGLStencilBackFunc = 0x8800;
auto constexpr OpenGLStencilBackFail = 0x8801;
auto constexpr OpenGLStencilBackPassDepthFail = 0x8802;
auto constexpr OpenGLStencilBackPassDepthPass = 0x8803;
auto constexpr OpenGLMaxDrawBuffers = 0x8824;
auto constexpr OpenGLDrawBuffer0 = 0x8825;
auto constexpr OpenGLDrawBuffer1 = 0x8826;
auto constexpr OpenGLDrawBuffer2 = 0x8827;
auto constexpr OpenGLDrawBuffer3 = 0x8828;
auto constexpr OpenGLDrawBuffer4 = 0x8829;
auto constexpr OpenGLDrawBuffer5 = 0x882A;
auto constexpr OpenGLDrawBuffer6 = 0x882B;
auto constexpr OpenGLDrawBuffer7 = 0x882C;
auto constexpr OpenGLDrawBuffer8 = 0x882D;
auto constexpr OpenGLDrawBuffer9 = 0x882E;
auto constexpr OpenGLDrawBuffer10 = 0x882F;
auto constexpr OpenGLDrawBuffer11 = 0x8830;
auto constexpr OpenGLDrawBuffer12 = 0x8831;
auto constexpr OpenGLDrawBuffer13 = 0x8832;
auto constexpr OpenGLDrawBuffer14 = 0x8833;
auto constexpr OpenGLDrawBuffer15 = 0x8834;
auto constexpr OpenGLBlendEquationAlpha = 0x883D;
auto constexpr OpenGLMaxVertexAttribs = 0x8869;
auto constexpr OpenGLVertexAttribArrayNormalized = 0x886A;
auto constexpr OpenGLMaxTextureImageUnits = 0x8872;
auto constexpr OpenGLFragmentShader = 0x8B30;
auto constexpr OpenGLVertexShader = 0x8B31;
auto constexpr OpenGLMaxFragmentUniformComponents = 0x8B49;
auto constexpr OpenGLMaxVertexUniformComponents = 0x8B4A;
auto constexpr OpenGLMaxVaryingFloats = 0x8B4B;
auto constexpr OpenGLMaxVertexTextureImageUnits = 0x8B4C;
auto constexpr OpenGLMaxCombinedTextureImageUnits = 0x8B4D;
auto constexpr OpenGLShaderType = 0x8B4F;
auto constexpr OpenGLFloatVec2 = 0x8B50;
auto constexpr OpenGLFloatVec3 = 0x8B51;
auto constexpr OpenGLFloatVec4 = 0x8B52;
auto constexpr OpenGLIntVec2 = 0x8B53;
auto constexpr OpenGLIntVec3 = 0x8B54;
auto constexpr OpenGLIntVec4 = 0x8B55;
auto constexpr OpenGLBool = 0x8B56;
auto constexpr OpenGLBoolVec2 = 0x8B57;
auto constexpr OpenGLBoolVec3 = 0x8B58;
auto constexpr OpenGLBoolVec4 = 0x8B59;
auto constexpr OpenGLFloatMat2 = 0x8B5A;
auto constexpr OpenGLFloatMat3 = 0x8B5B;
auto constexpr OpenGLFloatMat4 = 0x8B5C;
auto constexpr OpenGLSampler1d = 0x8B5D;
auto constexpr OpenGLSampler2d = 0x8B5E;
auto constexpr OpenGLSampler3d = 0x8B5F;
auto constexpr OpenGLSamplerCube = 0x8B60;
auto constexpr OpenGLSampler1dShadow = 0x8B61;
auto constexpr OpenGLSampler2dShadow = 0x8B62;
auto constexpr OpenGLDeleteStatus = 0x8B80;
auto constexpr OpenGLCompileStatus = 0x8B81;
auto constexpr OpenGLLinkStatus = 0x8B82;
auto constexpr OpenGLValidateStatus = 0x8B83;
auto constexpr OpenGLInfoLogLength = 0x8B84;
auto constexpr OpenGLAttachedShaders = 0x8B85;
auto constexpr OpenGLActiveUniforms = 0x8B86;
auto constexpr OpenGLActiveUniformMaxLength = 0x8B87;
auto constexpr OpenGLShaderSourceLength = 0x8B88;
auto constexpr OpenGLActiveAttributes = 0x8B89;
auto constexpr OpenGLActiveAttributeMaxLength = 0x8B8A;
auto constexpr OpenGLFragmentShaderDerivativeHint = 0x8B8B;
auto constexpr OpenGLShadingLanguageVersion = 0x8B8C;
auto constexpr OpenGLCurrentProgram = 0x8B8D;
auto constexpr OpenGLPointSpriteCoordOrigin = 0x8CA0;
auto constexpr OpenGLLowerLeft = 0x8CA1;
auto constexpr OpenGLUpperLeft = 0x8CA2;
auto constexpr OpenGLStencilBackRef = 0x8CA3;
auto constexpr OpenGLStencilBackValueMask = 0x8CA4;
auto constexpr OpenGLStencilBackWritemask = 0x8CA5;
auto constexpr OpenGLPixelPackBuffer = 0x88EB;
auto constexpr OpenGLPixelUnpackBuffer = 0x88EC;
auto constexpr OpenGLPixelPackBufferBinding = 0x88ED;
auto constexpr OpenGLPixelUnpackBufferBinding = 0x88EF;
auto constexpr OpenGLFloatMat2x3 = 0x8B65;
auto constexpr OpenGLFloatMat2x4 = 0x8B66;
auto constexpr OpenGLFloatMat3x2 = 0x8B67;
auto constexpr OpenGLFloatMat3x4 = 0x8B68;
auto constexpr OpenGLFloatMat4x2 = 0x8B69;
auto constexpr OpenGLFloatMat4x3 = 0x8B6A;
auto constexpr OpenGLSRGB = 0x8C40;
auto constexpr OpenGLSRGB8 = 0x8C41;
auto constexpr OpenGLSRGBAlpha = 0x8C42;
auto constexpr OpenGLSRGB8Alpha8 = 0x8C43;
auto constexpr OpenGLCompressedSRGB = 0x8C48;
auto constexpr OpenGLCompressedSRGBAlpha = 0x8C49;
auto constexpr OpenGLCompareRefToTexture = 0x884E;
auto constexpr OpenGLClipDistance0 = 0x3000;
auto constexpr OpenGLClipDistance1 = 0x3001;
auto constexpr OpenGLClipDistance2 = 0x3002;
auto constexpr OpenGLClipDistance3 = 0x3003;
auto constexpr OpenGLClipDistance4 = 0x3004;
auto constexpr OpenGLClipDistance5 = 0x3005;
auto constexpr OpenGLClipDistance6 = 0x3006;
auto constexpr OpenGLClipDistance7 = 0x3007;
auto constexpr OpenGLMaxClipDistances = 0x0D32;
auto constexpr OpenGLMajorVersion = 0x821B;
auto constexpr OpenGLMinorVersion = 0x821C;
auto constexpr OpenGLNumExtensions = 0x821D;
auto constexpr OpenGLContextFlags = 0x821E;
auto constexpr OpenGLCompressedRed = 0x8225;
auto constexpr OpenGLCompressedRg = 0x8226;
auto constexpr OpenGLContextFlagForwardCompatibleBit = 0x00000001;
auto constexpr OpenGLRGBA32f = 0x8814;
auto constexpr OpenGLRGB32f = 0x8815;
auto constexpr OpenGLRGBA16f = 0x881A;
auto constexpr OpenGLRGB16f = 0x881B;
auto constexpr OpenGLVertexAttribArrayInteger = 0x88FD;
auto constexpr OpenGLMaxArrayTextureLayers = 0x88FF;
auto constexpr OpenGLMinProgramTexelOffset = 0x8904;
auto constexpr OpenGLMaxProgramTexelOffset = 0x8905;
auto constexpr OpenGLClampReadColor = 0x891C;
auto constexpr OpenGLFixedOnly = 0x891D;
auto constexpr OpenGLMaxVaryingComponents = 0x8B4B;
auto constexpr OpenGLTexture1dArray = 0x8C18;
auto constexpr OpenGLProxyTexture1dArray = 0x8C19;
auto constexpr OpenGLTexture2dArray = 0x8C1A;
auto constexpr OpenGLProxyTexture2dArray = 0x8C1B;
auto constexpr OpenGLTextureBinding1dArray = 0x8C1C;
auto constexpr OpenGLTextureBinding2dArray = 0x8C1D;
auto constexpr OpenGLR11fG11fB10f = 0x8C3A;
auto constexpr OpenGLUnsignedInt10f11f11fRev = 0x8C3B;
auto constexpr OpenGLRGB9E5 = 0x8C3D;
auto constexpr OpenGLUnsignedInt5999Rev = 0x8C3E;
auto constexpr OpenGLTextureSharedSize = 0x8C3F;
auto constexpr OpenGLTransformFeedbackVaryingMaxLength = 0x8C76;
auto constexpr OpenGLTransformFeedbackBufferMode = 0x8C7F;
auto constexpr OpenGLMaxTransformFeedbackSeparateComponents = 0x8C80;
auto constexpr OpenGLTransformFeedbackVaryings = 0x8C83;
auto constexpr OpenGLTransformFeedbackBufferStart = 0x8C84;
auto constexpr OpenGLTransformFeedbackBufferSize = 0x8C85;
auto constexpr OpenGLPrimitivesGenerated = 0x8C87;
auto constexpr OpenGLTransformFeedbackPrimitivesWritten = 0x8C88;
auto constexpr OpenGLRasterizerDiscard = 0x8C89;
auto constexpr OpenGLMaxTransformFeedbackInterleavedComponents = 0x8C8A;
auto constexpr OpenGLMaxTransformFeedbackSeparateAttribs = 0x8C8B;
auto constexpr OpenGLInterleavedAttribs = 0x8C8C;
auto constexpr OpenGLSeparateAttribs = 0x8C8D;
auto constexpr OpenGLTransformFeedbackBuffer = 0x8C8E;
auto constexpr OpenGLTransformFeedbackBufferBinding = 0x8C8F;
auto constexpr OpenGLRGBA32ui = 0x8D70;
auto constexpr OpenGLRGB32ui = 0x8D71;
auto constexpr OpenGLRGBA16ui = 0x8D76;
auto constexpr OpenGLRGB16ui = 0x8D77;
auto constexpr OpenGLRGBA8ui = 0x8D7C;
auto constexpr OpenGLRGB8ui = 0x8D7D;
auto constexpr OpenGLRGBA32i = 0x8D82;
auto constexpr OpenGLRGB32i = 0x8D83;
auto constexpr OpenGLRGBA16i = 0x8D88;
auto constexpr OpenGLRGB16i = 0x8D89;
auto constexpr OpenGLRGBA8i = 0x8D8E;
auto constexpr OpenGLRGB8i = 0x8D8F;
auto constexpr OpenGLRedInteger = 0x8D94;
auto constexpr OpenGLGreenInteger = 0x8D95;
auto constexpr OpenGLBlueInteger = 0x8D96;
auto constexpr OpenGLRGBInteger = 0x8D98;
auto constexpr OpenGLRGBAInteger = 0x8D99;
auto constexpr OpenGLBGRInteger = 0x8D9A;
auto constexpr OpenGLBGRAInteger = 0x8D9B;
auto constexpr OpenGLSampler1dArray = 0x8DC0;
auto constexpr OpenGLSampler2dArray = 0x8DC1;
auto constexpr OpenGLSampler1dArrayShadow = 0x8DC3;
auto constexpr OpenGLSampler2dArrayShadow = 0x8DC4;
auto constexpr OpenGLSamplerCubeShadow = 0x8DC5;
auto constexpr OpenGLUnsignedIntVec2 = 0x8DC6;
auto constexpr OpenGLUnsignedIntVec3 = 0x8DC7;
auto constexpr OpenGLUnsignedIntVec4 = 0x8DC8;
auto constexpr OpenGLIntSampler1d = 0x8DC9;
auto constexpr OpenGLIntSampler2d = 0x8DCA;
auto constexpr OpenGLIntSampler3d = 0x8DCB;
auto constexpr OpenGLIntSamplerCube = 0x8DCC;
auto constexpr OpenGLIntSampler1dArray = 0x8DCE;
auto constexpr OpenGLIntSampler2dArray = 0x8DCF;
auto constexpr OpenGLUnsignedIntSampler1d = 0x8DD1;
auto constexpr OpenGLUnsignedIntSampler2d = 0x8DD2;
auto constexpr OpenGLUnsignedIntSampler3d = 0x8DD3;
auto constexpr OpenGLUnsignedIntSamplerCube = 0x8DD4;
auto constexpr OpenGLUnsignedIntSampler1dArray = 0x8DD6;
auto constexpr OpenGLUnsignedIntSampler2dArray = 0x8DD7;
auto constexpr OpenGLQueryWait = 0x8E13;
auto constexpr OpenGLQueryNoWait = 0x8E14;
auto constexpr OpenGLQueryByRegionWait = 0x8E15;
auto constexpr OpenGLQueryByRegionNoWait = 0x8E16;
auto constexpr OpenGLBufferAccessFlags = 0x911F;
auto constexpr OpenGLBufferMapLength = 0x9120;
auto constexpr OpenGLBufferMapOffset = 0x9121;
auto constexpr OpenGLDepthComponent32f = 0x8CAC;
auto constexpr OpenGLDepth32fStencil8 = 0x8CAD;
auto constexpr OpenGLFloat32UnsignedInt248Rev = 0x8DAD;
auto constexpr OpenGLInvalidFramebufferOperation = 0x0506;
auto constexpr OpenGLFramebufferAttachmentColorEncoding = 0x8210;
auto constexpr OpenGLFramebufferAttachmentComponentType = 0x8211;
auto constexpr OpenGLFramebufferAttachmentRedSize = 0x8212;
auto constexpr OpenGLFramebufferAttachmentGreenSize = 0x8213;
auto constexpr OpenGLFramebufferAttachmentBlueSize = 0x8214;
auto constexpr OpenGLFramebufferAttachmentAlphaSize = 0x8215;
auto constexpr OpenGLFramebufferAttachmentDepthSize = 0x8216;
auto constexpr OpenGLFramebufferAttachmentStencilSize = 0x8217;
auto constexpr OpenGLFramebufferDefault = 0x8218;
auto constexpr OpenGLFramebufferUndefined = 0x8219;
auto constexpr OpenGLDepthStencilAttachment = 0x821A;
auto constexpr OpenGLMaxRenderbufferSize = 0x84E8;
auto constexpr OpenGLDepthStencil = 0x84F9;
auto constexpr OpenGLUnsignedInt248 = 0x84FA;
auto constexpr OpenGLDepth24Stencil8 = 0x88F0;
auto constexpr OpenGLTextureStencilSize = 0x88F1;
auto constexpr OpenGLTextureRedType = 0x8C10;
auto constexpr OpenGLTextureGreenType = 0x8C11;
auto constexpr OpenGLTextureBlueType = 0x8C12;
auto constexpr OpenGLTextureAlphaType = 0x8C13;
auto constexpr OpenGLTextureDepthType = 0x8C16;
auto constexpr OpenGLUnsignedNormalized = 0x8C17;
auto constexpr OpenGLFramebufferBinding = 0x8CA6;
auto constexpr OpenGLDrawFramebufferBinding = 0x8CA6;
auto constexpr OpenGLRenderbufferBinding = 0x8CA7;
auto constexpr OpenGLReadFramebuffer = 0x8CA8;
auto constexpr OpenGLDrawFramebuffer = 0x8CA9;
auto constexpr OpenGLReadFramebufferBinding = 0x8CAA;
auto constexpr OpenGLRenderbufferSamples = 0x8CAB;
auto constexpr OpenGLFramebufferAttachmentObjectType = 0x8CD0;
auto constexpr OpenGLFramebufferAttachmentObjectName = 0x8CD1;
auto constexpr OpenGLFramebufferAttachmentTextureLevel = 0x8CD2;
auto constexpr OpenGLFramebufferAttachmentTextureCubeMapFace = 0x8CD3;
auto constexpr OpenGLFramebufferAttachmentTextureLayer = 0x8CD4;
auto constexpr OpenGLFramebufferComplete = 0x8CD5;
auto constexpr OpenGLFramebufferIncompleteAttachment = 0x8CD6;
auto constexpr OpenGLFramebufferIncompleteMissingAttachment = 0x8CD7;
auto constexpr OpenGLFramebufferIncompleteDrawBuffer = 0x8CDB;
auto constexpr OpenGLFramebufferIncompleteReadBuffer = 0x8CDC;
auto constexpr OpenGLFramebufferUnsupported = 0x8CDD;
auto constexpr OpenGLMaxColorAttachments = 0x8CDF;
auto constexpr OpenGLColorAttachment0 = 0x8CE0;
auto constexpr OpenGLColorAttachment1 = 0x8CE1;
auto constexpr OpenGLColorAttachment2 = 0x8CE2;
auto constexpr OpenGLColorAttachment3 = 0x8CE3;
auto constexpr OpenGLColorAttachment4 = 0x8CE4;
auto constexpr OpenGLColorAttachment5 = 0x8CE5;
auto constexpr OpenGLColorAttachment6 = 0x8CE6;
auto constexpr OpenGLColorAttachment7 = 0x8CE7;
auto constexpr OpenGLColorAttachment8 = 0x8CE8;
auto constexpr OpenGLColorAttachment9 = 0x8CE9;
auto constexpr OpenGLColorAttachment10 = 0x8CEA;
auto constexpr OpenGLColorAttachment11 = 0x8CEB;
auto constexpr OpenGLColorAttachment12 = 0x8CEC;
auto constexpr OpenGLColorAttachment13 = 0x8CED;
auto constexpr OpenGLColorAttachment14 = 0x8CEE;
auto constexpr OpenGLColorAttachment15 = 0x8CEF;
auto constexpr OpenGLColorAttachment16 = 0x8CF0;
auto constexpr OpenGLColorAttachment17 = 0x8CF1;
auto constexpr OpenGLColorAttachment18 = 0x8CF2;
auto constexpr OpenGLColorAttachment19 = 0x8CF3;
auto constexpr OpenGLColorAttachment20 = 0x8CF4;
auto constexpr OpenGLColorAttachment21 = 0x8CF5;
auto constexpr OpenGLColorAttachment22 = 0x8CF6;
auto constexpr OpenGLColorAttachment23 = 0x8CF7;
auto constexpr OpenGLColorAttachment24 = 0x8CF8;
auto constexpr OpenGLColorAttachment25 = 0x8CF9;
auto constexpr OpenGLColorAttachment26 = 0x8CFA;
auto constexpr OpenGLColorAttachment27 = 0x8CFB;
auto constexpr OpenGLColorAttachment28 = 0x8CFC;
auto constexpr OpenGLColorAttachment29 = 0x8CFD;
auto constexpr OpenGLColorAttachment30 = 0x8CFE;
auto constexpr OpenGLColorAttachment31 = 0x8CFF;
auto constexpr OpenGLDepthAttachment = 0x8D00;
auto constexpr OpenGLStencilAttachment = 0x8D20;
auto constexpr OpenGLFramebuffer = 0x8D40;
auto constexpr OpenGLRenderbuffer = 0x8D41;
auto constexpr OpenGLRenderbufferWidth = 0x8D42;
auto constexpr OpenGLRenderbufferHeight = 0x8D43;
auto constexpr OpenGLRenderbufferInternalFormat = 0x8D44;
auto constexpr OpenGLStencilIndex1 = 0x8D46;
auto constexpr OpenGLStencilIndex4 = 0x8D47;
auto constexpr OpenGLStencilIndex8 = 0x8D48;
auto constexpr OpenGLStencilIndex16 = 0x8D49;
auto constexpr OpenGLRenderbufferRedSize = 0x8D50;
auto constexpr OpenGLRenderbufferGreenSize = 0x8D51;
auto constexpr OpenGLRenderbufferBlueSize = 0x8D52;
auto constexpr OpenGLRenderbufferAlphaSize = 0x8D53;
auto constexpr OpenGLRenderbufferDepthSize = 0x8D54;
auto constexpr OpenGLRenderbufferStencilSize = 0x8D55;
auto constexpr OpenGLFramebufferIncompleteMultisample = 0x8D56;
auto constexpr OpenGLMaxSamples = 0x8D57;
auto constexpr OpenGLFramebufferSRGB = 0x8DB9;
auto constexpr OpenGLHalfFloat = 0x140B;
auto constexpr OpenGLMapReadBit = 0x0001;
auto constexpr OpenGLMapWriteBit = 0x0002;
auto constexpr OpenGLMapInvalidateRangeBit = 0x0004;
auto constexpr OpenGLMapInvalidateBufferBit = 0x0008;
auto constexpr OpenGLMapFlushExplicitBit = 0x0010;
auto constexpr OpenGLMapUnsynchronizedBit = 0x0020;
auto constexpr OpenGLCompressedRedRgtc1 = 0x8DBB;
auto constexpr OpenGLCompressedSignedRedRgtc1 = 0x8DBC;
auto constexpr OpenGLCompressedRgRgtc2 = 0x8DBD;
auto constexpr OpenGLCompressedSignedRgRgtc2 = 0x8DBE;
auto constexpr OpenGLRG = 0x8227;
auto constexpr OpenGLRGInteger = 0x8228;
auto constexpr OpenGLR8 = 0x8229;
auto constexpr OpenGLR16 = 0x822A;
auto constexpr OpenGLRG8 = 0x822B;
auto constexpr OpenGLRG16 = 0x822C;
auto constexpr OpenGLR16f = 0x822D;
auto constexpr OpenGLR32f = 0x822E;
auto constexpr OpenGLRG16f = 0x822F;
auto constexpr OpenGLRG32f = 0x8230;
auto constexpr OpenGLR8i = 0x8231;
auto constexpr OpenGLR8ui = 0x8232;
auto constexpr OpenGLR16i = 0x8233;
auto constexpr OpenGLR16ui = 0x8234;
auto constexpr OpenGLR32i = 0x8235;
auto constexpr OpenGLR32ui = 0x8236;
auto constexpr OpenGLRG8i = 0x8237;
auto constexpr OpenGLRG8ui = 0x8238;
auto constexpr OpenGLRG16i = 0x8239;
auto constexpr OpenGLRG16ui = 0x823A;
auto constexpr OpenGLRG32i = 0x823B;
auto constexpr OpenGLRG32ui = 0x823C;
auto constexpr OpenGLVertexArrayBinding = 0x85B5;
auto constexpr OpenGLSampler2dRect = 0x8B63;
auto constexpr OpenGLSampler2dRectShadow = 0x8B64;
auto constexpr OpenGLSamplerBuffer = 0x8DC2;
auto constexpr OpenGLIntSampler2dRect = 0x8DCD;
auto constexpr OpenGLIntSamplerBuffer = 0x8DD0;
auto constexpr OpenGLUnsignedIntSampler2dRect = 0x8DD5;
auto constexpr OpenGLUnsignedIntSamplerBuffer = 0x8DD8;
auto constexpr OpenGLTextureBuffer = 0x8C2A;
auto constexpr OpenGLMaxTextureBufferSize = 0x8C2B;
auto constexpr OpenGLTextureBindingBuffer = 0x8C2C;
auto constexpr OpenGLTextureBufferDataStoreBinding = 0x8C2D;
auto constexpr OpenGLTextureRectangle = 0x84F5;
auto constexpr OpenGLTextureBindingRectangle = 0x84F6;
auto constexpr OpenGLProxyTextureRectangle = 0x84F7;
auto constexpr OpenGLMaxRectangleTextureSize = 0x84F8;
auto constexpr OpenGLR8Snorm = 0x8F94;
auto constexpr OpenGLRG8Snorm = 0x8F95;
auto constexpr OpenGLRGB8Snorm = 0x8F96;
auto constexpr OpenGLRGBA8Snorm = 0x8F97;
auto constexpr OpenGLR16Snorm = 0x8F98;
auto constexpr OpenGLRG16Snorm = 0x8F99;
auto constexpr OpenGLRGB16Snorm = 0x8F9A;
auto constexpr OpenGLRGBA16Snorm = 0x8F9B;
auto constexpr OpenGLSignedNormalized = 0x8F9C;
auto constexpr OpenGLPrimitiveRestart = 0x8F9D;
auto constexpr OpenGLPrimitiveRestartIndex = 0x8F9E;
auto constexpr OpenGLCopyReadBuffer = 0x8F36;
auto constexpr OpenGLCopyWriteBuffer = 0x8F37;
auto constexpr OpenGLUniformBuffer = 0x8A11;
auto constexpr OpenGLUniformBufferBinding = 0x8A28;
auto constexpr OpenGLUniformBufferStart = 0x8A29;
auto constexpr OpenGLUniformBufferSize = 0x8A2A;
auto constexpr OpenGLMaxVertexUniformBlocks = 0x8A2B;
auto constexpr OpenGLMaxGeometryUniformBlocks = 0x8A2C;
auto constexpr OpenGLMaxFragmentUniformBlocks = 0x8A2D;
auto constexpr OpenGLMaxCombinedUniformBlocks = 0x8A2E;
auto constexpr OpenGLMaxUniformBufferBindings = 0x8A2F;
auto constexpr OpenGLMaxUniformBlockSize = 0x8A30;
auto constexpr OpenGLMaxCombinedVertexUniformComponents = 0x8A31;
auto constexpr OpenGLMaxCombinedGeometryUniformComponents = 0x8A32;
auto constexpr OpenGLMaxCombinedFragmentUniformComponents = 0x8A33;
auto constexpr OpenGLUniformBufferOffsetAlignment = 0x8A34;
auto constexpr OpenGLActiveUniformBlockMaxNameLength = 0x8A35;
auto constexpr OpenGLActiveUniformBlocks = 0x8A36;
auto constexpr OpenGLUniformType = 0x8A37;
auto constexpr OpenGLUniformSize = 0x8A38;
auto constexpr OpenGLUniformNameLength = 0x8A39;
auto constexpr OpenGLUniformBlockIndex = 0x8A3A;
auto constexpr OpenGLUniformOffset = 0x8A3B;
auto constexpr OpenGLUniformArrayStride = 0x8A3C;
auto constexpr OpenGLUniformMatrixStride = 0x8A3D;
auto constexpr OpenGLUniformIsRowMajor = 0x8A3E;
auto constexpr OpenGLUniformBlockBinding = 0x8A3F;
auto constexpr OpenGLUniformBlockDataSize = 0x8A40;
auto constexpr OpenGLUniformBlockNameLength = 0x8A41;
auto constexpr OpenGLUniformBlockActiveUniforms = 0x8A42;
auto constexpr OpenGLUniformBlockActiveUniformIndices = 0x8A43;
auto constexpr OpenGLUniformBlockReferencedByVertexShader = 0x8A44;
auto constexpr OpenGLUniformBlockReferencedByGeometryShader = 0x8A45;
auto constexpr OpenGLUniformBlockReferencedByFragmentShader = 0x8A46;
auto constexpr OpenGLInvalidIndex = 0xFFFFFFFF;
auto constexpr OpenGLContextCoreProfileBit = 0x00000001;
auto constexpr OpenGLContextCompatibilityProfileBit = 0x00000002;
auto constexpr OpenGLLinesAdjacency = 0x000A;
auto constexpr OpenGLLineStripAdjacency = 0x000B;
auto constexpr OpenGLTrianglesAdjacency = 0x000C;
auto constexpr OpenGLTriangleStripAdjacency = 0x000D;
auto constexpr OpenGLProgramPointSize = 0x8642;
auto constexpr OpenGLMaxGeometryTextureImageUnits = 0x8C29;
auto constexpr OpenGLFramebufferAttachmentLayered = 0x8DA7;
auto constexpr OpenGLFramebufferIncompleteLayerTargets = 0x8DA8;
auto constexpr OpenGLGeometryShader = 0x8DD9;
auto constexpr OpenGLGeometryVerticesOut = 0x8916;
auto constexpr OpenGLGeometryInputType = 0x8917;
auto constexpr OpenGLGeometryOutputType = 0x8918;
auto constexpr OpenGLMaxGeometryUniformComponents = 0x8DDF;
auto constexpr OpenGLMaxGeometryOutputVertices = 0x8DE0;
auto constexpr OpenGLMaxGeometryTotalOutputComponents = 0x8DE1;
auto constexpr OpenGLMaxVertexOutputComponents = 0x9122;
auto constexpr OpenGLMaxGeometryInputComponents = 0x9123;
auto constexpr OpenGLMaxGeometryOutputComponents = 0x9124;
auto constexpr OpenGLMaxFragmentInputComponents = 0x9125;
auto constexpr OpenGLContextProfileMask = 0x9126;
auto constexpr OpenGLDepthClamp = 0x864F;
auto constexpr OpenGLQuadsFollowProvokingVertexConvention = 0x8E4C;
auto constexpr OpenGLFirstVertexConvention = 0x8E4D;
auto constexpr OpenGLLastVertexConvention = 0x8E4E;
auto constexpr OpenGLProvokingVertex = 0x8E4F;
auto constexpr OpenGLTextureCubeMapSeamless = 0x884F;
auto constexpr OpenGLMaxServerWaitTimeout = 0x9111;
auto constexpr OpenGLObjectType = 0x9112;
auto constexpr OpenGLSyncCondition = 0x9113;
auto constexpr OpenGLSyncStatus = 0x9114;
auto constexpr OpenGLSyncFlags = 0x9115;
auto constexpr OpenGLSyncFence = 0x9116;
auto constexpr OpenGLSyncGpuCommandsComplete = 0x9117;
auto constexpr OpenGLUnsignaled = 0x9118;
auto constexpr OpenGLSignaled = 0x9119;
auto constexpr OpenGLAlreadySignaled = 0x911A;
auto constexpr OpenGLTimeoutExpired = 0x911B;
auto constexpr OpenGLConditionSatisfied = 0x911C;
auto constexpr OpenGLWaitFailed = 0x911D;
auto constexpr OpenGLTimeoutIgnored = 0xFFFFFFFFFFFFFFFF;
auto constexpr OpenGLSyncFlushCommandsBit = 0x00000001;
auto constexpr OpenGLSamplePosition = 0x8E50;
auto constexpr OpenGLSampleMask = 0x8E51;
auto constexpr OpenGLSampleMaskValue = 0x8E52;
auto constexpr OpenGLMaxSampleMaskWords = 0x8E59;
auto constexpr OpenGLTexture2dMultisample = 0x9100;
auto constexpr OpenGLProxyTexture2dMultisample = 0x9101;
auto constexpr OpenGLTexture2dMultisampleArray = 0x9102;
auto constexpr OpenGLProxyTexture2dMultisampleArray = 0x9103;
auto constexpr OpenGLTextureBinding2dMultisample = 0x9104;
auto constexpr OpenGLTextureBinding2dMultisampleArray = 0x9105;
auto constexpr OpenGLTextureSamples = 0x9106;
auto constexpr OpenGLTextureFixedSampleLocations = 0x9107;
auto constexpr OpenGLSampler2dMultisample = 0x9108;
auto constexpr OpenGLIntSampler2dMultisample = 0x9109;
auto constexpr OpenGLUnsignedIntSampler2dMultisample = 0x910A;
auto constexpr OpenGLSampler2dMultisampleArray = 0x910B;
auto constexpr OpenGLIntSampler2dMultisampleArray = 0x910C;
auto constexpr OpenGLUnsignedIntSampler2dMultisampleArray = 0x910D;
auto constexpr OpenGLMaxColorTextureSamples = 0x910E;
auto constexpr OpenGLMaxDepthTextureSamples = 0x910F;
auto constexpr OpenGLMaxIntegerSamples = 0x9110;
auto constexpr OpenGLVertexAttribArrayDivisor = 0x88FE;
auto constexpr OpenGLSrc1Color = 0x88F9;
auto constexpr OpenGLOneMinusSrc1Color = 0x88FA;
auto constexpr OpenGLOneMinusSrc1Alpha = 0x88FB;
auto constexpr OpenGLMaxDualSourceDrawBuffers = 0x88FC;
auto constexpr OpenGLAnySamplesPassed = 0x8C2F;
auto constexpr OpenGLSamplerBinding = 0x8919;
auto constexpr OpenGLRGB10A2ui = 0x906F;
auto constexpr OpenGLTextureSwizzleR = 0x8E42;
auto constexpr OpenGLTextureSwizzleG = 0x8E43;
auto constexpr OpenGLTextureSwizzleB = 0x8E44;
auto constexpr OpenGLTextureSwizzleA = 0x8E45;
auto constexpr OpenGLTextureSwizzleRGBA = 0x8E46;
auto constexpr OpenGLTimeElapsed = 0x88BF;
auto constexpr OpenGLTimestamp = 0x8E28;
auto constexpr OpenGLInt2101010Rev = 0x8D9F;
auto constexpr OpenGLSampleShading = 0x8C36;
auto constexpr OpenGLMinSampleShadingValue = 0x8C37;
auto constexpr OpenGLMinProgramTextureGatherOffset = 0x8E5E;
auto constexpr OpenGLMaxProgramTextureGatherOffset = 0x8E5F;
auto constexpr OpenGLTextureCubeMapArray = 0x9009;
auto constexpr OpenGLTextureBindingCubeMapArray = 0x900A;
auto constexpr OpenGLProxyTextureCubeMapArray = 0x900B;
auto constexpr OpenGLSamplerCubeMapArray = 0x900C;
auto constexpr OpenGLSamplerCubeMapArrayShadow = 0x900D;
auto constexpr OpenGLIntSamplerCubeMapArray = 0x900E;
auto constexpr OpenGLUnsignedIntSamplerCubeMapArray = 0x900F;
auto constexpr OpenGLDrawIndirectBuffer = 0x8F3F;
auto constexpr OpenGLDrawIndirectBufferBinding = 0x8F43;
auto constexpr OpenGLGeometryShaderInvocations = 0x887F;
auto constexpr OpenGLMaxGeometryShaderInvocations = 0x8E5A;
auto constexpr OpenGLMinFragmentInterpolationOffset = 0x8E5B;
auto constexpr OpenGLMaxFragmentInterpolationOffset = 0x8E5C;
auto constexpr OpenGLFragmentInterpolationOffsetBits = 0x8E5D;
auto constexpr OpenGLMaxVertexStreams = 0x8E71;
auto constexpr OpenGLDoubleVec2 = 0x8FFC;
auto constexpr OpenGLDoubleVec3 = 0x8FFD;
auto constexpr OpenGLDoubleVec4 = 0x8FFE;
auto constexpr OpenGLDoubleMat2 = 0x8F46;
auto constexpr OpenGLDoubleMat3 = 0x8F47;
auto constexpr OpenGLDoubleMat4 = 0x8F48;
auto constexpr OpenGLDoubleMat2x3 = 0x8F49;
auto constexpr OpenGLDoubleMat2x4 = 0x8F4A;
auto constexpr OpenGLDoubleMat3x2 = 0x8F4B;
auto constexpr OpenGLDoubleMat3x4 = 0x8F4C;
auto constexpr OpenGLDoubleMat4x2 = 0x8F4D;
auto constexpr OpenGLDoubleMat4x3 = 0x8F4E;
auto constexpr OpenGLActiveSubroutines = 0x8DE5;
auto constexpr OpenGLActiveSubroutineUniforms = 0x8DE6;
auto constexpr OpenGLActiveSubroutineUniformLocations = 0x8E47;
auto constexpr OpenGLActiveSubroutineMaxLength = 0x8E48;
auto constexpr OpenGLActiveSubroutineUniformMaxLength = 0x8E49;
auto constexpr OpenGLMaxSubroutines = 0x8DE7;
auto constexpr OpenGLMaxSubroutineUniformLocations = 0x8DE8;
auto constexpr OpenGLNumCompatibleSubroutines = 0x8E4A;
auto constexpr OpenGLCompatibleSubroutines = 0x8E4B;
auto constexpr OpenGLPatches = 0x000E;
auto constexpr OpenGLPatchVertices = 0x8E72;
auto constexpr OpenGLPatchDefaultInnerLevel = 0x8E73;
auto constexpr OpenGLPatchDefaultOuterLevel = 0x8E74;
auto constexpr OpenGLTessControlOutputVertices = 0x8E75;
auto constexpr OpenGLTessGenMode = 0x8E76;
auto constexpr OpenGLTessGenSpacing = 0x8E77;
auto constexpr OpenGLTessGenVertexOrder = 0x8E78;
auto constexpr OpenGLTessGenPointMode = 0x8E79;
auto constexpr OpenGLIsolines = 0x8E7A;
auto constexpr OpenGLQuads = 0x0007;
auto constexpr OpenGLFractionalOdd = 0x8E7B;
auto constexpr OpenGLFractionalEven = 0x8E7C;
auto constexpr OpenGLMaxPatchVertices = 0x8E7D;
auto constexpr OpenGLMaxTessGenLevel = 0x8E7E;
auto constexpr OpenGLMaxTessControlUniformComponents = 0x8E7F;
auto constexpr OpenGLMaxTessEvaluationUniformComponents = 0x8E80;
auto constexpr OpenGLMaxTessControlTextureImageUnits = 0x8E81;
auto constexpr OpenGLMaxTessEvaluationTextureImageUnits = 0x8E82;
auto constexpr OpenGLMaxTessControlOutputComponents = 0x8E83;
auto constexpr OpenGLMaxTessPatchComponents = 0x8E84;
auto constexpr OpenGLMaxTessControlTotalOutputComponents = 0x8E85;
auto constexpr OpenGLMaxTessEvaluationOutputComponents = 0x8E86;
auto constexpr OpenGLMaxTessControlUniformBlocks = 0x8E89;
auto constexpr OpenGLMaxTessEvaluationUniformBlocks = 0x8E8A;
auto constexpr OpenGLMaxTessControlInputComponents = 0x886C;
auto constexpr OpenGLMaxTessEvaluationInputComponents = 0x886D;
auto constexpr OpenGLMaxCombinedTessControlUniformComponents = 0x8E1E;
auto constexpr OpenGLMaxCombinedTessEvaluationUniformComponents = 0x8E1F;
auto constexpr OpenGLUniformBlockReferencedByTessControlShader = 0x84F0;
auto constexpr OpenGLUniformBlockReferencedByTessEvaluationShader = 0x84F1;
auto constexpr OpenGLTessEvaluationShader = 0x8E87;
auto constexpr OpenGLTessControlShader = 0x8E88;
auto constexpr OpenGLTransformFeedback = 0x8E22;
auto constexpr OpenGLTransformFeedbackBufferPaused = 0x8E23;
auto constexpr OpenGLTransformFeedbackBufferActive = 0x8E24;
auto constexpr OpenGLTransformFeedbackBinding = 0x8E25;
auto constexpr OpenGLMaxTransformFeedbackBuffers = 0x8E70;
auto constexpr OpenGLFixed = 0x140C;
auto constexpr OpenGLImplementationColorReadType = 0x8B9A;
auto constexpr OpenGLImplementationColorReadFormat = 0x8B9B;
auto constexpr OpenGLLowFloat = 0x8DF0;
auto constexpr OpenGLMediumFloat = 0x8DF1;
auto constexpr OpenGLHighFloat = 0x8DF2;
auto constexpr OpenGLLowInt = 0x8DF3;
auto constexpr OpenGLMediumInt = 0x8DF4;
auto constexpr OpenGLHighInt = 0x8DF5;
auto constexpr OpenGLShaderCompiler = 0x8DFA;
auto constexpr OpenGLShaderBinaryFormats = 0x8DF8;
auto constexpr OpenGLNumShaderBinaryFormats = 0x8DF9;
auto constexpr OpenGLMaxVertexUniformVectors = 0x8DFB;
auto constexpr OpenGLMaxVaryingVectors = 0x8DFC;
auto constexpr OpenGLMaxFragmentUniformVectors = 0x8DFD;
auto constexpr OpenGLRGB565 = 0x8D62;
auto constexpr OpenGLProgramBinaryRetrievableHint = 0x8257;
auto constexpr OpenGLProgramBinaryLength = 0x8741;
auto constexpr OpenGLNumProgramBinaryFormats = 0x87FE;
auto constexpr OpenGLProgramBinaryFormats = 0x87FF;
auto constexpr OpenGLVertexShaderBit = 0x00000001;
auto constexpr OpenGLFragmentShaderBit = 0x00000002;
auto constexpr OpenGLGeometryShaderBit = 0x00000004;
auto constexpr OpenGLTessControlShaderBit = 0x00000008;
auto constexpr OpenGLTessEvaluationShaderBit = 0x00000010;
auto constexpr OpenGLAllShaderBits = 0xFFFFFFFF;
auto constexpr OpenGLProgramSeparable = 0x8258;
auto constexpr OpenGLActiveProgram = 0x8259;
auto constexpr OpenGLProgramPipelineBinding = 0x825A;
auto constexpr OpenGLMaxViewports = 0x825B;
auto constexpr OpenGLViewportSubpixelBits = 0x825C;
auto constexpr OpenGLViewportBoundsRange = 0x825D;
auto constexpr OpenGLLayerProvokingVertex = 0x825E;
auto constexpr OpenGLViewportIndexProvokingVertex = 0x825F;
auto constexpr OpenGLUndefinedVertex = 0x8260;
auto constexpr OpenGLCopyReadBufferBinding = 0x8F36;
auto constexpr OpenGLCopyWriteBufferBinding = 0x8F37;
auto constexpr OpenGLTransformFeedbackActive = 0x8E24;
auto constexpr OpenGLTransformFeedbackPaused = 0x8E23;
auto constexpr OpenGLUnpackCompressedBlockWidth = 0x9127;
auto constexpr OpenGLUnpackCompressedBlockHeight = 0x9128;
auto constexpr OpenGLUnpackCompressedBlockDepth = 0x9129;
auto constexpr OpenGLUnpackCompressedBlockSize = 0x912A;
auto constexpr OpenGLPackCompressedBlockWidth = 0x912B;
auto constexpr OpenGLPackCompressedBlockHeight = 0x912C;
auto constexpr OpenGLPackCompressedBlockDepth = 0x912D;
auto constexpr OpenGLPackCompressedBlockSize = 0x912E;
auto constexpr OpenGLNumSampleCounts = 0x9380;
auto constexpr OpenGLMinMapBufferAlignment = 0x90BC;
auto constexpr OpenGLAtomicCounterBuffer = 0x92C0;
auto constexpr OpenGLAtomicCounterBufferBinding = 0x92C1;
auto constexpr OpenGLAtomicCounterBufferStart = 0x92C2;
auto constexpr OpenGLAtomicCounterBufferSize = 0x92C3;
auto constexpr OpenGLAtomicCounterBufferDataSize = 0x92C4;
auto constexpr OpenGLAtomicCounterBufferActiveAtomicCounters = 0x92C5;
auto constexpr OpenGLAtomicCounterBufferActiveAtomicCounterIndices = 0x92C6;
auto constexpr OpenGLAtomicCounterBufferReferencedByVertexShader = 0x92C7;
auto constexpr OpenGLAtomicCounterBufferReferencedByTessControlShader = 0x92C8;
auto constexpr OpenGLAtomicCounterBufferReferencedByTessEvaluationShader = 0x92C9;
auto constexpr OpenGLAtomicCounterBufferReferencedByGeometryShader = 0x92CA;
auto constexpr OpenGLAtomicCounterBufferReferencedByFragmentShader = 0x92CB;
auto constexpr OpenGLMaxVertexAtomicCounterBuffers = 0x92CC;
auto constexpr OpenGLMaxTessControlAtomicCounterBuffers = 0x92CD;
auto constexpr OpenGLMaxTessEvaluationAtomicCounterBuffers = 0x92CE;
auto constexpr OpenGLMaxGeometryAtomicCounterBuffers = 0x92CF;
auto constexpr OpenGLMaxFragmentAtomicCounterBuffers = 0x92D0;
auto constexpr OpenGLMaxCombinedAtomicCounterBuffers = 0x92D1;
auto constexpr OpenGLMaxVertexAtomicCounters = 0x92D2;
auto constexpr OpenGLMaxTessControlAtomicCounters = 0x92D3;
auto constexpr OpenGLMaxTessEvaluationAtomicCounters = 0x92D4;
auto constexpr OpenGLMaxGeometryAtomicCounters = 0x92D5;
auto constexpr OpenGLMaxFragmentAtomicCounters = 0x92D6;
auto constexpr OpenGLMaxCombinedAtomicCounters = 0x92D7;
auto constexpr OpenGLMaxAtomicCounterBufferSize = 0x92D8;
auto constexpr OpenGLMaxAtomicCounterBufferBindings = 0x92DC;
auto constexpr OpenGLActiveAtomicCounterBuffers = 0x92D9;
auto constexpr OpenGLUniformAtomicCounterBufferIndex = 0x92DA;
auto constexpr OpenGLUnsignedIntAtomicCounter = 0x92DB;
auto constexpr OpenGLVertexAttribArrayBarrierBit = 0x00000001;
auto constexpr OpenGLElementArrayBarrierBit = 0x00000002;
auto constexpr OpenGLUniformBarrierBit = 0x00000004;
auto constexpr OpenGLTextureFetchBarrierBit = 0x00000008;
auto constexpr OpenGLShaderImageAccessBarrierBit = 0x00000020;
auto constexpr OpenGLCommandBarrierBit = 0x00000040;
auto constexpr OpenGLPixelBufferBarrierBit = 0x00000080;
auto constexpr OpenGLTextureUpdateBarrierBit = 0x00000100;
auto constexpr OpenGLBufferUpdateBarrierBit = 0x00000200;
auto constexpr OpenGLFramebufferBarrierBit = 0x00000400;
auto constexpr OpenGLTransformFeedbackBarrierBit = 0x00000800;
auto constexpr OpenGLAtomicCounterBarrierBit = 0x00001000;
auto constexpr OpenGLAllBarrierBits = 0xFFFFFFFF;
auto constexpr OpenGLMaxImageUnits = 0x8F38;
auto constexpr OpenGLMaxCombinedImageUnitsAndFragmentOutputs = 0x8F39;
auto constexpr OpenGLImageBindingName = 0x8F3A;
auto constexpr OpenGLImageBindingLevel = 0x8F3B;
auto constexpr OpenGLImageBindingLayered = 0x8F3C;
auto constexpr OpenGLImageBindingLayer = 0x8F3D;
auto constexpr OpenGLImageBindingAccess = 0x8F3E;
auto constexpr OpenGLImage1d = 0x904C;
auto constexpr OpenGLImage2d = 0x904D;
auto constexpr OpenGLImage3d = 0x904E;
auto constexpr OpenGLImage2dRect = 0x904F;
auto constexpr OpenGLImageCube = 0x9050;
auto constexpr OpenGLImageBuffer = 0x9051;
auto constexpr OpenGLImage1dArray = 0x9052;
auto constexpr OpenGLImage2dArray = 0x9053;
auto constexpr OpenGLImageCubeMapArray = 0x9054;
auto constexpr OpenGLImage2dMultisample = 0x9055;
auto constexpr OpenGLImage2dMultisampleArray = 0x9056;
auto constexpr OpenGLIntImage1d = 0x9057;
auto constexpr OpenGLIntImage2d = 0x9058;
auto constexpr OpenGLIntImage3d = 0x9059;
auto constexpr OpenGLIntImage2dRect = 0x905A;
auto constexpr OpenGLIntImageCube = 0x905B;
auto constexpr OpenGLIntImageBuffer = 0x905C;
auto constexpr OpenGLIntImage1dArray = 0x905D;
auto constexpr OpenGLIntImage2dArray = 0x905E;
auto constexpr OpenGLIntImageCubeMapArray = 0x905F;
auto constexpr OpenGLIntImage2dMultisample = 0x9060;
auto constexpr OpenGLIntImage2dMultisampleArray = 0x9061;
auto constexpr OpenGLUnsignedIntImage1d = 0x9062;
auto constexpr OpenGLUnsignedIntImage2d = 0x9063;
auto constexpr OpenGLUnsignedIntImage3d = 0x9064;
auto constexpr OpenGLUnsignedIntImage2dRect = 0x9065;
auto constexpr OpenGLUnsignedIntImageCube = 0x9066;
auto constexpr OpenGLUnsignedIntImageBuffer = 0x9067;
auto constexpr OpenGLUnsignedIntImage1dArray = 0x9068;
auto constexpr OpenGLUnsignedIntImage2dArray = 0x9069;
auto constexpr OpenGLUnsignedIntImageCubeMapArray = 0x906A;
auto constexpr OpenGLUnsignedIntImage2dMultisample = 0x906B;
auto constexpr OpenGLUnsignedIntImage2dMultisampleArray = 0x906C;
auto constexpr OpenGLMaxImageSamples = 0x906D;
auto constexpr OpenGLImageBindingFormat = 0x906E;
auto constexpr OpenGLImageFormatCompatibilityType = 0x90C7;
auto constexpr OpenGLImageFormatCompatibilityBySize = 0x90C8;
auto constexpr OpenGLImageFormatCompatibilityByClass = 0x90C9;
auto constexpr OpenGLMaxVertexImageUniforms = 0x90CA;
auto constexpr OpenGLMaxTessControlImageUniforms = 0x90CB;
auto constexpr OpenGLMaxTessEvaluationImageUniforms = 0x90CC;
auto constexpr OpenGLMaxGeometryImageUniforms = 0x90CD;
auto constexpr OpenGLMaxFragmentImageUniforms = 0x90CE;
auto constexpr OpenGLMaxCombinedImageUniforms = 0x90CF;
auto constexpr OpenGLCompressedRGBABptcUnorm = 0x8E8C;
auto constexpr OpenGLCompressedSRGBAlphaBptcUnorm = 0x8E8D;
auto constexpr OpenGLCompressedRGBBptcSignedFloat = 0x8E8E;
auto constexpr OpenGLCompressedRGBBptcUnsignedFloat = 0x8E8F;
auto constexpr OpenGLTextureImmutableFormat = 0x912F;
auto constexpr OpenGLNumShadingLanguageVersions = 0x82E9;
auto constexpr OpenGLVertexAttribArrayLong = 0x874E;
auto constexpr OpenGLCompressedRGB8Etc2 = 0x9274;
auto constexpr OpenGLCompressedSRGB8Etc2 = 0x9275;
auto constexpr OpenGLCompressedRGB8PunchthroughAlpha1Etc2 = 0x9276;
auto constexpr OpenGLCompressedSRGB8PunchthroughAlpha1Etc2 = 0x9277;
auto constexpr OpenGLCompressedRGBA8Etc2Eac = 0x9278;
auto constexpr OpenGLCompressedSRGB8Alpha8Etc2Eac = 0x9279;
auto constexpr OpenGLCompressedR11Eac = 0x9270;
auto constexpr OpenGLCompressedSignedR11Eac = 0x9271;
auto constexpr OpenGLCompressedRg11Eac = 0x9272;
auto constexpr OpenGLCompressedSignedRg11Eac = 0x9273;
auto constexpr OpenGLPrimitiveRestartFixedIndex = 0x8D69;
auto constexpr OpenGLAnySamplesPassedConservative = 0x8D6A;
auto constexpr OpenGLMaxElementIndex = 0x8D6B;
auto constexpr OpenGLComputeShader = 0x91B9;
auto constexpr OpenGLMaxComputeUniformBlocks = 0x91BB;
auto constexpr OpenGLMaxComputeTextureImageUnits = 0x91BC;
auto constexpr OpenGLMaxComputeImageUniforms = 0x91BD;
auto constexpr OpenGLMaxComputeSharedMemorySize = 0x8262;
auto constexpr OpenGLMaxComputeUniformComponents = 0x8263;
auto constexpr OpenGLMaxComputeAtomicCounterBuffers = 0x8264;
auto constexpr OpenGLMaxComputeAtomicCounters = 0x8265;
auto constexpr OpenGLMaxCombinedComputeUniformComponents = 0x8266;
auto constexpr OpenGLMaxComputeWorkGroupInvocations = 0x90EB;
auto constexpr OpenGLMaxComputeWorkGroupCount = 0x91BE;
auto constexpr OpenGLMaxComputeWorkGroupSize = 0x91BF;
auto constexpr OpenGLComputeWorkGroupSize = 0x8267;
auto constexpr OpenGLUniformBlockReferencedByComputeShader = 0x90EC;
auto constexpr OpenGLAtomicCounterBufferReferencedByComputeShader = 0x90ED;
auto constexpr OpenGLDispatchIndirectBuffer = 0x90EE;
auto constexpr OpenGLDispatchIndirectBufferBinding = 0x90EF;
auto constexpr OpenGLComputeShaderBit = 0x00000020;
auto constexpr OpenGLDebugOutputSynchronous = 0x8242;
auto constexpr OpenGLDebugNextLoggedMessageLength = 0x8243;
auto constexpr OpenGLDebugCallbackFunction = 0x8244;
auto constexpr OpenGLDebugCallbackUserParam = 0x8245;
auto constexpr OpenGLDebugSourceApi = 0x8246;
auto constexpr OpenGLDebugSourceWindowSystem = 0x8247;
auto constexpr OpenGLDebugSourceShaderCompiler = 0x8248;
auto constexpr OpenGLDebugSourceThirdParty = 0x8249;
auto constexpr OpenGLDebugSourceApplication = 0x824A;
auto constexpr OpenGLDebugSourceOther = 0x824B;
auto constexpr OpenGLDebugTypeError = 0x824C;
auto constexpr OpenGLDebugTypeDeprecatedBehavior = 0x824D;
auto constexpr OpenGLDebugTypeUndefinedBehavior = 0x824E;
auto constexpr OpenGLDebugTypePortability = 0x824F;
auto constexpr OpenGLDebugTypePerformance = 0x8250;
auto constexpr OpenGLDebugTypeOther = 0x8251;
auto constexpr OpenGLMaxDebugMessageLength = 0x9143;
auto constexpr OpenGLMaxDebugLoggedMessages = 0x9144;
auto constexpr OpenGLDebugLoggedMessages = 0x9145;
auto constexpr OpenGLDebugSeverityHigh = 0x9146;
auto constexpr OpenGLDebugSeverityMedium = 0x9147;
auto constexpr OpenGLDebugSeverityLow = 0x9148;
auto constexpr OpenGLDebugTypeMarker = 0x8268;
auto constexpr OpenGLDebugTypePushGroup = 0x8269;
auto constexpr OpenGLDebugTypePopGroup = 0x826A;
auto constexpr OpenGLDebugSeverityNotification = 0x826B;
auto constexpr OpenGLMaxDebugGroupStackDepth = 0x826C;
auto constexpr OpenGLDebugGroupStackDepth = 0x826D;
auto constexpr OpenGLBuffer = 0x82E0;
auto constexpr OpenGLShader = 0x82E1;
auto constexpr OpenGLProgram = 0x82E2;
auto constexpr OpenGLVertexArray = 0x8074;
auto constexpr OpenGLQuery = 0x82E3;
auto constexpr OpenGLProgramPipeline = 0x82E4;
auto constexpr OpenGLSampler = 0x82E6;
auto constexpr OpenGLMaxLabelLength = 0x82E8;
auto constexpr OpenGLDebugOutput = 0x92E0;
auto constexpr OpenGLContextFlagDebugBit = 0x00000002;
auto constexpr OpenGLMaxUniformLocations = 0x826E;
auto constexpr OpenGLFramebufferDefaultWidth = 0x9310;
auto constexpr OpenGLFramebufferDefaultHeight = 0x9311;
auto constexpr OpenGLFramebufferDefaultLayers = 0x9312;
auto constexpr OpenGLFramebufferDefaultSamples = 0x9313;
auto constexpr OpenGLFramebufferDefaultFixedSampleLocations = 0x9314;
auto constexpr OpenGLMaxFramebufferWidth = 0x9315;
auto constexpr OpenGLMaxFramebufferHeight = 0x9316;
auto constexpr OpenGLMaxFramebufferLayers = 0x9317;
auto constexpr OpenGLMaxFramebufferSamples = 0x9318;
auto constexpr OpenGLInternalformatSupported = 0x826F;
auto constexpr OpenGLInternalformatPreferred = 0x8270;
auto constexpr OpenGLInternalformatRedSize = 0x8271;
auto constexpr OpenGLInternalformatGreenSize = 0x8272;
auto constexpr OpenGLInternalformatBlueSize = 0x8273;
auto constexpr OpenGLInternalformatAlphaSize = 0x8274;
auto constexpr OpenGLInternalformatDepthSize = 0x8275;
auto constexpr OpenGLInternalformatStencilSize = 0x8276;
auto constexpr OpenGLInternalformatSharedSize = 0x8277;
auto constexpr OpenGLInternalformatRedType = 0x8278;
auto constexpr OpenGLInternalformatGreenType = 0x8279;
auto constexpr OpenGLInternalformatBlueType = 0x827A;
auto constexpr OpenGLInternalformatAlphaType = 0x827B;
auto constexpr OpenGLInternalformatDepthType = 0x827C;
auto constexpr OpenGLInternalformatStencilType = 0x827D;
auto constexpr OpenGLMaxWidth = 0x827E;
auto constexpr OpenGLMaxHeight = 0x827F;
auto constexpr OpenGLMaxDepth = 0x8280;
auto constexpr OpenGLMaxLayers = 0x8281;
auto constexpr OpenGLMaxCombinedDimensions = 0x8282;
auto constexpr OpenGLColorComponents = 0x8283;
auto constexpr OpenGLDepthComponents = 0x8284;
auto constexpr OpenGLStencilComponents = 0x8285;
auto constexpr OpenGLColorRenderable = 0x8286;
auto constexpr OpenGLDepthRenderable = 0x8287;
auto constexpr OpenGLStencilRenderable = 0x8288;
auto constexpr OpenGLFramebufferRenderable = 0x8289;
auto constexpr OpenGLFramebufferRenderableLayered = 0x828A;
auto constexpr OpenGLFramebufferBlend = 0x828B;
auto constexpr OpenGLReadPixels = 0x828C;
auto constexpr OpenGLReadPixelsFormat = 0x828D;
auto constexpr OpenGLReadPixelsType = 0x828E;
auto constexpr OpenGLTextureImageFormat = 0x828F;
auto constexpr OpenGLTextureImageType = 0x8290;
auto constexpr OpenGLGetTextureImageFormat = 0x8291;
auto constexpr OpenGLGetTextureImageType = 0x8292;
auto constexpr OpenGLMipmap = 0x8293;
auto constexpr OpenGLManualGenerateMipmap = 0x8294;
auto constexpr OpenGLAutoGenerateMipmap = 0x8295;
auto constexpr OpenGLColorEncoding = 0x8296;
auto constexpr OpenGLSRGBRead = 0x8297;
auto constexpr OpenGLSRGBWrite = 0x8298;
auto constexpr OpenGLFilter = 0x829A;
auto constexpr OpenGLVertexTexture = 0x829B;
auto constexpr OpenGLTessControlTexture = 0x829C;
auto constexpr OpenGLTessEvaluationTexture = 0x829D;
auto constexpr OpenGLGeometryTexture = 0x829E;
auto constexpr OpenGLFragmentTexture = 0x829F;
auto constexpr OpenGLComputeTexture = 0x82A0;
auto constexpr OpenGLTextureShadow = 0x82A1;
auto constexpr OpenGLTextureGather = 0x82A2;
auto constexpr OpenGLTextureGatherShadow = 0x82A3;
auto constexpr OpenGLShaderImageLoad = 0x82A4;
auto constexpr OpenGLShaderImageStore = 0x82A5;
auto constexpr OpenGLShaderImageAtomic = 0x82A6;
auto constexpr OpenGLImageTexelSize = 0x82A7;
auto constexpr OpenGLImageCompatibilityClass = 0x82A8;
auto constexpr OpenGLImagePixelFormat = 0x82A9;
auto constexpr OpenGLImagePixelType = 0x82AA;
auto constexpr OpenGLSimultaneousTextureAndDepthTest = 0x82AC;
auto constexpr OpenGLSimultaneousTextureAndStencilTest = 0x82AD;
auto constexpr OpenGLSimultaneousTextureAndDepthWrite = 0x82AE;
auto constexpr OpenGLSimultaneousTextureAndStencilWrite = 0x82AF;
auto constexpr OpenGLTextureCompressedBlockWidth = 0x82B1;
auto constexpr OpenGLTextureCompressedBlockHeight = 0x82B2;
auto constexpr OpenGLTextureCompressedBlockSize = 0x82B3;
auto constexpr OpenGLClearBuffer = 0x82B4;
auto constexpr OpenGLTextureView = 0x82B5;
auto constexpr OpenGLViewCompatibilityClass = 0x82B6;
auto constexpr OpenGLFullSupport = 0x82B7;
auto constexpr OpenGLCaveatSupport = 0x82B8;
auto constexpr OpenGLImageClass4X32 = 0x82B9;
auto constexpr OpenGLImageClass2X32 = 0x82BA;
auto constexpr OpenGLImageClass1X32 = 0x82BB;
auto constexpr OpenGLImageClass4X16 = 0x82BC;
auto constexpr OpenGLImageClass2X16 = 0x82BD;
auto constexpr OpenGLImageClass1X16 = 0x82BE;
auto constexpr OpenGLImageClass4X8 = 0x82BF;
auto constexpr OpenGLImageClass2X8 = 0x82C0;
auto constexpr OpenGLImageClass1X8 = 0x82C1;
auto constexpr OpenGLImageClass111110 = 0x82C2;
auto constexpr OpenGLImageClass1010102 = 0x82C3;
auto constexpr OpenGLViewClass128Bits = 0x82C4;
auto constexpr OpenGLViewClass96Bits = 0x82C5;
auto constexpr OpenGLViewClass64Bits = 0x82C6;
auto constexpr OpenGLViewClass48Bits = 0x82C7;
auto constexpr OpenGLViewClass32Bits = 0x82C8;
auto constexpr OpenGLViewClass24Bits = 0x82C9;
auto constexpr OpenGLViewClass16Bits = 0x82CA;
auto constexpr OpenGLViewClass8Bits = 0x82CB;
auto constexpr OpenGLViewClassS3tcDxt1RGB = 0x82CC;
auto constexpr OpenGLViewClassS3tcDxt1RGBA = 0x82CD;
auto constexpr OpenGLViewClassS3tcDxt3RGBA = 0x82CE;
auto constexpr OpenGLViewClassS3tcDxt5RGBA = 0x82CF;
auto constexpr OpenGLViewClassRgtc1Red = 0x82D0;
auto constexpr OpenGLViewClassRgtc2Rg = 0x82D1;
auto constexpr OpenGLViewClassBptcUnorm = 0x82D2;
auto constexpr OpenGLViewClassBptcFloat = 0x82D3;
auto constexpr OpenGLUniform = 0x92E1;
auto constexpr OpenGLUniformBlock = 0x92E2;
auto constexpr OpenGLProgramInput = 0x92E3;
auto constexpr OpenGLProgramOutput = 0x92E4;
auto constexpr OpenGLBufferVariable = 0x92E5;
auto constexpr OpenGLShaderStorageBlock = 0x92E6;
auto constexpr OpenGLVertexSubroutine = 0x92E8;
auto constexpr OpenGLTessControlSubroutine = 0x92E9;
auto constexpr OpenGLTessEvaluationSubroutine = 0x92EA;
auto constexpr OpenGLGeometrySubroutine = 0x92EB;
auto constexpr OpenGLFragmentSubroutine = 0x92EC;
auto constexpr OpenGLComputeSubroutine = 0x92ED;
auto constexpr OpenGLVertexSubroutineUniform = 0x92EE;
auto constexpr OpenGLTessControlSubroutineUniform = 0x92EF;
auto constexpr OpenGLTessEvaluationSubroutineUniform = 0x92F0;
auto constexpr OpenGLGeometrySubroutineUniform = 0x92F1;
auto constexpr OpenGLFragmentSubroutineUniform = 0x92F2;
auto constexpr OpenGLComputeSubroutineUniform = 0x92F3;
auto constexpr OpenGLTransformFeedbackVarying = 0x92F4;
auto constexpr OpenGLActiveResources = 0x92F5;
auto constexpr OpenGLMaxNameLength = 0x92F6;
auto constexpr OpenGLMaxNumActiveVariables = 0x92F7;
auto constexpr OpenGLMaxNumCompatibleSubroutines = 0x92F8;
auto constexpr OpenGLNameLength = 0x92F9;
auto constexpr OpenGLType = 0x92FA;
auto constexpr OpenGLArraySize = 0x92FB;
auto constexpr OpenGLOffset = 0x92FC;
auto constexpr OpenGLBlockIndex = 0x92FD;
auto constexpr OpenGLArrayStride = 0x92FE;
auto constexpr OpenGLMatrixStride = 0x92FF;
auto constexpr OpenGLIsRowMajor = 0x9300;
auto constexpr OpenGLAtomicCounterBufferIndex = 0x9301;
auto constexpr OpenGLBufferBinding = 0x9302;
auto constexpr OpenGLBufferDataSize = 0x9303;
auto constexpr OpenGLNumActiveVariables = 0x9304;
auto constexpr OpenGLActiveVariables = 0x9305;
auto constexpr OpenGLReferencedByVertexShader = 0x9306;
auto constexpr OpenGLReferencedByTessControlShader = 0x9307;
auto constexpr OpenGLReferencedByTessEvaluationShader = 0x9308;
auto constexpr OpenGLReferencedByGeometryShader = 0x9309;
auto constexpr OpenGLReferencedByFragmentShader = 0x930A;
auto constexpr OpenGLReferencedByComputeShader = 0x930B;
auto constexpr OpenGLTopLevelArraySize = 0x930C;
auto constexpr OpenGLTopLevelArrayStride = 0x930D;
auto constexpr OpenGLLocation = 0x930E;
auto constexpr OpenGLLocationIndex = 0x930F;
auto constexpr OpenGLIsPerPatch = 0x92E7;
auto constexpr OpenGLShaderStorageBuffer = 0x90D2;
auto constexpr OpenGLShaderStorageBufferBinding = 0x90D3;
auto constexpr OpenGLShaderStorageBufferStart = 0x90D4;
auto constexpr OpenGLShaderStorageBufferSize = 0x90D5;
auto constexpr OpenGLMaxVertexShaderStorageBlocks = 0x90D6;
auto constexpr OpenGLMaxGeometryShaderStorageBlocks = 0x90D7;
auto constexpr OpenGLMaxTessControlShaderStorageBlocks = 0x90D8;
auto constexpr OpenGLMaxTessEvaluationShaderStorageBlocks = 0x90D9;
auto constexpr OpenGLMaxFragmentShaderStorageBlocks = 0x90DA;
auto constexpr OpenGLMaxComputeShaderStorageBlocks = 0x90DB;
auto constexpr OpenGLMaxCombinedShaderStorageBlocks = 0x90DC;
auto constexpr OpenGLMaxShaderStorageBufferBindings = 0x90DD;
auto constexpr OpenGLMaxShaderStorageBlockSize = 0x90DE;
auto constexpr OpenGLShaderStorageBufferOffsetAlignment = 0x90DF;
auto constexpr OpenGLShaderStorageBarrierBit = 0x00002000;
auto constexpr OpenGLMaxCombinedShaderOutputResources = 0x8F39;
auto constexpr OpenGLDepthStencilTextureMode = 0x90EA;
auto constexpr OpenGLTextureBufferOffset = 0x919D;
auto constexpr OpenGLTextureBufferSize = 0x919E;
auto constexpr OpenGLTextureBufferOffsetAlignment = 0x919F;
auto constexpr OpenGLTextureViewMinLevel = 0x82DB;
auto constexpr OpenGLTextureViewNumLevels = 0x82DC;
auto constexpr OpenGLTextureViewMinLayer = 0x82DD;
auto constexpr OpenGLTextureViewNumLayers = 0x82DE;
auto constexpr OpenGLTextureImmutableLevels = 0x82DF;
auto constexpr OpenGLVertexAttribBinding = 0x82D4;
auto constexpr OpenGLVertexAttribRelativeOffset = 0x82D5;
auto constexpr OpenGLVertexBindingDivisor = 0x82D6;
auto constexpr OpenGLVertexBindingOffset = 0x82D7;
auto constexpr OpenGLVertexBindingStride = 0x82D8;
auto constexpr OpenGLMaxVertexAttribRelativeOffset = 0x82D9;
auto constexpr OpenGLMaxVertexAttribBindings = 0x82DA;
auto constexpr OpenGLVertexBindingBuffer = 0x8F4F;
auto constexpr OpenGLDisplayList = 0x82E7;
auto constexpr OpenGLStackUnderflow = 0x0504;
auto constexpr OpenGLStackOverflow = 0x0503;
auto constexpr OpenGLMaxVertexAttribStride = 0x82E5;
auto constexpr OpenGLPrimitiveRestartForPatchesSupported = 0x8221;
auto constexpr OpenGLTextureBufferBinding = 0x8C2A;
auto constexpr OpenGLMapPersistentBit = 0x0040;
auto constexpr OpenGLMapCoherentBit = 0x0080;
auto constexpr OpenGLDynamicStorageBit = 0x0100;
auto constexpr OpenGLClientStorageBit = 0x0200;
auto constexpr OpenGLClientMappedBufferBarrierBit = 0x00004000;
auto constexpr OpenGLBufferImmutableStorage = 0x821F;
auto constexpr OpenGLBufferStorageFlags = 0x8220;
auto constexpr OpenGLClearTexture = 0x9365;
auto constexpr OpenGLLocationComponent = 0x934A;
auto constexpr OpenGLTransformFeedbackBufferIndex = 0x934B;
auto constexpr OpenGLTransformFeedbackBufferStride = 0x934C;
auto constexpr OpenGLQueryBuffer = 0x9192;
auto constexpr OpenGLQueryBufferBarrierBit = 0x00008000;
auto constexpr OpenGLQueryBufferBinding = 0x9193;
auto constexpr OpenGLQueryResultNoWait = 0x9194;
auto constexpr OpenGLMirrorClampToEdge = 0x8743;
auto constexpr OpenGLContextLost = 0x0507;
auto constexpr OpenGLNegativeOneToOne = 0x935E;
auto constexpr OpenGLZeroToOne = 0x935F;
auto constexpr OpenGLClipOrigin = 0x935C;
auto constexpr OpenGLClipDepthMode = 0x935D;
auto constexpr OpenGLQueryWaitInverted = 0x8E17;
auto constexpr OpenGLQueryNoWaitInverted = 0x8E18;
auto constexpr OpenGLQueryByRegionWaitInverted = 0x8E19;
auto constexpr OpenGLQueryByRegionNoWaitInverted = 0x8E1A;
auto constexpr OpenGLMaxCullDistances = 0x82F9;
auto constexpr OpenGLMaxCombinedClipAndCullDistances = 0x82FA;
auto constexpr OpenGLTextureTarget = 0x1006;
auto constexpr OpenGLQueryTarget = 0x82EA;
auto constexpr OpenGLGuiltyContextReset = 0x8253;
auto constexpr OpenGLInnocentContextReset = 0x8254;
auto constexpr OpenGLUnknownContextReset = 0x8255;
auto constexpr OpenGLResetNotificationStrategy = 0x8256;
auto constexpr OpenGLLoseContextOnReset = 0x8252;
auto constexpr OpenGLNoResetNotification = 0x8261;
auto constexpr OpenGLContextFlagRobustAccessBit = 0x00000004;
auto constexpr OpenGLColorTable = 0x80D0;
auto constexpr OpenGLPostConvolutionColorTable = 0x80D1;
auto constexpr OpenGLPostColorMatrixColorTable = 0x80D2;
auto constexpr OpenGLProxyColorTable = 0x80D3;
auto constexpr OpenGLProxyPostConvolutionColorTable = 0x80D4;
auto constexpr OpenGLProxyPostColorMatrixColorTable = 0x80D5;
auto constexpr OpenGLConvolution1d = 0x8010;
auto constexpr OpenGLConvolution2d = 0x8011;
auto constexpr OpenGLSeparable2d = 0x8012;
auto constexpr OpenGLHistogram = 0x8024;
auto constexpr OpenGLProxyHistogram = 0x8025;
auto constexpr OpenGLMinmax = 0x802E;
auto constexpr OpenGLContextReleaseBehavior = 0x82FB;
auto constexpr OpenGLContextReleaseBehaviorFlush = 0x82FC;
auto constexpr OpenGLShaderBinaryFormatSpirV = 0x9551;
auto constexpr OpenGLSpirVBinary = 0x9552;
auto constexpr OpenGLParameterBuffer = 0x80EE;
auto constexpr OpenGLParameterBufferBinding = 0x80EF;
auto constexpr OpenGLContextFlagNoErrorBit = 0x00000008;
auto constexpr OpenGLVerticesSubmitted = 0x82EE;
auto constexpr OpenGLPrimitivesSubmitted = 0x82EF;
auto constexpr OpenGLVertexShaderInvocations = 0x82F0;
auto constexpr OpenGLTessControlShaderPatches = 0x82F1;
auto constexpr OpenGLTessEvaluationShaderInvocations = 0x82F2;
auto constexpr OpenGLGeometryShaderPrimitivesEmitted = 0x82F3;
auto constexpr OpenGLFragmentShaderInvocations = 0x82F4;
auto constexpr OpenGLComputeShaderInvocations = 0x82F5;
auto constexpr OpenGLClippingInputPrimitives = 0x82F6;
auto constexpr OpenGLClippingOutputPrimitives = 0x82F7;
auto constexpr OpenGLPolygonOffsetClamp = 0x8E1B;
auto constexpr OpenGLSpirVExtensions = 0x9553;
auto constexpr OpenGLNumSpirVExtensions = 0x9554;
auto constexpr OpenGLTextureMaxAnisotropy = 0x84FE;
auto constexpr OpenGLMaxTextureMaxAnisotropy = 0x84FF;
auto constexpr OpenGLTransformFeedbackOverflow = 0x82EC;
auto constexpr OpenGLTransformFeedbackStreamOverflow = 0x82ED;
auto constexpr OpenGLAliasedPointSizeRange = 0x846D;
auto constexpr OpenGLRedBits = 0x0D52;
auto constexpr OpenGLGreenBits = 0x0D53;
auto constexpr OpenGLBlueBits = 0x0D54;
auto constexpr OpenGLAlphaBits = 0x0D55;
auto constexpr OpenGLDepthBits = 0x0D56;
auto constexpr OpenGLStencilBits = 0x0D57;
auto constexpr OpenGLGenerateMipmapHint = 0x8192;
auto constexpr OpenGLLuminance = 0x1909;
auto constexpr OpenGLLuminanceAlpha = 0x190A;
auto constexpr OpenGLFramebufferIncompleteDimensions = 0x8CD9;
auto constexpr OpenGLMultisampleLineWidthRange = 0x9381;
auto constexpr OpenGLMultisampleLineWidthGranularity = 0x9382;
auto constexpr OpenGLMultiply = 0x9294;
auto constexpr OpenGLScreen = 0x9295;
auto constexpr OpenGLOverlay = 0x9296;
auto constexpr OpenGLDarken = 0x9297;
auto constexpr OpenGLLighten = 0x9298;
auto constexpr OpenGLColordodge = 0x9299;
auto constexpr OpenGLColorburn = 0x929A;
auto constexpr OpenGLHardlight = 0x929B;
auto constexpr OpenGLSoftlight = 0x929C;
auto constexpr OpenGLDifference = 0x929E;
auto constexpr OpenGLExclusion = 0x92A0;
auto constexpr OpenGLHslHue = 0x92AD;
auto constexpr OpenGLHslSaturation = 0x92AE;
auto constexpr OpenGLHslColor = 0x92AF;
auto constexpr OpenGLHslLuminosity = 0x92B0;
auto constexpr OpenGLPrimitiveBoundingBox = 0x92BE;
auto constexpr OpenGLCompressedRGBAAstc4x4 = 0x93B0;
auto constexpr OpenGLCompressedRGBAAstc5x4 = 0x93B1;
auto constexpr OpenGLCompressedRGBAAstc5x5 = 0x93B2;
auto constexpr OpenGLCompressedRGBAAstc6x5 = 0x93B3;
auto constexpr OpenGLCompressedRGBAAstc6x6 = 0x93B4;
auto constexpr OpenGLCompressedRGBAAstc8x5 = 0x93B5;
auto constexpr OpenGLCompressedRGBAAstc8x6 = 0x93B6;
auto constexpr OpenGLCompressedRGBAAstc8x8 = 0x93B7;
auto constexpr OpenGLCompressedRGBAAstc10x5 = 0x93B8;
auto constexpr OpenGLCompressedRGBAAstc10x6 = 0x93B9;
auto constexpr OpenGLCompressedRGBAAstc10x8 = 0x93BA;
auto constexpr OpenGLCompressedRGBAAstc10x10 = 0x93BB;
auto constexpr OpenGLCompressedRGBAAstc12x10 = 0x93BC;
auto constexpr OpenGLCompressedRGBAAstc12x12 = 0x93BD;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc4x4 = 0x93D0;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc5x4 = 0x93D1;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc5x5 = 0x93D2;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc6x5 = 0x93D3;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc6x6 = 0x93D4;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc8x5 = 0x93D5;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc8x6 = 0x93D6;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc8x8 = 0x93D7;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x5 = 0x93D8;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x6 = 0x93D9;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x8 = 0x93DA;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc10x10 = 0x93DB;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc12x10 = 0x93DC;
auto constexpr OpenGLCompressedSRGB8Alpha8Astc12x12 = 0x93DD;

} /* namespace boom */