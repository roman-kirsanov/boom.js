#include <cinttypes>
#include <Boom/OpenGL.hpp>

namespace boom {

struct GLSync;

using GLvoid = void;
using GLenum = std::uint32_t;
using GLboolean = std::uint8_t;
using GLbitfield = std::uint32_t;
using GLbyte = std::int32_t;
using GLubyte = std::uint8_t;
using GLshort = std::int16_t;
using GLushort = std::uint16_t;
using GLint = std::int32_t;
using GLuint = std::uint32_t;
using GLclampx = std::int32_t;
using GLsizei = std::int32_t;
using GLfloat = float;
using GLclampf = float;
using GLdouble = double;
using GLclampd = double;
using GLeglClientBufferEXT = void*;
using GLeglImageOES = void*;
using GLchar = char;
using GLcharARB = char;
using GLhalf = std::uint16_t;
using GLhalfARB = std::uint16_t;
using GLfixed = std::int32_t;
using GLintptr = std::intptr_t;
using GLintptrARB = std::intptr_t;
using GLsizeiptr = std::int64_t;
using GLsizeiptrARB = std::int64_t;
using GLint64 = std::int64_t;
using GLint64EXT = std::int64_t;
using GLuint64 = std::uint64_t;
using GLuint64EXT = std::uint64_t;
using GLDebugProc = void(*)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
using GLCullFace = void(*)(GLenum mode);
using GLFrontFace = void(*)(GLenum mode);
using GLHint = void(*)(GLenum target, GLenum mode);
using GLLineWidth = void(*)(GLfloat width);
using GLPointSize = void(*)(GLfloat size);
using GLPolygonMode = void(*)(GLenum face, GLenum mode);
using GLScissor = void(*)(GLint x, GLint y, GLsizei width, GLsizei height);
using GLTexParameterf = void(*)(GLenum target, GLenum pname, GLfloat param);
using GLTexParameterfv = void(*)(GLenum target, GLenum pname, const GLfloat *params);
using GLTexParameteri = void(*)(GLenum target, GLenum pname, GLint param);
using GLTexParameteriv = void(*)(GLenum target, GLenum pname, const GLint *params);
using GLTexImage1D = void(*)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
using GLTexImage2D = void(*)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
using GLDrawBuffer = void(*)(GLenum buf);
using GLClear = void(*)(GLbitfield mask);
using GLClearColor = void(*)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
using GLClearStencil = void(*)(GLint s);
using GLClearDepth = void(*)(GLdouble depth);
using GLStencilMask = void(*)(GLuint mask);
using GLColorMask = void(*)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
using GLDepthMask = void(*)(GLboolean flag);
using GLDisable = void(*)(GLenum cap);
using GLEnable = void(*)(GLenum cap);
using GLFinish = void(*)(void);
using GLFlush = void(*)(void);
using GLBlendFunc = void(*)(GLenum sfactor, GLenum dfactor);
using GLLogicOp = void(*)(GLenum opcode);
using GLStencilFunc = void(*)(GLenum func, GLint ref, GLuint mask);
using GLStencilOp = void(*)(GLenum fail, GLenum zfail, GLenum zpass);
using GLDepthFunc = void(*)(GLenum func);
using GLPixelStoref = void(*)(GLenum pname, GLfloat param);
using GLPixelStorei = void(*)(GLenum pname, GLint param);
using GLReadBuffer = void(*)(GLenum src);
using GLReadPixels = void(*)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
using GLGetBooleanv = void(*)(GLenum pname, GLboolean *data);
using GLGetDoublev = void(*)(GLenum pname, GLdouble *data);
using GLGetFloatv = void(*)(GLenum pname, GLfloat *data);
using GLGetIntegerv = void(*)(GLenum pname, GLint *data);
using GLGetTexImage = void(*)(GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
using GLGetTexParameterfv = void(*)(GLenum target, GLenum pname, GLfloat *params);
using GLGetTexParameteriv = void(*)(GLenum target, GLenum pname, GLint *params);
using GLGetTexLevelParameterfv = void(*)(GLenum target, GLint level, GLenum pname, GLfloat *params);
using GLGetTexLevelParameteriv = void(*)(GLenum target, GLint level, GLenum pname, GLint *params);
using GLDepthRange = void(*)(GLdouble n, GLdouble f);
using GLViewport = void(*)(GLint x, GLint y, GLsizei width, GLsizei height);
using GLDrawArrays = void(*)(GLenum mode, GLint first, GLsizei count);
using GLDrawElements = void(*)(GLenum mode, GLsizei count, GLenum type, const void *indices);
using GLPolygonOffset = void(*)(GLfloat factor, GLfloat units);
using GLCopyTexImage1D = void(*)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
using GLCopyTexImage2D = void(*)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
using GLCopyTexSubImage1D = void(*)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
using GLCopyTexSubImage2D = void(*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
using GLTexSubImage1D = void(*)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
using GLTexSubImage2D = void(*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
using GLBindTexture = void(*)(GLenum target, GLuint texture);
using GLDeleteTextures = void(*)(GLsizei n, const GLuint *textures);
using GLGenTextures = void(*)(GLsizei n, GLuint *textures);
using GLDrawRangeElements = void(*)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
using GLTexImage3D = void(*)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
using GLTexSubImage3D = void(*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
using GLCopyTexSubImage3D = void(*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
using GLActiveTexture = void(*)(GLenum texture);
using GLSampleCoverage = void(*)(GLfloat value, GLboolean invert);
using GLCompressedTexImage3D = void(*)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
using GLCompressedTexImage2D = void(*)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
using GLCompressedTexImage1D = void(*)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
using GLCompressedTexSubImage3D = void(*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
using GLCompressedTexSubImage2D = void(*)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
using GLCompressedTexSubImage1D = void(*)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
using GLGetCompressedTexImage = void(*)(GLenum target, GLint level, void *img);
using GLBlendFuncSeparate = void(*)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
using GLMultiDrawArrays = void(*)(GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
using GLMultiDrawElements = void(*)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
using GLPointParameterf = void(*)(GLenum pname, GLfloat param);
using GLPointParameterfv = void(*)(GLenum pname, const GLfloat *params);
using GLPointParameteri = void(*)(GLenum pname, GLint param);
using GLPointParameteriv = void(*)(GLenum pname, const GLint *params);
using GLBlendColor = void(*)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
using GLBlendEquation = void(*)(GLenum mode);
using GLGenQueries = void(*)(GLsizei n, GLuint *ids);
using GLDeleteQueries = void(*)(GLsizei n, const GLuint *ids);
using GLBeginQuery = void(*)(GLenum target, GLuint id);
using GLEndQuery = void(*)(GLenum target);
using GLGetQueryiv = void(*)(GLenum target, GLenum pname, GLint *params);
using GLGetQueryObjectiv = void(*)(GLuint id, GLenum pname, GLint *params);
using GLGetQueryObjectuiv = void(*)(GLuint id, GLenum pname, GLuint *params);
using GLBindBuffer = void(*)(GLenum target, GLuint buffer);
using GLDeleteBuffers = void(*)(GLsizei n, const GLuint *buffers);
using GLGenBuffers = void(*)(GLsizei n, GLuint *buffers);
using GLBufferData = void(*)(GLenum target, GLsizeiptr size, const void *data, GLenum usage);
using GLBufferSubData = void(*)(GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
using GLGetBufferSubData = void(*)(GLenum target, GLintptr offset, GLsizeiptr size, void *data);
using GLGetBufferParameteriv = void(*)(GLenum target, GLenum pname, GLint *params);
using GLGetBufferPointerv = void(*)(GLenum target, GLenum pname, void **params);
using GLBlendEquationSeparate = void(*)(GLenum modeRGB, GLenum modeAlpha);
using GLDrawBuffers = void(*)(GLsizei n, const GLenum *bufs);
using GLStencilOpSeparate = void(*)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
using GLStencilFuncSeparate = void(*)(GLenum face, GLenum func, GLint ref, GLuint mask);
using GLStencilMaskSeparate = void(*)(GLenum face, GLuint mask);
using GLAttachShader = void(*)(GLuint program, GLuint shader);
using GLBindAttribLocation = void(*)(GLuint program, GLuint index, const GLchar *name);
using GLCompileShader = void(*)(GLuint shader);
using GLDeleteProgram = void(*)(GLuint program);
using GLDeleteShader = void(*)(GLuint shader);
using GLDetachShader = void(*)(GLuint program, GLuint shader);
using GLDisableVertexAttribArray = void(*)(GLuint index);
using GLEnableVertexAttribArray = void(*)(GLuint index);
using GLGetActiveAttrib = void(*)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
using GLGetActiveUniform = void(*)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
using GLGetAttachedShaders = void(*)(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
using GLGetProgramiv = void(*)(GLuint program, GLenum pname, GLint *params);
using GLGetProgramInfoLog = void(*)(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
using GLGetShaderiv = void(*)(GLuint shader, GLenum pname, GLint *params);
using GLGetShaderInfoLog = void(*)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
using GLGetShaderSource = void(*)(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
using GLGetUniformfv = void(*)(GLuint program, GLint location, GLfloat *params);
using GLGetUniformiv = void(*)(GLuint program, GLint location, GLint *params);
using GLGetVertexAttribdv = void(*)(GLuint index, GLenum pname, GLdouble *params);
using GLGetVertexAttribfv = void(*)(GLuint index, GLenum pname, GLfloat *params);
using GLGetVertexAttribiv = void(*)(GLuint index, GLenum pname, GLint *params);
using GLGetVertexAttribPointerv = void(*)(GLuint index, GLenum pname, void **pointer);
using GLLinkProgram = void(*)(GLuint program);
using GLShaderSource = void(*)(GLuint shader, GLsizei count, const GLchar *const*string, const GLint *length);
using GLUseProgram = void(*)(GLuint program);
using GLUniform1f = void(*)(GLint location, GLfloat v0);
using GLUniform2f = void(*)(GLint location, GLfloat v0, GLfloat v1);
using GLUniform3f = void(*)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
using GLUniform4f = void(*)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
using GLUniform1i = void(*)(GLint location, GLint v0);
using GLUniform2i = void(*)(GLint location, GLint v0, GLint v1);
using GLUniform3i = void(*)(GLint location, GLint v0, GLint v1, GLint v2);
using GLUniform4i = void(*)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
using GLUniform1fv = void(*)(GLint location, GLsizei count, const GLfloat *value);
using GLUniform2fv = void(*)(GLint location, GLsizei count, const GLfloat *value);
using GLUniform3fv = void(*)(GLint location, GLsizei count, const GLfloat *value);
using GLUniform4fv = void(*)(GLint location, GLsizei count, const GLfloat *value);
using GLUniform1iv = void(*)(GLint location, GLsizei count, const GLint *value);
using GLUniform2iv = void(*)(GLint location, GLsizei count, const GLint *value);
using GLUniform3iv = void(*)(GLint location, GLsizei count, const GLint *value);
using GLUniform4iv = void(*)(GLint location, GLsizei count, const GLint *value);
using GLUniformMatrix2fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix3fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix4fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLValidateProgram = void(*)(GLuint program);
using GLVertexAttrib1d = void(*)(GLuint index, GLdouble x);
using GLVertexAttrib1dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttrib1f = void(*)(GLuint index, GLfloat x);
using GLVertexAttrib1fv = void(*)(GLuint index, const GLfloat *v);
using GLVertexAttrib1s = void(*)(GLuint index, GLshort x);
using GLVertexAttrib1sv = void(*)(GLuint index, const GLshort *v);
using GLVertexAttrib2d = void(*)(GLuint index, GLdouble x, GLdouble y);
using GLVertexAttrib2dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttrib2f = void(*)(GLuint index, GLfloat x, GLfloat y);
using GLVertexAttrib2fv = void(*)(GLuint index, const GLfloat *v);
using GLVertexAttrib2s = void(*)(GLuint index, GLshort x, GLshort y);
using GLVertexAttrib2sv = void(*)(GLuint index, const GLshort *v);
using GLVertexAttrib3d = void(*)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
using GLVertexAttrib3dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttrib3f = void(*)(GLuint index, GLfloat x, GLfloat y, GLfloat z);
using GLVertexAttrib3fv = void(*)(GLuint index, const GLfloat *v);
using GLVertexAttrib3s = void(*)(GLuint index, GLshort x, GLshort y, GLshort z);
using GLVertexAttrib3sv = void(*)(GLuint index, const GLshort *v);
using GLVertexAttrib4Nbv = void(*)(GLuint index, const GLbyte *v);
using GLVertexAttrib4Niv = void(*)(GLuint index, const GLint *v);
using GLVertexAttrib4Nsv = void(*)(GLuint index, const GLshort *v);
using GLVertexAttrib4Nub = void(*)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
using GLVertexAttrib4Nubv = void(*)(GLuint index, const GLubyte *v);
using GLVertexAttrib4Nuiv = void(*)(GLuint index, const GLuint *v);
using GLVertexAttrib4Nusv = void(*)(GLuint index, const GLushort *v);
using GLVertexAttrib4bv = void(*)(GLuint index, const GLbyte *v);
using GLVertexAttrib4d = void(*)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
using GLVertexAttrib4dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttrib4f = void(*)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
using GLVertexAttrib4fv = void(*)(GLuint index, const GLfloat *v);
using GLVertexAttrib4iv = void(*)(GLuint index, const GLint *v);
using GLVertexAttrib4s = void(*)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
using GLVertexAttrib4sv = void(*)(GLuint index, const GLshort *v);
using GLVertexAttrib4ubv = void(*)(GLuint index, const GLubyte *v);
using GLVertexAttrib4uiv = void(*)(GLuint index, const GLuint *v);
using GLVertexAttrib4usv = void(*)(GLuint index, const GLushort *v);
using GLVertexAttribPointer = void(*)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
using GLUniformMatrix2x3fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix3x2fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix2x4fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix4x2fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix3x4fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLUniformMatrix4x3fv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLColorMaski = void(*)(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
using GLGetBooleani_v = void(*)(GLenum target, GLuint index, GLboolean *data);
using GLGetIntegeri_v = void(*)(GLenum target, GLuint index, GLint *data);
using GLEnablei = void(*)(GLenum target, GLuint index);
using GLDisablei = void(*)(GLenum target, GLuint index);
using GLBeginTransformFeedback = void(*)(GLenum primitiveMode);
using GLEndTransformFeedback = void(*)(void);
using GLBindBufferRange = void(*)(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
using GLBindBufferBase = void(*)(GLenum target, GLuint index, GLuint buffer);
using GLTransformFeedbackVaryings = void(*)(GLuint program, GLsizei count, const GLchar *const*varyings, GLenum bufferMode);
using GLGetTransformFeedbackVarying = void(*)(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
using GLClampColor = void(*)(GLenum target, GLenum clamp);
using GLBeginConditionalRender = void(*)(GLuint id, GLenum mode);
using GLEndConditionalRender = void(*)(void);
using GLVertexAttribIPointer = void(*)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
using GLGetVertexAttribIiv = void(*)(GLuint index, GLenum pname, GLint *params);
using GLGetVertexAttribIuiv = void(*)(GLuint index, GLenum pname, GLuint *params);
using GLVertexAttribI1i = void(*)(GLuint index, GLint x);
using GLVertexAttribI2i = void(*)(GLuint index, GLint x, GLint y);
using GLVertexAttribI3i = void(*)(GLuint index, GLint x, GLint y, GLint z);
using GLVertexAttribI4i = void(*)(GLuint index, GLint x, GLint y, GLint z, GLint w);
using GLVertexAttribI1ui = void(*)(GLuint index, GLuint x);
using GLVertexAttribI2ui = void(*)(GLuint index, GLuint x, GLuint y);
using GLVertexAttribI3ui = void(*)(GLuint index, GLuint x, GLuint y, GLuint z);
using GLVertexAttribI4ui = void(*)(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
using GLVertexAttribI1iv = void(*)(GLuint index, const GLint *v);
using GLVertexAttribI2iv = void(*)(GLuint index, const GLint *v);
using GLVertexAttribI3iv = void(*)(GLuint index, const GLint *v);
using GLVertexAttribI4iv = void(*)(GLuint index, const GLint *v);
using GLVertexAttribI1uiv = void(*)(GLuint index, const GLuint *v);
using GLVertexAttribI2uiv = void(*)(GLuint index, const GLuint *v);
using GLVertexAttribI3uiv = void(*)(GLuint index, const GLuint *v);
using GLVertexAttribI4uiv = void(*)(GLuint index, const GLuint *v);
using GLVertexAttribI4bv = void(*)(GLuint index, const GLbyte *v);
using GLVertexAttribI4sv = void(*)(GLuint index, const GLshort *v);
using GLVertexAttribI4ubv = void(*)(GLuint index, const GLubyte *v);
using GLVertexAttribI4usv = void(*)(GLuint index, const GLushort *v);
using GLGetUniformuiv = void(*)(GLuint program, GLint location, GLuint *params);
using GLBindFragDataLocation = void(*)(GLuint program, GLuint color, const GLchar *name);
using GLUniform1ui = void(*)(GLint location, GLuint v0);
using GLUniform2ui = void(*)(GLint location, GLuint v0, GLuint v1);
using GLUniform3ui = void(*)(GLint location, GLuint v0, GLuint v1, GLuint v2);
using GLUniform4ui = void(*)(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
using GLUniform1uiv = void(*)(GLint location, GLsizei count, const GLuint *value);
using GLUniform2uiv = void(*)(GLint location, GLsizei count, const GLuint *value);
using GLUniform3uiv = void(*)(GLint location, GLsizei count, const GLuint *value);
using GLUniform4uiv = void(*)(GLint location, GLsizei count, const GLuint *value);
using GLTexParameterIiv = void(*)(GLenum target, GLenum pname, const GLint *params);
using GLTexParameterIuiv = void(*)(GLenum target, GLenum pname, const GLuint *params);
using GLGetTexParameterIiv = void(*)(GLenum target, GLenum pname, GLint *params);
using GLGetTexParameterIuiv = void(*)(GLenum target, GLenum pname, GLuint *params);
using GLClearBufferiv = void(*)(GLenum buffer, GLint drawbuffer, const GLint *value);
using GLClearBufferuiv = void(*)(GLenum buffer, GLint drawbuffer, const GLuint *value);
using GLClearBufferfv = void(*)(GLenum buffer, GLint drawbuffer, const GLfloat *value);
using GLClearBufferfi = void(*)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
using GLBindRenderbuffer = void(*)(GLenum target, GLuint renderbuffer);
using GLDeleteRenderbuffers = void(*)(GLsizei n, const GLuint *renderbuffers);
using GLGenRenderbuffers = void(*)(GLsizei n, GLuint *renderbuffers);
using GLRenderbufferStorage = void(*)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
using GLGetRenderbufferParameteriv = void(*)(GLenum target, GLenum pname, GLint *params);
using GLBindFramebuffer = void(*)(GLenum target, GLuint framebuffer);
using GLDeleteFramebuffers = void(*)(GLsizei n, const GLuint *framebuffers);
using GLGenFramebuffers = void(*)(GLsizei n, GLuint *framebuffers);
using GLFramebufferTexture1D = void(*)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
using GLFramebufferTexture2D = void(*)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
using GLFramebufferTexture3D = void(*)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
using GLFramebufferRenderbuffer = void(*)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
using GLGetFramebufferAttachmentParameteriv = void(*)(GLenum target, GLenum attachment, GLenum pname, GLint *params);
using GLGenerateMipmap = void(*)(GLenum target);
using GLBlitFramebuffer = void(*)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
using GLRenderbufferStorageMultisample = void(*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
using GLFramebufferTextureLayer = void(*)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
using GLFlushMappedBufferRange = void(*)(GLenum target, GLintptr offset, GLsizeiptr length);
using GLBindVertexArray = void(*)(GLuint array);
using GLDeleteVertexArrays = void(*)(GLsizei n, const GLuint *arrays);
using GLGenVertexArrays = void(*)(GLsizei n, GLuint *arrays);
using GLDrawArraysInstanced = void(*)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
using GLDrawElementsInstanced = void(*)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
using GLTexBuffer = void(*)(GLenum target, GLenum internalformat, GLuint buffer);
using GLPrimitiveRestartIndex = void(*)(GLuint index);
using GLCopyBufferSubData = void(*)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
using GLGetUniformIndices = void(*)(GLuint program, GLsizei uniformCount, const GLchar *const*uniformNames, GLuint *uniformIndices);
using GLGetActiveUniformsiv = void(*)(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
using GLGetActiveUniformName = void(*)(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
using GLGetActiveUniformBlockiv = void(*)(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
using GLGetActiveUniformBlockName = void(*)(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
using GLUniformBlockBinding = void(*)(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
using GLDrawElementsBaseVertex = void(*)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
using GLDrawRangeElementsBaseVertex = void(*)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
using GLDrawElementsInstancedBaseVertex = void(*)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
using GLMultiDrawElementsBaseVertex = void(*)(GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
using GLProvokingVertex = void(*)(GLenum mode);
using GLDeleteSync = void(*)(GLSync* sync);
using GLWaitSync = void(*)(GLSync* sync, GLbitfield flags, GLuint64 timeout);
using GLGetInteger64v = void(*)(GLenum pname, GLint64 *data);
using GLGetSynciv = void(*)(GLSync* sync, GLenum pname, GLsizei count, GLsizei *length, GLint *values);
using GLGetInteger64i_v = void(*)(GLenum target, GLuint index, GLint64 *data);
using GLGetBufferParameteri64v = void(*)(GLenum target, GLenum pname, GLint64 *params);
using GLFramebufferTexture = void(*)(GLenum target, GLenum attachment, GLuint texture, GLint level);
using GLTexImage2DMultisample = void(*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
using GLTexImage3DMultisample = void(*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
using GLGetMultisamplefv = void(*)(GLenum pname, GLuint index, GLfloat *val);
using GLSampleMaski = void(*)(GLuint maskNumber, GLbitfield mask);
using GLBindFragDataLocationIndexed = void(*)(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
using GLGenSamplers = void(*)(GLsizei count, GLuint *samplers);
using GLDeleteSamplers = void(*)(GLsizei count, const GLuint *samplers);
using GLBindSampler = void(*)(GLuint unit, GLuint sampler);
using GLSamplerParameteri = void(*)(GLuint sampler, GLenum pname, GLint param);
using GLSamplerParameteriv = void(*)(GLuint sampler, GLenum pname, const GLint *param);
using GLSamplerParameterf = void(*)(GLuint sampler, GLenum pname, GLfloat param);
using GLSamplerParameterfv = void(*)(GLuint sampler, GLenum pname, const GLfloat *param);
using GLSamplerParameterIiv = void(*)(GLuint sampler, GLenum pname, const GLint *param);
using GLSamplerParameterIuiv = void(*)(GLuint sampler, GLenum pname, const GLuint *param);
using GLGetSamplerParameteriv = void(*)(GLuint sampler, GLenum pname, GLint *params);
using GLGetSamplerParameterIiv = void(*)(GLuint sampler, GLenum pname, GLint *params);
using GLGetSamplerParameterfv = void(*)(GLuint sampler, GLenum pname, GLfloat *params);
using GLGetSamplerParameterIuiv = void(*)(GLuint sampler, GLenum pname, GLuint *params);
using GLQueryCounter = void(*)(GLuint id, GLenum target);
using GLGetQueryObjecti64v = void(*)(GLuint id, GLenum pname, GLint64 *params);
using GLGetQueryObjectui64v = void(*)(GLuint id, GLenum pname, GLuint64 *params);
using GLVertexAttribDivisor = void(*)(GLuint index, GLuint divisor);
using GLVertexAttribP1ui = void(*)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
using GLVertexAttribP1uiv = void(*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
using GLVertexAttribP2ui = void(*)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
using GLVertexAttribP2uiv = void(*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
using GLVertexAttribP3ui = void(*)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
using GLVertexAttribP3uiv = void(*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
using GLVertexAttribP4ui = void(*)(GLuint index, GLenum type, GLboolean normalized, GLuint value);
using GLVertexAttribP4uiv = void(*)(GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
using GLVertexP2ui = void(*)(GLenum type, GLuint value);
using GLVertexP2uiv = void(*)(GLenum type, const GLuint *value);
using GLVertexP3ui = void(*)(GLenum type, GLuint value);
using GLVertexP3uiv = void(*)(GLenum type, const GLuint *value);
using GLVertexP4ui = void(*)(GLenum type, GLuint value);
using GLVertexP4uiv = void(*)(GLenum type, const GLuint *value);
using GLTexCoordP1ui = void(*)(GLenum type, GLuint coords);
using GLTexCoordP1uiv = void(*)(GLenum type, const GLuint *coords);
using GLTexCoordP2ui = void(*)(GLenum type, GLuint coords);
using GLTexCoordP2uiv = void(*)(GLenum type, const GLuint *coords);
using GLTexCoordP3ui = void(*)(GLenum type, GLuint coords);
using GLTexCoordP3uiv = void(*)(GLenum type, const GLuint *coords);
using GLTexCoordP4ui = void(*)(GLenum type, GLuint coords);
using GLTexCoordP4uiv = void(*)(GLenum type, const GLuint *coords);
using GLMultiTexCoordP1ui = void(*)(GLenum texture, GLenum type, GLuint coords);
using GLMultiTexCoordP1uiv = void(*)(GLenum texture, GLenum type, const GLuint *coords);
using GLMultiTexCoordP2ui = void(*)(GLenum texture, GLenum type, GLuint coords);
using GLMultiTexCoordP2uiv = void(*)(GLenum texture, GLenum type, const GLuint *coords);
using GLMultiTexCoordP3ui = void(*)(GLenum texture, GLenum type, GLuint coords);
using GLMultiTexCoordP3uiv = void(*)(GLenum texture, GLenum type, const GLuint *coords);
using GLMultiTexCoordP4ui = void(*)(GLenum texture, GLenum type, GLuint coords);
using GLMultiTexCoordP4uiv = void(*)(GLenum texture, GLenum type, const GLuint *coords);
using GLNormalP3ui = void(*)(GLenum type, GLuint coords);
using GLNormalP3uiv = void(*)(GLenum type, const GLuint *coords);
using GLColorP3ui = void(*)(GLenum type, GLuint color);
using GLColorP3uiv = void(*)(GLenum type, const GLuint *color);
using GLColorP4ui = void(*)(GLenum type, GLuint color);
using GLColorP4uiv = void(*)(GLenum type, const GLuint *color);
using GLSecondaryColorP3ui = void(*)(GLenum type, GLuint color);
using GLSecondaryColorP3uiv = void(*)(GLenum type, const GLuint *color);
using GLMinSampleShading = void(*)(GLfloat value);
using GLBlendEquationi = void(*)(GLuint buf, GLenum mode);
using GLBlendEquationSeparatei = void(*)(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
using GLBlendFunci = void(*)(GLuint buf, GLenum src, GLenum dst);
using GLBlendFuncSeparatei = void(*)(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
using GLDrawArraysIndirect = void(*)(GLenum mode, const void *indirect);
using GLDrawElementsIndirect = void(*)(GLenum mode, GLenum type, const void *indirect);
using GLUniform1d = void(*)(GLint location, GLdouble x);
using GLUniform2d = void(*)(GLint location, GLdouble x, GLdouble y);
using GLUniform3d = void(*)(GLint location, GLdouble x, GLdouble y, GLdouble z);
using GLUniform4d = void(*)(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
using GLUniform1dv = void(*)(GLint location, GLsizei count, const GLdouble *value);
using GLUniform2dv = void(*)(GLint location, GLsizei count, const GLdouble *value);
using GLUniform3dv = void(*)(GLint location, GLsizei count, const GLdouble *value);
using GLUniform4dv = void(*)(GLint location, GLsizei count, const GLdouble *value);
using GLUniformMatrix2dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix3dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix4dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix2x3dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix2x4dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix3x2dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix3x4dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix4x2dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLUniformMatrix4x3dv = void(*)(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLGetUniformdv = void(*)(GLuint program, GLint location, GLdouble *params);
using GLGetActiveSubroutineUniformiv = void(*)(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
using GLGetActiveSubroutineUniformName = void(*)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
using GLGetActiveSubroutineName = void(*)(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
using GLUniformSubroutinesuiv = void(*)(GLenum shadertype, GLsizei count, const GLuint *indices);
using GLGetUniformSubroutineuiv = void(*)(GLenum shadertype, GLint location, GLuint *params);
using GLGetProgramStageiv = void(*)(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
using GLPatchParameteri = void(*)(GLenum pname, GLint value);
using GLPatchParameterfv = void(*)(GLenum pname, const GLfloat *values);
using GLBindTransformFeedback = void(*)(GLenum target, GLuint id);
using GLDeleteTransformFeedbacks = void(*)(GLsizei n, const GLuint *ids);
using GLGenTransformFeedbacks = void(*)(GLsizei n, GLuint *ids);
using GLPauseTransformFeedback = void(*)(void);
using GLResumeTransformFeedback = void(*)(void);
using GLDrawTransformFeedback = void(*)(GLenum mode, GLuint id);
using GLDrawTransformFeedbackStream = void(*)(GLenum mode, GLuint id, GLuint stream);
using GLBeginQueryIndexed = void(*)(GLenum target, GLuint index, GLuint id);
using GLEndQueryIndexed = void(*)(GLenum target, GLuint index);
using GLGetQueryIndexediv = void(*)(GLenum target, GLuint index, GLenum pname, GLint *params);
using GLReleaseShaderCompiler = void(*)(void);
using GLShaderBinary = void(*)(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
using GLGetShaderPrecisionFormat = void(*)(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
using GLDepthRangef = void(*)(GLfloat n, GLfloat f);
using GLClearDepthf = void(*)(GLfloat d);
using GLGetProgramBinary = void(*)(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
using GLProgramBinary = void(*)(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
using GLProgramParameteri = void(*)(GLuint program, GLenum pname, GLint value);
using GLUseProgramStages = void(*)(GLuint pipeline, GLbitfield stages, GLuint program);
using GLActiveShaderProgram = void(*)(GLuint pipeline, GLuint program);
using GLBindProgramPipeline = void(*)(GLuint pipeline);
using GLDeleteProgramPipelines = void(*)(GLsizei n, const GLuint *pipelines);
using GLGenProgramPipelines = void(*)(GLsizei n, GLuint *pipelines);
using GLGetProgramPipelineiv = void(*)(GLuint pipeline, GLenum pname, GLint *params);
using GLProgramUniform1i = void(*)(GLuint program, GLint location, GLint v0);
using GLProgramUniform1iv = void(*)(GLuint program, GLint location, GLsizei count, const GLint *value);
using GLProgramUniform1f = void(*)(GLuint program, GLint location, GLfloat v0);
using GLProgramUniform1fv = void(*)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
using GLProgramUniform1d = void(*)(GLuint program, GLint location, GLdouble v0);
using GLProgramUniform1dv = void(*)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
using GLProgramUniform1ui = void(*)(GLuint program, GLint location, GLuint v0);
using GLProgramUniform1uiv = void(*)(GLuint program, GLint location, GLsizei count, const GLuint *value);
using GLProgramUniform2i = void(*)(GLuint program, GLint location, GLint v0, GLint v1);
using GLProgramUniform2iv = void(*)(GLuint program, GLint location, GLsizei count, const GLint *value);
using GLProgramUniform2f = void(*)(GLuint program, GLint location, GLfloat v0, GLfloat v1);
using GLProgramUniform2fv = void(*)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
using GLProgramUniform2d = void(*)(GLuint program, GLint location, GLdouble v0, GLdouble v1);
using GLProgramUniform2dv = void(*)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
using GLProgramUniform2ui = void(*)(GLuint program, GLint location, GLuint v0, GLuint v1);
using GLProgramUniform2uiv = void(*)(GLuint program, GLint location, GLsizei count, const GLuint *value);
using GLProgramUniform3i = void(*)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
using GLProgramUniform3iv = void(*)(GLuint program, GLint location, GLsizei count, const GLint *value);
using GLProgramUniform3f = void(*)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
using GLProgramUniform3fv = void(*)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
using GLProgramUniform3d = void(*)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
using GLProgramUniform3dv = void(*)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
using GLProgramUniform3ui = void(*)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
using GLProgramUniform3uiv = void(*)(GLuint program, GLint location, GLsizei count, const GLuint *value);
using GLProgramUniform4i = void(*)(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
using GLProgramUniform4iv = void(*)(GLuint program, GLint location, GLsizei count, const GLint *value);
using GLProgramUniform4f = void(*)(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
using GLProgramUniform4fv = void(*)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
using GLProgramUniform4d = void(*)(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
using GLProgramUniform4dv = void(*)(GLuint program, GLint location, GLsizei count, const GLdouble *value);
using GLProgramUniform4ui = void(*)(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
using GLProgramUniform4uiv = void(*)(GLuint program, GLint location, GLsizei count, const GLuint *value);
using GLProgramUniformMatrix2fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix3fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix4fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix2dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix3dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix4dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix2x3fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix3x2fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix2x4fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix4x2fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix3x4fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix4x3fv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
using GLProgramUniformMatrix2x3dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix3x2dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix2x4dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix4x2dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix3x4dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLProgramUniformMatrix4x3dv = void(*)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
using GLValidateProgramPipeline = void(*)(GLuint pipeline);
using GLGetProgramPipelineInfoLog = void(*)(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
using GLVertexAttribL1d = void(*)(GLuint index, GLdouble x);
using GLVertexAttribL2d = void(*)(GLuint index, GLdouble x, GLdouble y);
using GLVertexAttribL3d = void(*)(GLuint index, GLdouble x, GLdouble y, GLdouble z);
using GLVertexAttribL4d = void(*)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
using GLVertexAttribL1dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttribL2dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttribL3dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttribL4dv = void(*)(GLuint index, const GLdouble *v);
using GLVertexAttribLPointer = void(*)(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
using GLGetVertexAttribLdv = void(*)(GLuint index, GLenum pname, GLdouble *params);
using GLViewportArrayv = void(*)(GLuint first, GLsizei count, const GLfloat *v);
using GLViewportIndexedf = void(*)(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
using GLViewportIndexedfv = void(*)(GLuint index, const GLfloat *v);
using GLScissorArrayv = void(*)(GLuint first, GLsizei count, const GLint *v);
using GLScissorIndexed = void(*)(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
using GLScissorIndexedv = void(*)(GLuint index, const GLint *v);
using GLDepthRangeArrayv = void(*)(GLuint first, GLsizei count, const GLdouble *v);
using GLDepthRangeIndexed = void(*)(GLuint index, GLdouble n, GLdouble f);
using GLGetFloati_v = void(*)(GLenum target, GLuint index, GLfloat *data);
using GLGetDoublei_v = void(*)(GLenum target, GLuint index, GLdouble *data);
using GLDrawArraysInstancedBaseInstance = void(*)(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
using GLDrawElementsInstancedBaseInstance = void(*)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
using GLDrawElementsInstancedBaseVertexBaseInstance = void(*)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
using GLGetInternalformativ = void(*)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params);
using GLGetActiveAtomicCounterBufferiv = void(*)(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
using GLBindImageTexture = void(*)(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
using GLMemoryBarrier = void(*)(GLbitfield barriers);
using GLTexStorage1D = void(*)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
using GLTexStorage2D = void(*)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
using GLTexStorage3D = void(*)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
using GLDrawTransformFeedbackInstanced = void(*)(GLenum mode, GLuint id, GLsizei instancecount);
using GLDrawTransformFeedbackStreamInstanced = void(*)(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount);
using GLClearBufferData = void(*)(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
using GLClearBufferSubData = void(*)(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
using GLDispatchCompute = void(*)(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
using GLDispatchComputeIndirect = void(*)(GLintptr indirect);
using GLCopyImageSubData = void(*)(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
using GLFramebufferParameteri = void(*)(GLenum target, GLenum pname, GLint param);
using GLGetFramebufferParameteriv = void(*)(GLenum target, GLenum pname, GLint *params);
using GLGetInternalformati64v = void(*)(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params);
using GLInvalidateTexSubImage = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
using GLInvalidateTexImage = void(*)(GLuint texture, GLint level);
using GLInvalidateBufferSubData = void(*)(GLuint buffer, GLintptr offset, GLsizeiptr length);
using GLInvalidateBufferData = void(*)(GLuint buffer);
using GLInvalidateFramebuffer = void(*)(GLenum target, GLsizei numAttachments, const GLenum *attachments);
using GLInvalidateSubFramebuffer = void(*)(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
using GLMultiDrawArraysIndirect = void(*)(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
using GLMultiDrawElementsIndirect = void(*)(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
using GLGetProgramInterfaceiv = void(*)(GLuint program, GLenum programInterface, GLenum pname, GLint *params);
using GLGetProgramResourceName = void(*)(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name);
using GLGetProgramResourceiv = void(*)(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params);
using GLShaderStorageBlockBinding = void(*)(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
using GLTexBufferRange = void(*)(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
using GLTexStorage2DMultisample = void(*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
using GLTexStorage3DMultisample = void(*)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
using GLTextureView = void(*)(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
using GLBindVertexBuffer = void(*)(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
using GLVertexAttribFormat = void(*)(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
using GLVertexAttribIFormat = void(*)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
using GLVertexAttribLFormat = void(*)(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
using GLVertexAttribBinding = void(*)(GLuint attribindex, GLuint bindingindex);
using GLVertexBindingDivisor = void(*)(GLuint bindingindex, GLuint divisor);
using GLDebugMessageControl = void(*)(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
using GLDebugMessageInsert = void(*)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
using GLDebugMessageCallback = void(*)(GLDebugProc callback, const void *userParam);
using GLPushDebugGroup = void(*)(GLenum source, GLuint id, GLsizei length, const GLchar *message);
using GLPopDebugGroup = void(*)(void);
using GLObjectLabel = void(*)(GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
using GLGetObjectLabel = void(*)(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label);
using GLObjectPtrLabel = void(*)(const void *ptr, GLsizei length, const GLchar *label);
using GLGetObjectPtrLabel = void(*)(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label);
using GLGetPointerv = void(*)(GLenum pname, void **params);
using GLBufferStorage = void(*)(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
using GLClearTexImage = void(*)(GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
using GLClearTexSubImage = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
using GLBindBuffersBase = void(*)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
using GLBindBuffersRange = void(*)(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
using GLBindTextures = void(*)(GLuint first, GLsizei count, const GLuint *textures);
using GLBindSamplers = void(*)(GLuint first, GLsizei count, const GLuint *samplers);
using GLBindImageTextures = void(*)(GLuint first, GLsizei count, const GLuint *textures);
using GLBindVertexBuffers = void(*)(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
using GLClipControl = void(*)(GLenum origin, GLenum depth);
using GLCreateTransformFeedbacks = void(*)(GLsizei n, GLuint *ids);
using GLTransformFeedbackBufferBase = void(*)(GLuint xfb, GLuint index, GLuint buffer);
using GLTransformFeedbackBufferRange = void(*)(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
using GLGetTransformFeedbackiv = void(*)(GLuint xfb, GLenum pname, GLint *param);
using GLGetTransformFeedbacki_v = void(*)(GLuint xfb, GLenum pname, GLuint index, GLint *param);
using GLGetTransformFeedbacki64_v = void(*)(GLuint xfb, GLenum pname, GLuint index, GLint64 *param);
using GLCreateBuffers = void(*)(GLsizei n, GLuint *buffers);
using GLNamedBufferStorage = void(*)(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
using GLNamedBufferData = void(*)(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
using GLNamedBufferSubData = void(*)(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
using GLCopyNamedBufferSubData = void(*)(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
using GLClearNamedBufferData = void(*)(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
using GLClearNamedBufferSubData = void(*)(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
using GLFlushMappedNamedBufferRange = void(*)(GLuint buffer, GLintptr offset, GLsizeiptr length);
using GLGetNamedBufferParameteriv = void(*)(GLuint buffer, GLenum pname, GLint *params);
using GLGetNamedBufferParameteri64v = void(*)(GLuint buffer, GLenum pname, GLint64 *params);
using GLGetNamedBufferPointerv = void(*)(GLuint buffer, GLenum pname, void **params);
using GLGetNamedBufferSubData = void(*)(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
using GLCreateFramebuffers = void(*)(GLsizei n, GLuint *framebuffers);
using GLNamedFramebufferRenderbuffer = void(*)(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
using GLNamedFramebufferParameteri = void(*)(GLuint framebuffer, GLenum pname, GLint param);
using GLNamedFramebufferTexture = void(*)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
using GLNamedFramebufferTextureLayer = void(*)(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
using GLNamedFramebufferDrawBuffer = void(*)(GLuint framebuffer, GLenum buf);
using GLNamedFramebufferDrawBuffers = void(*)(GLuint framebuffer, GLsizei n, const GLenum *bufs);
using GLNamedFramebufferReadBuffer = void(*)(GLuint framebuffer, GLenum src);
using GLInvalidateNamedFramebufferData = void(*)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments);
using GLInvalidateNamedFramebufferSubData = void(*)(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height);
using GLClearNamedFramebufferiv = void(*)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value);
using GLClearNamedFramebufferuiv = void(*)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value);
using GLClearNamedFramebufferfv = void(*)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value);
using GLClearNamedFramebufferfi = void(*)(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
using GLBlitNamedFramebuffer = void(*)(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
using GLGetNamedFramebufferParameteriv = void(*)(GLuint framebuffer, GLenum pname, GLint *param);
using GLGetNamedFramebufferAttachmentParameteriv = void(*)(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params);
using GLCreateRenderbuffers = void(*)(GLsizei n, GLuint *renderbuffers);
using GLNamedRenderbufferStorage = void(*)(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
using GLNamedRenderbufferStorageMultisample = void(*)(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
using GLGetNamedRenderbufferParameteriv = void(*)(GLuint renderbuffer, GLenum pname, GLint *params);
using GLCreateTextures = void(*)(GLenum target, GLsizei n, GLuint *textures);
using GLTextureBuffer = void(*)(GLuint texture, GLenum internalformat, GLuint buffer);
using GLTextureBufferRange = void(*)(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
using GLTextureStorage1D = void(*)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
using GLTextureStorage2D = void(*)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
using GLTextureStorage3D = void(*)(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
using GLTextureStorage2DMultisample = void(*)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
using GLTextureStorage3DMultisample = void(*)(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
using GLTextureSubImage1D = void(*)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
using GLTextureSubImage2D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
using GLTextureSubImage3D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
using GLCompressedTextureSubImage1D = void(*)(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
using GLCompressedTextureSubImage2D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
using GLCompressedTextureSubImage3D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
using GLCopyTextureSubImage1D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
using GLCopyTextureSubImage2D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
using GLCopyTextureSubImage3D = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
using GLTextureParameterf = void(*)(GLuint texture, GLenum pname, GLfloat param);
using GLTextureParameterfv = void(*)(GLuint texture, GLenum pname, const GLfloat *param);
using GLTextureParameteri = void(*)(GLuint texture, GLenum pname, GLint param);
using GLTextureParameterIiv = void(*)(GLuint texture, GLenum pname, const GLint *params);
using GLTextureParameterIuiv = void(*)(GLuint texture, GLenum pname, const GLuint *params);
using GLTextureParameteriv = void(*)(GLuint texture, GLenum pname, const GLint *param);
using GLGenerateTextureMipmap = void(*)(GLuint texture);
using GLBindTextureUnit = void(*)(GLuint unit, GLuint texture);
using GLGetTextureImage = void(*)(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
using GLGetCompressedTextureImage = void(*)(GLuint texture, GLint level, GLsizei bufSize, void *pixels);
using GLGetTextureLevelParameterfv = void(*)(GLuint texture, GLint level, GLenum pname, GLfloat *params);
using GLGetTextureLevelParameteriv = void(*)(GLuint texture, GLint level, GLenum pname, GLint *params);
using GLGetTextureParameterfv = void(*)(GLuint texture, GLenum pname, GLfloat *params);
using GLGetTextureParameterIiv = void(*)(GLuint texture, GLenum pname, GLint *params);
using GLGetTextureParameterIuiv = void(*)(GLuint texture, GLenum pname, GLuint *params);
using GLGetTextureParameteriv = void(*)(GLuint texture, GLenum pname, GLint *params);
using GLCreateVertexArrays = void(*)(GLsizei n, GLuint *arrays);
using GLDisableVertexArrayAttrib = void(*)(GLuint vaobj, GLuint index);
using GLEnableVertexArrayAttrib = void(*)(GLuint vaobj, GLuint index);
using GLVertexArrayElementBuffer = void(*)(GLuint vaobj, GLuint buffer);
using GLVertexArrayVertexBuffer = void(*)(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
using GLVertexArrayVertexBuffers = void(*)(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
using GLVertexArrayAttribBinding = void(*)(GLuint vaobj, GLuint attribindex, GLuint bindingindex);
using GLVertexArrayAttribFormat = void(*)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
using GLVertexArrayAttribIFormat = void(*)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
using GLVertexArrayAttribLFormat = void(*)(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
using GLVertexArrayBindingDivisor = void(*)(GLuint vaobj, GLuint bindingindex, GLuint divisor);
using GLGetVertexArrayiv = void(*)(GLuint vaobj, GLenum pname, GLint *param);
using GLGetVertexArrayIndexediv = void(*)(GLuint vaobj, GLuint index, GLenum pname, GLint *param);
using GLGetVertexArrayIndexed64iv = void(*)(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param);
using GLCreateSamplers = void(*)(GLsizei n, GLuint *samplers);
using GLCreateProgramPipelines = void(*)(GLsizei n, GLuint *pipelines);
using GLCreateQueries = void(*)(GLenum target, GLsizei n, GLuint *ids);
using GLGetQueryBufferObjecti64v = void(*)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
using GLGetQueryBufferObjectiv = void(*)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
using GLGetQueryBufferObjectui64v = void(*)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
using GLGetQueryBufferObjectuiv = void(*)(GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
using GLMemoryBarrierByRegion = void(*)(GLbitfield barriers);
using GLGetTextureSubImage = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
using GLGetCompressedTextureSubImage = void(*)(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
using GLGetnCompressedTexImage = void(*)(GLenum target, GLint lod, GLsizei bufSize, void *pixels);
using GLGetnTexImage = void(*)(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
using GLGetnUniformdv = void(*)(GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
using GLGetnUniformfv = void(*)(GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
using GLGetnUniformiv = void(*)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
using GLGetnUniformuiv = void(*)(GLuint program, GLint location, GLsizei bufSize, GLuint *params);
using GLReadnPixels = void(*)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
using GLGetnMapdv = void(*)(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v);
using GLGetnMapfv = void(*)(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v);
using GLGetnMapiv = void(*)(GLenum target, GLenum query, GLsizei bufSize, GLint *v);
using GLGetnPixelMapfv = void(*)(GLenum map, GLsizei bufSize, GLfloat *values);
using GLGetnPixelMapuiv = void(*)(GLenum map, GLsizei bufSize, GLuint *values);
using GLGetnPixelMapusv = void(*)(GLenum map, GLsizei bufSize, GLushort *values);
using GLGetnPolygonStipple = void(*)(GLsizei bufSize, GLubyte *pattern);
using GLGetnColorTable = void(*)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
using GLGetnConvolutionFilter = void(*)(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
using GLGetnSeparableFilter = void(*)(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
using GLGetnHistogram = void(*)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
using GLGetnMinmax = void(*)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
using GLTextureBarrier = void(*)(void);
using GLSpecializeShader = void(*)(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);
using GLMultiDrawArraysIndirectCount = void(*)(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
using GLMultiDrawElementsIndirectCount = void(*)(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
using GLPolygonOffsetClamp = void(*)(GLfloat factor, GLfloat units, GLfloat clamp);
using GLBlendBarrier = void(*)(void);
using GLPrimitiveBoundingBox = void(*)(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);

} /* namespace boom */